<!DOCTYPE html>


<html lang="ko-kr" data-theme="">
<head>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>[Javascript] async/await 알아보기 (w. V8 Engine, task, microtask) - 오늘도 개발을 한다.</title>

<meta name="description" content="서론CS 스터디에서 9월 10일에 발표한 async function과 await 키워드에 대해 정리한 문서를 블로그에 공유하고자 한다.
async function - await는 어떻게 동작할까?async/await란?async function이란, 여러 Promise간의 흐름을 순서대로 처리할 수 있는, 즉 여러 비동기 함수들을 동기적인 순서로 진행할 수 있는 함수를 말합니다.
async function은 0개 이상의 await 키워드를 포함할 수 있는데, 함수를 진행하다 await가 달린 Promise를 만나게 되면 해당 Promise가 이행/거부될 때 까지 함수 실행을 일시 중단 하며 처리가 완료된 뒤 다시 진행됩니다.">





<link rel="icon" type="image/x-icon" href="https://cloudsoswift.github.io/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="https://cloudsoswift.github.io/favicon.png">




    



<style>
  body {
    visibility: hidden;
    opacity: 0;
  }
</style>

<noscript>
  <style>
    body {
      visibility: visible;
      opacity: 1;
    }
  </style>
</noscript>




    





    
    
        
    
    

    
        <link rel="stylesheet" href="https://cloudsoswift.github.io/css/style.min.a863b4abb00ba3862e5d085827416c340f13ee98e430b3fca75a05d676a6ee88.css" integrity="sha256-qGO0q7ALo4YuXQhYJ0FsNA8T7pjkMLP8p1oF1nam7og=">
    





    

    





    
    
        
    
    

    
        <script src="https://cloudsoswift.github.io/js/script.min.74bf1a3fcf1af396efa4acf3e660e876b61a2153ab9cbe1893ac24ea6d4f94ee.js" type="text/javascript" charset="utf-8" integrity="sha256-dL8aP88a85bvpKzz5mDodrYaIVOrnL4Yk6wk6m1PlO4="></script>
    







<meta property="og:title" content="[Javascript] async/await 알아보기 (w. V8 Engine, task, microtask)" />
<meta property="og:description" content="서론CS 스터디에서 9월 10일에 발표한 async function과 await 키워드에 대해 정리한 문서를 블로그에 공유하고자 한다.
async function - await는 어떻게 동작할까?async/await란?async function이란, 여러 Promise간의 흐름을 순서대로 처리할 수 있는, 즉 여러 비동기 함수들을 동기적인 순서로 진행할 수 있는 함수를 말합니다.
async function은 0개 이상의 await 키워드를 포함할 수 있는데, 함수를 진행하다 await가 달린 Promise를 만나게 되면 해당 Promise가 이행/거부될 때 까지 함수 실행을 일시 중단 하며 처리가 완료된 뒤 다시 진행됩니다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cloudsoswift.github.io/post/develop/javascript/async-await/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2024-09-14T20:55:53+09:00" />
<meta property="article:modified_time" content="2024-09-14T20:55:53+09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[Javascript] async/await 알아보기 (w. V8 Engine, task, microtask)"/>
<meta name="twitter:description" content="서론CS 스터디에서 9월 10일에 발표한 async function과 await 키워드에 대해 정리한 문서를 블로그에 공유하고자 한다.
async function - await는 어떻게 동작할까?async/await란?async function이란, 여러 Promise간의 흐름을 순서대로 처리할 수 있는, 즉 여러 비동기 함수들을 동기적인 순서로 진행할 수 있는 함수를 말합니다.
async function은 0개 이상의 await 키워드를 포함할 수 있는데, 함수를 진행하다 await가 달린 Promise를 만나게 되면 해당 Promise가 이행/거부될 때 까지 함수 실행을 일시 중단 하며 처리가 완료된 뒤 다시 진행됩니다."/>













    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header class="common-header"> 
            
                <div class="header-top">
    <h1 class="site-title">
    <a href="/">오늘도 개발을 한다.</a>
</h1>
    <ul class="social-icons">


    
        <li>
            <a href="https://gohugo.io/documentation/" title="Docs" rel="me">
                <span class="inline-svg" >




    


</span>

            </a>
        </li>
    

    
        
        
        <li>
            <a href="https://github.com/cloudsoswift" title="Github" rel="me">
            <span class="inline-svg" >




    
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>

</span>

            </a>
        </li>
    




</ul>
</div>

    <nav>
        
        
        <a class="" href="https://cloudsoswift.github.io/about/" title="">About</a>
        
        <a class="" href="https://cloudsoswift.github.io/tags/" title="">태그</a>
        
        <a class="" href="https://cloudsoswift.github.io/post/" title="">글 목록</a>
        
        <a class="" href="https://cloudsoswift.github.io/categories/develop" title="">개발</a>
        
        <a class="" href="https://cloudsoswift.github.io/categories/etc" title="">기타</a>
        
    </nav>


<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



            
        </header>
        <main id="main" tabindex="-1"> 
            
    

    <article class="post h-entry">
        <div class="post-header">
            <header>
                <h1 class="p-name post-title">[Javascript] async/await 알아보기 (w. V8 Engine, task, microtask)</h1>

                
            </header>
        </div>
        




<nav id="TableOfContents">
  <ul>
    <li><a href="#asyncawait란"><code>async/await</code>란?</a>
      <ul>
        <li><a href="#asyncawait의-특징"><code>async/await</code>의 특징</a></li>
      </ul>
    </li>
    <li><a href="#async-function-내부의-await-동작"><code>async function</code> 내부의 <code>await</code> 동작</a>
      <ul>
        <li><a href="#그렇다면-asyncawait는-진짜-동기적으로-동작할까">그렇다면 <code>async/await</code>는 진짜 동기적으로 동작할까?</a></li>
        <li><a href="#event-loop-내부의-asyncawait-동작">Event Loop 내부의 <code>async/await</code> 동작</a></li>
        <li><a href="#asyncawait을-사용하면-비동기-병렬-처리가-불가능한가요"><code>async/await</code>을 사용하면, 비동기 병렬 처리가 불가능한가요?</a></li>
      </ul>
    </li>
    <li><a href="#v8-엔진에서의-내부-await-동작-과정-httpsv8devblogfast-async">V8 엔진에서의 내부 await 동작 과정 <a href="https://v8.dev/blog/fast-async">#</a></a></li>
    <li><a href="#자세히-살펴보기">자세히 살펴보기</a>
      <ul>
        <li><a href="#asyncawait-작업의-최적화"><code>async/await</code> 작업의 최적화</a></li>
      </ul>
    </li>
  </ul>
</nav>

        <div class="content e-content">
            <h1 id="서론" >서론
<span>
    <a href="#%ec%84%9c%eb%a1%a0">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h1><p><a href="https://github.com/orm712/CS-712">CS 스터디</a>에서 9월 10일에 발표한 <a href="https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/11_async-await/Readme.md"><strong>async function과 await 키워드</strong></a>에 대해 정리한 문서를 블로그에 공유하고자 한다.</p>
<h1 id="async-function---await는-어떻게-동작할까" ><code>async function</code> - <code>await</code>는 어떻게 동작할까?
<span>
    <a href="#async-function---await%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%a0%ea%b9%8c">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h1><h2 id="asyncawait란" ><code>async/await</code>란?
<span>
    <a href="#asyncawait%eb%9e%80">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><p><code>async function</code>이란, 여러 <code>Promise</code>간의 흐름을 순서대로 처리할 수 있는, 즉 여러 비동기 함수들을 동기적인 순서로 진행할 수 있는 함수를 말합니다.<br>
<code>async function</code>은 0개 이상의 <code>await</code> 키워드를 포함할 수 있는데, 함수를 진행하다 <code>await</code>가 달린 <code>Promise</code>를 만나게 되면 해당 <code>Promise</code>가 <em><code>이행</code>/<code>거부</code>될 때 까지</em> <strong>함수 실행을 <code>일시 중단</code></strong> 하며 처리가 완료된 뒤 다시 진행됩니다.<br>
즉, <code>Promise</code>를 반환하는 함수를 동기식인 것처럼 동작하도록 해줍니다.</p>
<ul>
<li>이는 <code>await</code> 이후의 코드를 <code>Promise.then()</code> 콜백에서 수행하는 것과 거의 유사</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 일반 Promise와 callback 예시
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getProcessedData</span>(<span style="color:#a6e22e">url</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">downloadData</span>(<span style="color:#a6e22e">url</span>) <span style="color:#75715e">// returns a promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .<span style="color:#66d9ef">catch</span>((<span style="color:#a6e22e">e</span>) =&gt; <span style="color:#a6e22e">downloadFallbackData</span>(<span style="color:#a6e22e">url</span>)) <span style="color:#75715e">// returns a promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    .<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">v</span>) =&gt; <span style="color:#a6e22e">processDataInWorker</span>(<span style="color:#a6e22e">v</span>)); <span style="color:#75715e">// returns a promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 위 예시를 async function - await로 변환한 예시
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getProcessedData</span>(<span style="color:#a6e22e">url</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">v</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">downloadData</span>(<span style="color:#a6e22e">url</span>);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">e</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">downloadFallbackData</span>(<span style="color:#a6e22e">url</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">processDataInWorker</span>(<span style="color:#a6e22e">v</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>또한, <code>async function</code>은 항상 <code>Promise</code>를 <code>반환</code>하며, 만약 <em>Promise가 아닌 값</em>을 반환(<code>심지어 아무것도 return하지 않아도!</code>)하는 경우 <em>암시적으로</em> <code>Promise</code>로 래핑되어 반환됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// Promise가 아닌 값을 반환하는 경우
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">abc</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">abc</span>(); <span style="color:#75715e">// Promise {&lt;fulfilled&gt;: 1}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 아무것도 반환하지 않는 경우
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">none</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">async</span> () =&gt; {};
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">none</span>(); <span style="color:#75715e">// Promise {&lt;fulfilled&gt;: undefined}
</span></span></span></code></pre></div><h3 id="asyncawait의-특징" ><code>async/await</code>의 특징
<span>
    <a href="#asyncawait%ec%9d%98-%ed%8a%b9%ec%a7%95">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><h4 id="어떠한-값이든-await-할-수-있음" >어떠한 값이든 <code>await</code> 할 수 있음
<span>
    <a href="#%ec%96%b4%eb%96%a0%ed%95%9c-%ea%b0%92%ec%9d%b4%eb%93%a0-await-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%8c">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h4><p>웬만한 경우, <code>Promise</code> 앞에 <code>await</code> 키워드를 붙여 비동기 작업의 결과를 기다리도록 합니다.<br>
하지만 실제로는 어떠한 <code>Javascript 값</code>이든 기다리게 할 수 있습니다.<br>
만약 <code>await</code> 키워드 뒤에 오는 <code>표현식</code>의 값이 <code>Promise</code>가 아닌 경우, 이를 <code>Promise</code>로 변환합니다.<br>
예를들어, <code>25</code>와 같은 아무런 숫자도 <code>await</code>를 붙일 수 있는 것입니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#ae81ff">25</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">foo</span>();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// → Promise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// `25`를 출력한다.
</span></span></span></code></pre></div><h4 id="await-은-어떠한-thenable-객체와도-정상-동작함" ><code>await</code> 은 어떠한 <code>thenable</code> 객체와도 정상 동작함
<span>
    <a href="#await-%ec%9d%80-%ec%96%b4%eb%96%a0%ed%95%9c-thenable-%ea%b0%9d%ec%b2%b4%ec%99%80%eb%8f%84-%ec%a0%95%ec%83%81-%eb%8f%99%ec%9e%91%ed%95%a8">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h4><p><code>await</code> 키워드는 어떤 객체든 <code>then</code> 메서드만 있다면 꼭 <code>Promise</code>가 아니어도 잘 동작하게 됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sleep</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">timeout</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">timeout</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">timeout</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">then</span>(<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">startTime</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(Date.<span style="color:#a6e22e">now</span>() <span style="color:#f92672">-</span> <span style="color:#a6e22e">startTime</span>),
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">timeout</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">async</span> () =&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">actualTime</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">actualTime</span>);
</span></span><span style="display:flex;"><span>})();
</span></span></code></pre></div><h2 id="async-function-내부의-await-동작" ><code>async function</code> 내부의 <code>await</code> 동작
<span>
    <a href="#async-function-%eb%82%b4%eb%b6%80%ec%9d%98-await-%eb%8f%99%ec%9e%91">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><p><code>async function</code>은 일반 함수처럼 진행되다가, <code>await</code> 키워드가 달린 <code>Promise</code>를 만나게 될 경우, 해당 <code>Promise</code>가 <code>resolve(또는 reject)</code>될 때까지 <code>async function</code>의 실행을 일시 중단합니다.<br>
이때, Javascript의 <code>논-블로킹</code> 특성상, <code>await</code> 키워드로 인해 <em>함수 실행이 멈추더라도</em> <code>다른 연산</code>들은 <code>백그라운드에서 계속 진행</code>됩니다.<br>
이는 <a href="../1_Promise-async/Readme.md">콜백 vs async</a> 에서 언급한 것처럼, <code>Javascript</code>에서는 코드 실행을 수행하는 <code>메인 스레드</code> 뿐만 아니라, <code>타이머 기반 작업</code>, <code>네트워크 요청</code> 등의 <code>비동기 작업</code>을 처리하는 <code>Web API</code>를 사용하기 때문입니다.<br>
즉, 만약 상기한 <code>비동기 작업</code>을 마주한다 해도 <code>메인 스레드</code>는 이를 <em>직접 처리하지 않고</em> <code>Web API</code>에게 이를 <code>전달</code>합니다. 따라서 해당 작업이 완료되길 <code>기다리지 않고</code> 이어지는 코드들을 <code>계속 실행</code>하게 됩니다.</p>
<h3 id="그렇다면-asyncawait는-진짜-동기적으로-동작할까" >그렇다면 <code>async/await</code>는 진짜 동기적으로 동작할까?
<span>
    <a href="#%ea%b7%b8%eb%a0%87%eb%8b%a4%eb%a9%b4-asyncawait%eb%8a%94-%ec%a7%84%ec%a7%9c-%eb%8f%99%ea%b8%b0%ec%a0%81%ec%9c%bc%eb%a1%9c-%eb%8f%99%ec%9e%91%ed%95%a0%ea%b9%8c">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;첫 번째 타이머&#39;</span>), <span style="color:#ae81ff">10000</span>);  
</span></span><span style="display:flex;"><span>});  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;두 번째 타이머&#39;</span>), <span style="color:#ae81ff">10000</span>);  
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><blockquote>
<p>코드 1</p>
</blockquote>
<p>위처럼 각각 10초 이후 문자열을 <code>resolve</code>하는 타이머 <code>t1</code>, <code>t2</code>를 예로 들어보겠습니다.<br>
만약 이 둘을 <code>async function</code> 내부에서 <code>await</code>를 달아주면 어떻게 동작할까요?<br>
10초짜리 타이머 2개가 동기적으로 호출될 것이니, 20초가 소요될까요?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;시작&#34;</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {  
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;첫 번째 타이머&#39;</span>), <span style="color:#ae81ff">10000</span>);  
</span></span><span style="display:flex;"><span>	});  
</span></span><span style="display:flex;"><span>	  
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {  
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;두 번째 타이머&#39;</span>), <span style="color:#ae81ff">10000</span>);  
</span></span><span style="display:flex;"><span>	});
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">startTime</span> <span style="color:#f92672">=</span> Date.<span style="color:#a6e22e">now</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">t1</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;T1에 소요된 시간 : &#34;</span>, Date.<span style="color:#a6e22e">now</span>() <span style="color:#f92672">-</span> <span style="color:#a6e22e">startTime</span>, <span style="color:#e6db74">&#34;ms&#34;</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">t2</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;T2에 소요된 시간 : &#34;</span>, Date.<span style="color:#a6e22e">now</span>() <span style="color:#f92672">-</span> <span style="color:#a6e22e">startTime</span>, <span style="color:#e6db74">&#34;ms&#34;</span>);
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;끝&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>(); <span style="color:#75715e">// ?
</span></span></span></code></pre></div><blockquote>
<p>코드 2</p>
</blockquote>
<p><img src="await-with-timer.png" alt="await-with-timer.png"><br>
하지만, 실제로는 두 타이머 작업을 수행하는데에 총 10초밖에 들지 않았습니다.<br>
그렇다면 작업이 동기적으로 수행되지 않은 걸까요?<br>
이를 이해하려면 Javascript Event Loop 내부 동작이 어떻게 수행되는지 알아야 합니다.</p>
<h3 id="event-loop-내부의-asyncawait-동작" >Event Loop 내부의 <code>async/await</code> 동작
<span>
    <a href="#event-loop-%eb%82%b4%eb%b6%80%ec%9d%98-asyncawait-%eb%8f%99%ec%9e%91">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><p>간단하게 설명하면, <code>Event Loop</code>는 Javascript 코드를 한 줄 한 줄 실행하면서, 지속적으로 <code>메시지 큐</code>에 <code>보류(Pending)중인 메시지</code>(ex. <code>resolve</code>된 <code>Promise</code>)를 확인하며 하나 하나 처리합니다.<br>
즉, <code>t1</code>, <code>t2</code>를 초기화하는 <code>코드 1</code> 코드를 <code>메인 스레드</code>가 읽고 실행한 순간, 백그라운드에서 해당 타이머 작업은 <code>Web API</code>에게 전달되어 실행되고 있는 것입니다.</p>
<ul>
<li><code>Promise()</code>의 첫 번째 인자로 주어진 함수는 즉시 실행됩니다.</li>
</ul>
<p>따라서 <code>t1</code>, <code>t2</code>는 백그라운드에서 동시에 실행되고 있으며, <code>메인 스레드</code>는 이후 이어지는 코드(<code>코드 2</code>)들을 계속 실행해나갑니다.<br>
그리고 <code>test()</code> 내부의 <code>await t1</code>에 도달했을 때, <code>t1</code>이 <code>resolve</code>될 때 까지 기다렸다가 코드 진행을 계속 이어나갑니다.<br>
<code>t1</code>과 <code>t2</code> 모두 10초짜리 타이머이므로, <code>t1</code>이 완료됨과 거의 동시에 <code>t2</code>도 완료되게 됩니다. 따라서 <code>await t2</code>는 거의 기다리지 않고 이후 코드들이 즉시 실행되게 됩니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;첫 번째 타이머&#39;</span>), <span style="color:#ae81ff">10000</span>);  
</span></span><span style="display:flex;"><span>});  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">t2</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>) =&gt; {  
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#39;두 번째 타이머&#39;</span>), <span style="color:#ae81ff">5000</span>);  
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>만약 <code>t2</code>를 5초로 줄이더라도, 백그라운드에서는 <code>t2</code>가 <code>t1</code>보다 먼저 완료되지만 <code>test()</code> 함수의 동작은 이전과 동일하게 작동합니다.</p>
<h3 id="asyncawait을-사용하면-비동기-병렬-처리가-불가능한가요" ><code>async/await</code>을 사용하면, 비동기 병렬 처리가 불가능한가요?
<span>
    <a href="#asyncawait%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%a9%b4-%eb%b9%84%eb%8f%99%ea%b8%b0-%eb%b3%91%eb%a0%ac-%ec%b2%98%eb%a6%ac%ea%b0%80-%eb%b6%88%ea%b0%80%eb%8a%a5%ed%95%9c%ea%b0%80%ec%9a%94">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><p>그렇지 않습니다. <code>Promise</code>의 <code>all</code> 또는 <code>allSettled</code> 함수를 통해 <code>await</code> 키워드를 사용하면서 비동기 작업들을 병렬적으로 처리할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fetchData</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">userDataPromise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fetchUserData</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">productDataPromise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fetchProductData</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">userData</span>, <span style="color:#a6e22e">productData</span>] <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> Promise.<span style="color:#a6e22e">all</span>([<span style="color:#a6e22e">userDataPromise</span>, <span style="color:#a6e22e">productDataPromise</span>]);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;User data:&#34;</span>, <span style="color:#a6e22e">userData</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Product data:&#34;</span>, <span style="color:#a6e22e">productData</span>);
</span></span><span style="display:flex;"><span>	}<span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">error</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#e6db74">&#34;Error fetching data:&#34;</span>, <span style="color:#a6e22e">error</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위 코드처럼, 병렬로 실행할 <code>비동기 작업(Promise)</code>들을 <code>배열(또는 Iterable 객체)</code>에 담아 <code>all</code> 또는 <code>allSettled</code>에 넘겨주면 이들을 병렬적으로 수행하게 됩니다.<br>
이후 배열의 모든 <code>비동기 작업</code>이 완료되면 코드 진행을 이어나갑니다.</p>
<h2 id="v8-엔진에서의-내부-await-동작-과정-httpsv8devblogfast-async" >V8 엔진에서의 내부 await 동작 과정 <a href="https://v8.dev/blog/fast-async">#</a>
<span>
    <a href="#v8-%ec%97%94%ec%a7%84%ec%97%90%ec%84%9c%ec%9d%98-%eb%82%b4%eb%b6%80-await-%eb%8f%99%ec%9e%91-%ea%b3%bc%ec%a0%95-httpsv8devblogfast-async">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foo</span>(<span style="color:#a6e22e">v</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">v</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">w</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>위와 같은 함수를 실행한다고 할 때, V8 엔진 내부에서는 아래와 같이 처리가 이뤄집니다.</p>
<p><img src="await-under-the-hood.svg" alt="await-under-the-hood.svg"></p>
<ol>
<li>V8 엔진이 <code>async function</code>을 <code>resumable</code>(<code>await</code> 위치에서 함수 실행을 중단하고 재개할 수 있음을 뜻함)하다고 표시합니다.
<ul>
<li>그런 다음 <code>implicit_promise</code>(<code>async function</code>을 호출할 때 반환되며, 최종적으로 <code>async function</code>이 생성한 값을 <code>resolve</code>하는 <code>Promise</code>)를 생성합니다.</li>
</ul>
</li>
<li><code>await</code>에 전달된 값(여기서는 <code>v</code>)을 <code>Promise</code>로 래핑합니다.</li>
<li>만약 <code>Promise</code>가 <code>이행(fulfilled)</code>되면 <code>async function</code>을 <code>재개</code>하도록 하는 <code>핸들러</code>를 래핑된 <code>Promise</code>에 연결합니다.</li>
<li><code>async function</code>의 실행을 <code>일시 중단(suspend)</code>한 뒤, 호출자에게 <code>implicit_promise</code>를 반환합니다.
<ul>
<li>이후 <code>Promise</code>가 이행된 경우, <code>Promise</code>의 값 <code>w</code>와 함께 <code>async function</code>이 재개되고 <code>implicit_promise</code>는 <code>w</code>를 <code>resolve</code>합니다.</li>
</ul>
</li>
</ol>
<h2 id="자세히-살펴보기" >자세히 살펴보기
<span>
    <a href="#%ec%9e%90%ec%84%b8%ed%9e%88-%ec%82%b4%ed%8e%b4%eb%b3%b4%ea%b8%b0">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h2><p>위 과정을 하나 하나 살펴보겠습니다.<br>
참고로 위 예시에서 <code>await</code>한 표현식이 <em>42라는 값으로 이행된</em> <code>Promise</code>라고 가정하겠습니다.<br>
<img src="await-step-1.svg" alt="await-step-1.svg">
엔진은 이 <code>await</code>된 값을 <code>promise</code>라는 <code>Promise</code>로 래핑합니다.<br>
이는 다음 차례에 <code>Promise</code>들의 <code>지연된 연쇄(deferred chaining)</code>를 수행합니다.</p>
<ul>
<li><code>ECMA 사양</code>에서는 이를 <a href="https://tc39.es/ecma262/#sec-promiseresolvethenablejob"><code>PromiseResolveThenableJob</code></a>이라고 부릅니다.</li>
</ul>
<p>이후 엔진은 <em>아무것도 체인으로 연결 되어있지 않고, 완전히 <code>엔진 내부에 존재</code>하는</em> <code>throwaway</code>라는 <code>Promise</code>를 생성합니다.<br>
이 <code>throwaway</code>는 <code>async function</code>을 재개하기 위한 적절한 핸들러와 함께 <code>promise</code>와 체이닝됩니다.<br>
<code>performPromiseThen</code>은 <code>Promise.prototype.then()</code>이 뒤에서 실제로 수행하는 일이며, 마지막으로 <code>async function</code>의 실행이 일시 중단되고 제어권은 호출자에게 반환됩니다.<br>
<img src="await-step-2.svg" alt="await-step-2.svg">
호출자측에서 작업이 계속 이어지고, 끝내 <code>콜 스택</code>이 비워지게 됩니다.<br>
이후 <code>Javascript 엔진</code>은 <code>microtask</code>들을 실행하기 시작합니다.</p>
<ul>
<li><code>microtask</code>(또는 <code>job</code>): <code>I/O</code>, <code>타이머</code> 작업과 같이 한 번에 하나씩 실행되는 비동기 작업인 <code>task</code>들이 끝날 때 실행되며, <code>async/await</code> 및 <code>Promise</code>에 대한 <code>지연 실행(Task가 완전히 끝난 후에만 실행됨)</code>을 구현하는 작업. <code>ES6</code>에서 <code>Promise</code>가 등장함에 따라 함께 추가 됨.</li>
</ul>
<p>즉, 이전에 예약해두었던 <code>PromiseResolveThenableJob</code>을 실행하게 되는데 이는 <code>promise</code>와 <code>await</code>에 전달된 값(여기서는 <code>42</code>)을 체이닝하기 위한 <code>PromiseReactionJob</code>을 예약합니다.<br>
<img src="await-step-3.svg" alt="await-step-3.svg">
이어서 <code>await</code>한 <code>Promise</code>(<code>v</code>)의 값으로 <code>promise</code>를 이행하고, <code>throwaway</code>에 대한 <code>반응(reaction) 작업</code>(또다른 <code>PromiseReactionJob</code>)을 예약하는 <code>PromiseReactionJob</code>을 수행합니다.</p>
<p><img src="await-step-4-final.svg" alt="await-step-4-final.svg"></p>
<p>이어지는 두 번째 <code>PromiseReactionJob</code>(<code>throwaway</code>에 대한 <code>반응</code>)은 <code>resolve</code>된 값(<code>42</code>)을 <code>throwaway</code>에 전파하고, 일시 중지 되었던 <code>async function</code>의 실행 재개해, <code>await</code>에서 <code>42</code>라는 값을 반환합니다.</p>
<h3 id="asyncawait-작업의-최적화" ><code>async/await</code> 작업의 최적화
<span>
    <a href="#asyncawait-%ec%9e%91%ec%97%85%ec%9d%98-%ec%b5%9c%ec%a0%81%ed%99%94">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h3><h4 id="원인" >원인
<span>
    <a href="#%ec%9b%90%ec%9d%b8">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h4><p><img src="await-overhead.svg" alt="await-overhead.svg"></p>
<p>자세히 살펴본 위 작업 과정에 따르면, 각 <code>await</code>에 대해 JS 엔진은 두 개의 추가 <code>Promise</code>, 그리고 최소 3개의 <code>Microtask</code>가 필요하게 됩니다.<br>
<img src="await-code-before.svg" alt="await-code-before.svg"></p>
<p>이 중, 하나의 <code>Promise</code>와 2개의 <code>Microtask</code>는 위 코드의 맨 위의 두 줄의 코드에 의해 발생합니다.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createPromise</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">resolvePromise</span>(<span style="color:#a6e22e">promise</span>, <span style="color:#a6e22e">v</span>);
</span></span></code></pre></div><p>이는 심지어 <code>v</code>가 이미 <code>Promise</code>여도 수행되기 때문에, <strong><code>v</code>가 <code>Promise</code>인 경우</strong> 상당히 비싼 오버헤드를 발생시킬 수 있습니다.</p>
<h4 id="해결" >해결
<span>
    <a href="#%ed%95%b4%ea%b2%b0">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h4><p>사실 <code>ECMA 사양</code>에는 이미 필요할 때만 <code>Promise</code>로의 래핑을 수행하는 <a href="https://tc39.es/ecma262/#sec-promise-resolve"><code>promiseResolve</code></a>라는 작업이 존재합니다.<br>
<img src="await-code-comparison.svg" alt="await-code-comparison.svg"></p>
<p>즉, 위 두 줄을 <code>promise = promiseResolve(v)</code> 단 한 줄로 변경하게 되면, <code>promise</code>에는 아무런 변화도 없으며 오직 필요할 경우에만 <code>Promise</code>로 래핑하게 됩니다.<br>
이렇게 하면 이전의 코드에서 <code>throwaway</code>를 생성하고, 이를 <code>v</code>와 체이닝하는 <code>PromiseReactionJob</code>을 예약하는 작업 정도만 남게 됩니다.<br>
또한, <code>throwaway</code>는 <code>performPromiseThen</code> 의 API 제약 조건을 충족하기 위해서 존재하는데, <a href="https://github.com/tc39/ecma262/issues/694">ECMA 사양의 변경</a>으로 더 이상 웬만해서는 <code>await</code>을 위해 <code>throwaway</code>를 생성할 필요가 없어졌습니다.</p>
<h1 id="참고" >참고
<span>
    <a href="#%ec%b0%b8%ea%b3%a0">
        <svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/></svg>
    </a>
</span>
</h1><ul>
<li><a href="https://rehmat-sayany.medium.com/demystifying-the-background-scene-of-async-await-in-javascript-5e6b8f4eca73">Demystifying the background Scene of Async/Await in JavaScript | by Rehmat Sayany | Medium</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async function - JavaScript | MDN</a></li>
<li><a href="https://scientyficworld.org/how-the-async-await-works-in-javascript/">How The Async-await Works In JavaScript? • Scientyfic World</a></li>
<li><a href="https://v8.dev/blog/fast-async">Faster async functions and promises · V8</a></li>
</ul>

        </div>
        

    



<div class="post-info">
    
        <div class="post-date dt-published">
            <a class="u-url" href="/post/develop/javascript/async-await/"><time datetime="2024-09-14">2024-09-14 20:55 KST</time></a>
            
        </div>
    

    <a class="post-hidden-url u-url" href="https://cloudsoswift.github.io/post/develop/javascript/async-await/">https://cloudsoswift.github.io/post/develop/javascript/async-await/</a>
    <a href="https://cloudsoswift.github.io/" class="p-name p-author post-hidden-author h-card" rel="me">cloudsoswift</a>


    <div class="post-taxonomies">
        
            <ul class="post-categories">
                
                    
                    <li><a href="https://cloudsoswift.github.io/categories/develop/">develop</a></li>
                
            </ul>
        
        
            <ul class="post-tags">
                
                    
                    <li><a href="https://cloudsoswift.github.io/tags/javascript/">#Javascript</a></li>
                
                    
                    <li><a href="https://cloudsoswift.github.io/tags/promise/">#Promise</a></li>
                
                    
                    <li><a href="">#동시성</a></li>
                
                    
                    <li><a href="https://cloudsoswift.github.io/tags/v8/">#V8</a></li>
                
            </ul>
        
        
    </div>
</div>

    </article>

    
        
        
            <h3 class="read-next-title">Read next</h3>
            <ul class="read-next-posts">
                
                <li><a href="/post/develop/javascript/generator/">[Javascript] 제너레이터 알아보기 (w. Iterator, 배열)</a></li>
                
                <li><a href="/post/develop/javascript/ast/">[Javascript] 추상 구문 트리(AST) 알아보기(w. 파스 트리, CFG, BNF)</a></li>
                
            </ul>
        
    

    
        
    
    
    <div class="pagination post-pagination">
        <div class="left pagination-item disabled">
            
        </div>
        <div class="right pagination-item ">
            
                <a href="/post/develop/database/sql-injection/">[DB] SQL Injection 알아보기 (w. PreparedStatement, Stored Procedures)</a>
            
        </div>
    </div>




    

    
        








    





<script src="https://giscus.app/client.js"
        data-repo="cloudsoswift/cloudsoswift.github.io"
        data-repo-id="R_kgDOIx-DaQ"
        data-category="Announcements"
        data-category-id="DIC_kwDOIx-Dac4CUdFI"
        data-mapping="og:title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        
        async>
</script>

    

        </main>
        
            <footer class="common-footer">
    
    

    <div class="common-footer-bottom">
        
        <div class="copyright">
            <p>© cloudsoswift, 2024<br>
            Powered by <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" rel="noopener noreferrer" href="https://github.com/mitrichius/hugo-theme-anubis">Anubis</a>.<br>
            
            </p>  
        </div> 

        

    




    <button class="theme-switcher">
        Dark theme
    </button>


<script>
const STORAGE_KEY = 'user-color-scheme'
const defaultTheme = "light"

let currentTheme
let switchButton
let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

const autoChangeScheme = e => {
    currentTheme = e.matches ? 'dark' : 'light'
    document.documentElement.setAttribute('data-theme', currentTheme)
    changeButtonText()
}

document.addEventListener('DOMContentLoaded', function() {
    switchButton = document.querySelector('.theme-switcher')
    currentTheme = detectCurrentScheme()
    if (currentTheme == 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark')
    }
    if (currentTheme == 'auto') {
        autoChangeScheme(autoDefinedScheme);
        autoDefinedScheme.addListener(autoChangeScheme);
    }

    if (switchButton) {
        changeButtonText()
        switchButton.addEventListener('click', switchTheme, false)
    }
  
    showContent()
})

function detectCurrentScheme() {
    if (localStorage !== null && localStorage.getItem(STORAGE_KEY)) {
        return localStorage.getItem(STORAGE_KEY)
    } 
    if (defaultTheme) {
        return defaultTheme
    } 
    if (!window.matchMedia) {
        return 'light'
    } 
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark'
    }
    return 'light'
}

function changeButtonText()
{   
    if (switchButton) {
        switchButton.textContent = currentTheme == 'dark' ?  "Light theme" : "Dark theme"
    }
}

function switchTheme(e) {
    if (currentTheme == 'dark') {
        if (localStorage !== null)
            localStorage.setItem(STORAGE_KEY, 'light')
        document.documentElement.setAttribute('data-theme', 'light')
        currentTheme = 'light'
    } else {
        if (localStorage !== null)
            localStorage.setItem(STORAGE_KEY, 'dark')
        document.documentElement.setAttribute('data-theme', 'dark')
        currentTheme = 'dark'
    }
    changeButtonText()
}

function showContent() {
    document.body.style.visibility = 'visible';
    document.body.style.opacity = 1;
}
</script>

   
    </div>

    <p class="h-card vcard">

    <a href=https://cloudsoswift.github.io/ class="p-name u-url url fn" rel="me">cloudsoswift</a> 

    

     
        <img class="u-photo" src="/img/avatar.png" />
    
</p> 
</footer>

        
    </div>
</body>
</html>

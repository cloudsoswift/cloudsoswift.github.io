<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>동시성 on 오늘도 개발을 한다.</title>
    <link>https://cloudsoswift.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/</link>
    <description>오늘도 개발을 한다. (동시성)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 14 Sep 2024 20:55:53 +0900</lastBuildDate>
    
    <atom:link href="https://cloudsoswift.github.io/tags/%EB%8F%99%EC%8B%9C%EC%84%B1/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Javascript] async/await 알아보기 (w. V8 Engine, task, microtask)</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/async-await/</link>
      <pubDate>Sat, 14 Sep 2024 20:55:53 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/async-await/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 9월 10일에 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/11_async-await/Readme.md&#34;&gt;&lt;strong&gt;async function과 await 키워드&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h1 id=&#34;async-function---await는-어떻게-동작할까&#34; &gt;&lt;code&gt;async function&lt;/code&gt; - &lt;code&gt;await&lt;/code&gt;는 어떻게 동작할까?
&lt;span&gt;
    &lt;a href=&#34;#async-function---await%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%8f%99%ec%9e%91%ed%95%a0%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;asyncawait란&#34; &gt;&lt;code&gt;async/await&lt;/code&gt;란?
&lt;span&gt;
    &lt;a href=&#34;#asyncawait%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;async function&lt;/code&gt;이란, 여러 &lt;code&gt;Promise&lt;/code&gt;간의 흐름을 순서대로 처리할 수 있는, 즉 여러 비동기 함수들을 동기적인 순서로 진행할 수 있는 함수를 말합니다.&lt;br&gt;
&lt;code&gt;async function&lt;/code&gt;은 0개 이상의 &lt;code&gt;await&lt;/code&gt; 키워드를 포함할 수 있는데, 함수를 진행하다 &lt;code&gt;await&lt;/code&gt;가 달린 &lt;code&gt;Promise&lt;/code&gt;를 만나게 되면 해당 &lt;code&gt;Promise&lt;/code&gt;가 &lt;em&gt;&lt;code&gt;이행&lt;/code&gt;/&lt;code&gt;거부&lt;/code&gt;될 때 까지&lt;/em&gt; &lt;strong&gt;함수 실행을 &lt;code&gt;일시 중단&lt;/code&gt;&lt;/strong&gt; 하며 처리가 완료된 뒤 다시 진행됩니다.&lt;br&gt;
즉, &lt;code&gt;Promise&lt;/code&gt;를 반환하는 함수를 동기식인 것처럼 동작하도록 해줍니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이는 &lt;code&gt;await&lt;/code&gt; 이후의 코드를 &lt;code&gt;Promise.then()&lt;/code&gt; 콜백에서 수행하는 것과 거의 유사&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 일반 Promise와 callback 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getProcessedData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// returns a promise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    .&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadFallbackData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;)) &lt;span style=&#34;color:#75715e&#34;&gt;// returns a promise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;processDataInWorker&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// returns a promise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 위 예시를 async function - await로 변환한 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getProcessedData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;downloadFallbackData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;processDataInWorker&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;또한, &lt;code&gt;async function&lt;/code&gt;은 항상 &lt;code&gt;Promise&lt;/code&gt;를 &lt;code&gt;반환&lt;/code&gt;하며, 만약 &lt;em&gt;Promise가 아닌 값&lt;/em&gt;을 반환(&lt;code&gt;심지어 아무것도 return하지 않아도!&lt;/code&gt;)하는 경우 &lt;em&gt;암시적으로&lt;/em&gt; &lt;code&gt;Promise&lt;/code&gt;로 래핑되어 반환됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Promise가 아닌 값을 반환하는 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; () =&amp;gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Promise {&amp;lt;fulfilled&amp;gt;: 1}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 아무것도 반환하지 않는 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;none&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; () =&amp;gt; {};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;none&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// Promise {&amp;lt;fulfilled&amp;gt;: undefined}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;asyncawait의-특징&#34; &gt;&lt;code&gt;async/await&lt;/code&gt;의 특징
&lt;span&gt;
    &lt;a href=&#34;#asyncawait%ec%9d%98-%ed%8a%b9%ec%a7%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;어떠한-값이든-await-할-수-있음&#34; &gt;어떠한 값이든 &lt;code&gt;await&lt;/code&gt; 할 수 있음
&lt;span&gt;
    &lt;a href=&#34;#%ec%96%b4%eb%96%a0%ed%95%9c-%ea%b0%92%ec%9d%b4%eb%93%a0-await-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;웬만한 경우, &lt;code&gt;Promise&lt;/code&gt; 앞에 &lt;code&gt;await&lt;/code&gt; 키워드를 붙여 비동기 작업의 결과를 기다리도록 합니다.&lt;br&gt;
하지만 실제로는 어떠한 &lt;code&gt;Javascript 값&lt;/code&gt;이든 기다리게 할 수 있습니다.&lt;br&gt;
만약 &lt;code&gt;await&lt;/code&gt; 키워드 뒤에 오는 &lt;code&gt;표현식&lt;/code&gt;의 값이 &lt;code&gt;Promise&lt;/code&gt;가 아닌 경우, 이를 &lt;code&gt;Promise&lt;/code&gt;로 변환합니다.&lt;br&gt;
예를들어, &lt;code&gt;25&lt;/code&gt;와 같은 아무런 숫자도 &lt;code&gt;await&lt;/code&gt;를 붙일 수 있는 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// → Promise
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// `25`를 출력한다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;await-은-어떠한-thenable-객체와도-정상-동작함&#34; &gt;&lt;code&gt;await&lt;/code&gt; 은 어떠한 &lt;code&gt;thenable&lt;/code&gt; 객체와도 정상 동작함
&lt;span&gt;
    &lt;a href=&#34;#await-%ec%9d%80-%ec%96%b4%eb%96%a0%ed%95%9c-thenable-%ea%b0%9d%ec%b2%b4%ec%99%80%eb%8f%84-%ec%a0%95%ec%83%81-%eb%8f%99%ec%9e%91%ed%95%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;await&lt;/code&gt; 키워드는 어떤 객체든 &lt;code&gt;then&lt;/code&gt; 메서드만 있다면 꼭 &lt;code&gt;Promise&lt;/code&gt;가 아니어도 잘 동작하게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;constructor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;timeout&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;timeout&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;timeout&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reject&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;startTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Date.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(Date.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;startTime&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;               &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;timeout&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;actualTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Sleep&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;actualTime&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;})();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;async-function-내부의-await-동작&#34; &gt;&lt;code&gt;async function&lt;/code&gt; 내부의 &lt;code&gt;await&lt;/code&gt; 동작
&lt;span&gt;
    &lt;a href=&#34;#async-function-%eb%82%b4%eb%b6%80%ec%9d%98-await-%eb%8f%99%ec%9e%91&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;async function&lt;/code&gt;은 일반 함수처럼 진행되다가, &lt;code&gt;await&lt;/code&gt; 키워드가 달린 &lt;code&gt;Promise&lt;/code&gt;를 만나게 될 경우, 해당 &lt;code&gt;Promise&lt;/code&gt;가 &lt;code&gt;resolve(또는 reject)&lt;/code&gt;될 때까지 &lt;code&gt;async function&lt;/code&gt;의 실행을 일시 중단합니다.&lt;br&gt;
이때, Javascript의 &lt;code&gt;논-블로킹&lt;/code&gt; 특성상, &lt;code&gt;await&lt;/code&gt; 키워드로 인해 &lt;em&gt;함수 실행이 멈추더라도&lt;/em&gt; &lt;code&gt;다른 연산&lt;/code&gt;들은 &lt;code&gt;백그라운드에서 계속 진행&lt;/code&gt;됩니다.&lt;br&gt;
이는 &lt;a href=&#34;../1_Promise-async/Readme.md&#34;&gt;콜백 vs async&lt;/a&gt; 에서 언급한 것처럼, &lt;code&gt;Javascript&lt;/code&gt;에서는 코드 실행을 수행하는 &lt;code&gt;메인 스레드&lt;/code&gt; 뿐만 아니라, &lt;code&gt;타이머 기반 작업&lt;/code&gt;, &lt;code&gt;네트워크 요청&lt;/code&gt; 등의 &lt;code&gt;비동기 작업&lt;/code&gt;을 처리하는 &lt;code&gt;Web API&lt;/code&gt;를 사용하기 때문입니다.&lt;br&gt;
즉, 만약 상기한 &lt;code&gt;비동기 작업&lt;/code&gt;을 마주한다 해도 &lt;code&gt;메인 스레드&lt;/code&gt;는 이를 &lt;em&gt;직접 처리하지 않고&lt;/em&gt; &lt;code&gt;Web API&lt;/code&gt;에게 이를 &lt;code&gt;전달&lt;/code&gt;합니다. 따라서 해당 작업이 완료되길 &lt;code&gt;기다리지 않고&lt;/code&gt; 이어지는 코드들을 &lt;code&gt;계속 실행&lt;/code&gt;하게 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;그렇다면-asyncawait는-진짜-동기적으로-동작할까&#34; &gt;그렇다면 &lt;code&gt;async/await&lt;/code&gt;는 진짜 동기적으로 동작할까?
&lt;span&gt;
    &lt;a href=&#34;#%ea%b7%b8%eb%a0%87%eb%8b%a4%eb%a9%b4-asyncawait%eb%8a%94-%ec%a7%84%ec%a7%9c-%eb%8f%99%ea%b8%b0%ec%a0%81%ec%9c%bc%eb%a1%9c-%eb%8f%99%ec%9e%91%ed%95%a0%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;) =&amp;gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;첫 번째 타이머&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;) =&amp;gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;두 번째 타이머&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;코드 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위처럼 각각 10초 이후 문자열을 &lt;code&gt;resolve&lt;/code&gt;하는 타이머 &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;를 예로 들어보겠습니다.&lt;br&gt;
만약 이 둘을 &lt;code&gt;async function&lt;/code&gt; 내부에서 &lt;code&gt;await&lt;/code&gt;를 달아주면 어떻게 동작할까요?&lt;br&gt;
10초짜리 타이머 2개가 동기적으로 호출될 것이니, 20초가 소요될까요?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;시작&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;) =&amp;gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;첫 번째 타이머&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	});  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;) =&amp;gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;두 번째 타이머&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;startTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Date.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T1에 소요된 시간 : &amp;#34;&lt;/span&gt;, Date.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;startTime&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ms&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t2&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T2에 소요된 시간 : &amp;#34;&lt;/span&gt;, Date.&lt;span style=&#34;color:#a6e22e&#34;&gt;now&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;startTime&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ms&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;끝&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;test&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// ?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;코드 2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;await-with-timer.png&#34; alt=&#34;await-with-timer.png&#34;&gt;&lt;br&gt;
하지만, 실제로는 두 타이머 작업을 수행하는데에 총 10초밖에 들지 않았습니다.&lt;br&gt;
그렇다면 작업이 동기적으로 수행되지 않은 걸까요?&lt;br&gt;
이를 이해하려면 Javascript Event Loop 내부 동작이 어떻게 수행되는지 알아야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;event-loop-내부의-asyncawait-동작&#34; &gt;Event Loop 내부의 &lt;code&gt;async/await&lt;/code&gt; 동작
&lt;span&gt;
    &lt;a href=&#34;#event-loop-%eb%82%b4%eb%b6%80%ec%9d%98-asyncawait-%eb%8f%99%ec%9e%91&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;간단하게 설명하면, &lt;code&gt;Event Loop&lt;/code&gt;는 Javascript 코드를 한 줄 한 줄 실행하면서, 지속적으로 &lt;code&gt;메시지 큐&lt;/code&gt;에 &lt;code&gt;보류(Pending)중인 메시지&lt;/code&gt;(ex. &lt;code&gt;resolve&lt;/code&gt;된 &lt;code&gt;Promise&lt;/code&gt;)를 확인하며 하나 하나 처리합니다.&lt;br&gt;
즉, &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;를 초기화하는 &lt;code&gt;코드 1&lt;/code&gt; 코드를 &lt;code&gt;메인 스레드&lt;/code&gt;가 읽고 실행한 순간, 백그라운드에서 해당 타이머 작업은 &lt;code&gt;Web API&lt;/code&gt;에게 전달되어 실행되고 있는 것입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Promise()&lt;/code&gt;의 첫 번째 인자로 주어진 함수는 즉시 실행됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 &lt;code&gt;t1&lt;/code&gt;, &lt;code&gt;t2&lt;/code&gt;는 백그라운드에서 동시에 실행되고 있으며, &lt;code&gt;메인 스레드&lt;/code&gt;는 이후 이어지는 코드(&lt;code&gt;코드 2&lt;/code&gt;)들을 계속 실행해나갑니다.&lt;br&gt;
그리고 &lt;code&gt;test()&lt;/code&gt; 내부의 &lt;code&gt;await t1&lt;/code&gt;에 도달했을 때, &lt;code&gt;t1&lt;/code&gt;이 &lt;code&gt;resolve&lt;/code&gt;될 때 까지 기다렸다가 코드 진행을 계속 이어나갑니다.&lt;br&gt;
&lt;code&gt;t1&lt;/code&gt;과 &lt;code&gt;t2&lt;/code&gt; 모두 10초짜리 타이머이므로, &lt;code&gt;t1&lt;/code&gt;이 완료됨과 거의 동시에 &lt;code&gt;t2&lt;/code&gt;도 완료되게 됩니다. 따라서 &lt;code&gt;await t2&lt;/code&gt;는 거의 기다리지 않고 이후 코드들이 즉시 실행되게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;) =&amp;gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;첫 번째 타이머&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;) =&amp;gt; {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;두 번째 타이머&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;만약 &lt;code&gt;t2&lt;/code&gt;를 5초로 줄이더라도, 백그라운드에서는 &lt;code&gt;t2&lt;/code&gt;가 &lt;code&gt;t1&lt;/code&gt;보다 먼저 완료되지만 &lt;code&gt;test()&lt;/code&gt; 함수의 동작은 이전과 동일하게 작동합니다.&lt;/p&gt;
&lt;h3 id=&#34;asyncawait을-사용하면-비동기-병렬-처리가-불가능한가요&#34; &gt;&lt;code&gt;async/await&lt;/code&gt;을 사용하면, 비동기 병렬 처리가 불가능한가요?
&lt;span&gt;
    &lt;a href=&#34;#asyncawait%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%a9%b4-%eb%b9%84%eb%8f%99%ea%b8%b0-%eb%b3%91%eb%a0%ac-%ec%b2%98%eb%a6%ac%ea%b0%80-%eb%b6%88%ea%b0%80%eb%8a%a5%ed%95%9c%ea%b0%80%ec%9a%94&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;그렇지 않습니다. &lt;code&gt;Promise&lt;/code&gt;의 &lt;code&gt;all&lt;/code&gt; 또는 &lt;code&gt;allSettled&lt;/code&gt; 함수를 통해 &lt;code&gt;await&lt;/code&gt; 키워드를 사용하면서 비동기 작업들을 병렬적으로 처리할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetchData&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;userDataPromise&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetchUserData&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;productDataPromise&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetchProductData&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; [&lt;span style=&#34;color:#a6e22e&#34;&gt;userData&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;productData&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; Promise.&lt;span style=&#34;color:#a6e22e&#34;&gt;all&lt;/span&gt;([&lt;span style=&#34;color:#a6e22e&#34;&gt;userDataPromise&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;productDataPromise&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;User data:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;userData&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Product data:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;productData&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error fetching data:&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드처럼, 병렬로 실행할 &lt;code&gt;비동기 작업(Promise)&lt;/code&gt;들을 &lt;code&gt;배열(또는 Iterable 객체)&lt;/code&gt;에 담아 &lt;code&gt;all&lt;/code&gt; 또는 &lt;code&gt;allSettled&lt;/code&gt;에 넘겨주면 이들을 병렬적으로 수행하게 됩니다.&lt;br&gt;
이후 배열의 모든 &lt;code&gt;비동기 작업&lt;/code&gt;이 완료되면 코드 진행을 이어나갑니다.&lt;/p&gt;
&lt;h2 id=&#34;v8-엔진에서의-내부-await-동작-과정-httpsv8devblogfast-async&#34; &gt;V8 엔진에서의 내부 await 동작 과정 &lt;a href=&#34;https://v8.dev/blog/fast-async&#34;&gt;#&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#v8-%ec%97%94%ec%a7%84%ec%97%90%ec%84%9c%ec%9d%98-%eb%82%b4%eb%b6%80-await-%eb%8f%99%ec%9e%91-%ea%b3%bc%ec%a0%95-httpsv8devblogfast-async&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위와 같은 함수를 실행한다고 할 때, V8 엔진 내부에서는 아래와 같이 처리가 이뤄집니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;await-under-the-hood.svg&#34; alt=&#34;await-under-the-hood.svg&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;V8 엔진이 &lt;code&gt;async function&lt;/code&gt;을 &lt;code&gt;resumable&lt;/code&gt;(&lt;code&gt;await&lt;/code&gt; 위치에서 함수 실행을 중단하고 재개할 수 있음을 뜻함)하다고 표시합니다.
&lt;ul&gt;
&lt;li&gt;그런 다음 &lt;code&gt;implicit_promise&lt;/code&gt;(&lt;code&gt;async function&lt;/code&gt;을 호출할 때 반환되며, 최종적으로 &lt;code&gt;async function&lt;/code&gt;이 생성한 값을 &lt;code&gt;resolve&lt;/code&gt;하는 &lt;code&gt;Promise&lt;/code&gt;)를 생성합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;await&lt;/code&gt;에 전달된 값(여기서는 &lt;code&gt;v&lt;/code&gt;)을 &lt;code&gt;Promise&lt;/code&gt;로 래핑합니다.&lt;/li&gt;
&lt;li&gt;만약 &lt;code&gt;Promise&lt;/code&gt;가 &lt;code&gt;이행(fulfilled)&lt;/code&gt;되면 &lt;code&gt;async function&lt;/code&gt;을 &lt;code&gt;재개&lt;/code&gt;하도록 하는 &lt;code&gt;핸들러&lt;/code&gt;를 래핑된 &lt;code&gt;Promise&lt;/code&gt;에 연결합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async function&lt;/code&gt;의 실행을 &lt;code&gt;일시 중단(suspend)&lt;/code&gt;한 뒤, 호출자에게 &lt;code&gt;implicit_promise&lt;/code&gt;를 반환합니다.
&lt;ul&gt;
&lt;li&gt;이후 &lt;code&gt;Promise&lt;/code&gt;가 이행된 경우, &lt;code&gt;Promise&lt;/code&gt;의 값 &lt;code&gt;w&lt;/code&gt;와 함께 &lt;code&gt;async function&lt;/code&gt;이 재개되고 &lt;code&gt;implicit_promise&lt;/code&gt;는 &lt;code&gt;w&lt;/code&gt;를 &lt;code&gt;resolve&lt;/code&gt;합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;자세히-살펴보기&#34; &gt;자세히 살펴보기
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%ec%84%b8%ed%9e%88-%ec%82%b4%ed%8e%b4%eb%b3%b4%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;위 과정을 하나 하나 살펴보겠습니다.&lt;br&gt;
참고로 위 예시에서 &lt;code&gt;await&lt;/code&gt;한 표현식이 &lt;em&gt;42라는 값으로 이행된&lt;/em&gt; &lt;code&gt;Promise&lt;/code&gt;라고 가정하겠습니다.&lt;br&gt;
&lt;img src=&#34;await-step-1.svg&#34; alt=&#34;await-step-1.svg&#34;&gt;
엔진은 이 &lt;code&gt;await&lt;/code&gt;된 값을 &lt;code&gt;promise&lt;/code&gt;라는 &lt;code&gt;Promise&lt;/code&gt;로 래핑합니다.&lt;br&gt;
이는 다음 차례에 &lt;code&gt;Promise&lt;/code&gt;들의 &lt;code&gt;지연된 연쇄(deferred chaining)&lt;/code&gt;를 수행합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ECMA 사양&lt;/code&gt;에서는 이를 &lt;a href=&#34;https://tc39.es/ecma262/#sec-promiseresolvethenablejob&#34;&gt;&lt;code&gt;PromiseResolveThenableJob&lt;/code&gt;&lt;/a&gt;이라고 부릅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후 엔진은 &lt;em&gt;아무것도 체인으로 연결 되어있지 않고, 완전히 &lt;code&gt;엔진 내부에 존재&lt;/code&gt;하는&lt;/em&gt; &lt;code&gt;throwaway&lt;/code&gt;라는 &lt;code&gt;Promise&lt;/code&gt;를 생성합니다.&lt;br&gt;
이 &lt;code&gt;throwaway&lt;/code&gt;는 &lt;code&gt;async function&lt;/code&gt;을 재개하기 위한 적절한 핸들러와 함께 &lt;code&gt;promise&lt;/code&gt;와 체이닝됩니다.&lt;br&gt;
&lt;code&gt;performPromiseThen&lt;/code&gt;은 &lt;code&gt;Promise.prototype.then()&lt;/code&gt;이 뒤에서 실제로 수행하는 일이며, 마지막으로 &lt;code&gt;async function&lt;/code&gt;의 실행이 일시 중단되고 제어권은 호출자에게 반환됩니다.&lt;br&gt;
&lt;img src=&#34;await-step-2.svg&#34; alt=&#34;await-step-2.svg&#34;&gt;
호출자측에서 작업이 계속 이어지고, 끝내 &lt;code&gt;콜 스택&lt;/code&gt;이 비워지게 됩니다.&lt;br&gt;
이후 &lt;code&gt;Javascript 엔진&lt;/code&gt;은 &lt;code&gt;microtask&lt;/code&gt;들을 실행하기 시작합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;microtask&lt;/code&gt;(또는 &lt;code&gt;job&lt;/code&gt;): &lt;code&gt;I/O&lt;/code&gt;, &lt;code&gt;타이머&lt;/code&gt; 작업과 같이 한 번에 하나씩 실행되는 비동기 작업인 &lt;code&gt;task&lt;/code&gt;들이 끝날 때 실행되며, &lt;code&gt;async/await&lt;/code&gt; 및 &lt;code&gt;Promise&lt;/code&gt;에 대한 &lt;code&gt;지연 실행(Task가 완전히 끝난 후에만 실행됨)&lt;/code&gt;을 구현하는 작업. &lt;code&gt;ES6&lt;/code&gt;에서 &lt;code&gt;Promise&lt;/code&gt;가 등장함에 따라 함께 추가 됨.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;즉, 이전에 예약해두었던 &lt;code&gt;PromiseResolveThenableJob&lt;/code&gt;을 실행하게 되는데 이는 &lt;code&gt;promise&lt;/code&gt;와 &lt;code&gt;await&lt;/code&gt;에 전달된 값(여기서는 &lt;code&gt;42&lt;/code&gt;)을 체이닝하기 위한 &lt;code&gt;PromiseReactionJob&lt;/code&gt;을 예약합니다.&lt;br&gt;
&lt;img src=&#34;await-step-3.svg&#34; alt=&#34;await-step-3.svg&#34;&gt;
이어서 &lt;code&gt;await&lt;/code&gt;한 &lt;code&gt;Promise&lt;/code&gt;(&lt;code&gt;v&lt;/code&gt;)의 값으로 &lt;code&gt;promise&lt;/code&gt;를 이행하고, &lt;code&gt;throwaway&lt;/code&gt;에 대한 &lt;code&gt;반응(reaction) 작업&lt;/code&gt;(또다른 &lt;code&gt;PromiseReactionJob&lt;/code&gt;)을 예약하는 &lt;code&gt;PromiseReactionJob&lt;/code&gt;을 수행합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;await-step-4-final.svg&#34; alt=&#34;await-step-4-final.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;이어지는 두 번째 &lt;code&gt;PromiseReactionJob&lt;/code&gt;(&lt;code&gt;throwaway&lt;/code&gt;에 대한 &lt;code&gt;반응&lt;/code&gt;)은 &lt;code&gt;resolve&lt;/code&gt;된 값(&lt;code&gt;42&lt;/code&gt;)을 &lt;code&gt;throwaway&lt;/code&gt;에 전파하고, 일시 중지 되었던 &lt;code&gt;async function&lt;/code&gt;의 실행 재개해, &lt;code&gt;await&lt;/code&gt;에서 &lt;code&gt;42&lt;/code&gt;라는 값을 반환합니다.&lt;/p&gt;
&lt;h3 id=&#34;asyncawait-작업의-최적화&#34; &gt;&lt;code&gt;async/await&lt;/code&gt; 작업의 최적화
&lt;span&gt;
    &lt;a href=&#34;#asyncawait-%ec%9e%91%ec%97%85%ec%9d%98-%ec%b5%9c%ec%a0%81%ed%99%94&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;원인&#34; &gt;원인
&lt;span&gt;
    &lt;a href=&#34;#%ec%9b%90%ec%9d%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;await-overhead.svg&#34; alt=&#34;await-overhead.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;자세히 살펴본 위 작업 과정에 따르면, 각 &lt;code&gt;await&lt;/code&gt;에 대해 JS 엔진은 두 개의 추가 &lt;code&gt;Promise&lt;/code&gt;, 그리고 최소 3개의 &lt;code&gt;Microtask&lt;/code&gt;가 필요하게 됩니다.&lt;br&gt;
&lt;img src=&#34;await-code-before.svg&#34; alt=&#34;await-code-before.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 중, 하나의 &lt;code&gt;Promise&lt;/code&gt;와 2개의 &lt;code&gt;Microtask&lt;/code&gt;는 위 코드의 맨 위의 두 줄의 코드에 의해 발생합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;promise&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createPromise&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;resolvePromise&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;promise&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이는 심지어 &lt;code&gt;v&lt;/code&gt;가 이미 &lt;code&gt;Promise&lt;/code&gt;여도 수행되기 때문에, &lt;strong&gt;&lt;code&gt;v&lt;/code&gt;가 &lt;code&gt;Promise&lt;/code&gt;인 경우&lt;/strong&gt; 상당히 비싼 오버헤드를 발생시킬 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;해결&#34; &gt;해결
&lt;span&gt;
    &lt;a href=&#34;#%ed%95%b4%ea%b2%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;사실 &lt;code&gt;ECMA 사양&lt;/code&gt;에는 이미 필요할 때만 &lt;code&gt;Promise&lt;/code&gt;로의 래핑을 수행하는 &lt;a href=&#34;https://tc39.es/ecma262/#sec-promise-resolve&#34;&gt;&lt;code&gt;promiseResolve&lt;/code&gt;&lt;/a&gt;라는 작업이 존재합니다.&lt;br&gt;
&lt;img src=&#34;await-code-comparison.svg&#34; alt=&#34;await-code-comparison.svg&#34;&gt;&lt;/p&gt;
&lt;p&gt;즉, 위 두 줄을 &lt;code&gt;promise = promiseResolve(v)&lt;/code&gt; 단 한 줄로 변경하게 되면, &lt;code&gt;promise&lt;/code&gt;에는 아무런 변화도 없으며 오직 필요할 경우에만 &lt;code&gt;Promise&lt;/code&gt;로 래핑하게 됩니다.&lt;br&gt;
이렇게 하면 이전의 코드에서 &lt;code&gt;throwaway&lt;/code&gt;를 생성하고, 이를 &lt;code&gt;v&lt;/code&gt;와 체이닝하는 &lt;code&gt;PromiseReactionJob&lt;/code&gt;을 예약하는 작업 정도만 남게 됩니다.&lt;br&gt;
또한, &lt;code&gt;throwaway&lt;/code&gt;는 &lt;code&gt;performPromiseThen&lt;/code&gt; 의 API 제약 조건을 충족하기 위해서 존재하는데, &lt;a href=&#34;https://github.com/tc39/ecma262/issues/694&#34;&gt;ECMA 사양의 변경&lt;/a&gt;으로 더 이상 웬만해서는 &lt;code&gt;await&lt;/code&gt;을 위해 &lt;code&gt;throwaway&lt;/code&gt;를 생성할 필요가 없어졌습니다.&lt;/p&gt;
&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rehmat-sayany.medium.com/demystifying-the-background-scene-of-async-await-in-javascript-5e6b8f4eca73&#34;&gt;Demystifying the background Scene of Async/Await in JavaScript | by Rehmat Sayany | Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&#34;&gt;async function - JavaScript | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://scientyficworld.org/how-the-async-await-works-in-javascript/&#34;&gt;How The Async-await Works In JavaScript? • Scientyfic World&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://v8.dev/blog/fast-async&#34;&gt;Faster async functions and promises · V8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Java] synchronized 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/java/synchronized/</link>
      <pubDate>Mon, 04 Mar 2024 23:19:16 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/java/synchronized/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 3월 6일 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/07-JAVA_SPRING/7_Synchronized/Readme.md&#34;&gt;&lt;strong&gt;synchronized&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;synchronized-키워드란&#34; &gt;&lt;code&gt;synchronized&lt;/code&gt; 키워드란?
&lt;span&gt;
    &lt;a href=&#34;#synchronized-%ed%82%a4%ec%9b%8c%eb%93%9c%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;멀티 스레드 환경&lt;/strong&gt;&lt;/em&gt;에서 Java 언어가 &lt;strong&gt;공유 자원&lt;/strong&gt;에 대한 &lt;strong&gt;동기화 처리&lt;/strong&gt;를 위해 사용되는 관용구(idiom)입니다. 이 키워드를 사용해 개발자는 간단하게 &lt;strong&gt;&lt;code&gt;경쟁 조건(Race Condition)&lt;/code&gt;&lt;/strong&gt; 을 &lt;strong&gt;피할 수&lt;/strong&gt; 있습니다.&lt;br&gt;
&lt;code&gt;Synchronized&lt;/code&gt; 키워드를 사용하게 되면 Java는 내부적으로 &lt;strong&gt;&lt;code&gt;모니터(monitor)&lt;/code&gt;&lt;/strong&gt;(&lt;code&gt;모니터 락(monitor lock)&lt;/code&gt; 또는 &lt;code&gt;내재적 락(intrinsic lock)&lt;/code&gt;이라고도 불림)을 사용해 &lt;strong&gt;동기화를 처리&lt;/strong&gt;합니다.&lt;br&gt;
모니터는 동기화에 필요한 &amp;lsquo;객체 상태에 대한 &lt;strong&gt;배타적 액세스 강제&lt;/strong&gt;&amp;rsquo;, &amp;lsquo;&lt;strong&gt;가시성&lt;/strong&gt;(&lt;strong&gt;visibility&lt;/strong&gt;)에 필수적인 &lt;code&gt;발생-전(happen-before) 관계&lt;/code&gt; 설정&amp;rsquo; 과 같은 작업을 수행하는 역할을 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가시성: 동일한 &lt;code&gt;synchronized&lt;/code&gt; 블록에 진입하는 다음 스레드는 &lt;em&gt;이전 스레드가 본 것&lt;/em&gt;과 &lt;strong&gt;같은 변수 값&lt;/strong&gt;들을 보게 됩니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;발생-전(happen-before)&lt;/code&gt;: &lt;strong&gt;명령어의 순서 변경&lt;/strong&gt;을 통해 작업 간의 순서 및 가시성을 보장하는 것을 말합니다. 이를 통해 &lt;em&gt;한 스레드에서 변경된 내용&lt;/em&gt;이 &lt;strong&gt;다른 스레드에 표시될 수 있도록 보장&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;모든 객체는 관련된 &lt;code&gt;내재적 락&lt;/code&gt;이 존재하고, 관례에 따라 객체의 필드에 &lt;strong&gt;독점적이고 일관적&lt;/strong&gt;이게 &lt;strong&gt;접근&lt;/strong&gt;해야하는 스레드는 &amp;lsquo;내재적 락&amp;rsquo;을 얻고 접근 후 &amp;lsquo;내재적 락&amp;rsquo;을 해제해야 합니다.&lt;br&gt;
이러한 모니터는 &lt;strong&gt;객체에 바인딩&lt;/strong&gt; 되므로, 동일한 객체의 모든 &lt;code&gt;synchronized&lt;/code&gt; 블록은 &lt;strong&gt;동시에 한 스레드만 실행&lt;/strong&gt;할 수 있습니다.&lt;br&gt;
&lt;code&gt;synchronized&lt;/code&gt; 키워드는 &lt;code&gt;메서드 앞&lt;/code&gt;에 붙이거나 &lt;code&gt;코드 블럭&lt;/code&gt; 중간에 사용할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;키워드-위치에-따른-의미&#34; &gt;키워드 위치에 따른 의미
&lt;span&gt;
    &lt;a href=&#34;#%ed%82%a4%ec%9b%8c%eb%93%9c-%ec%9c%84%ec%b9%98%ec%97%90-%eb%94%b0%eb%a5%b8-%ec%9d%98%eb%af%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;인스턴스-메서드&#34; &gt;&lt;code&gt;인스턴스 메서드&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%b8%ec%8a%a4%ed%84%b4%ec%8a%a4-%eb%a9%94%ec%84%9c%eb%93%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;synchronisedCalculate&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    setSum&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;getSum&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;메서드 선언 앞에 &lt;code&gt;synchronized&lt;/code&gt; 키워드를 붙임으로써 해당 메서드가 동기화 처리 되도록 합니다.&lt;br&gt;
&lt;strong&gt;메서드를 소유한 인스턴스에 의해 동기화&lt;/strong&gt;되므로, &lt;strong&gt;한 인스턴스 당 하나의 스레드&lt;/strong&gt;만 해당 메서드를 실행할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;정적-메서드&#34; &gt;&lt;code&gt;정적 메서드&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%ec%a0%81-%eb%a9%94%ec%84%9c%eb%93%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;syncStaticCalculate&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     staticSum &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; staticSum &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;정적 메서드 앞에 &lt;code&gt;synchronized&lt;/code&gt; 키워드를 붙임으로써 해당 메서드가 동기화 처리 되도록 합니다.&lt;br&gt;
해당 메서드를 소유한 클래스의 &lt;strong&gt;&lt;code&gt;Class&lt;/code&gt; 객체에 의해 동기화&lt;/strong&gt;됩니다. 클래스 별로 &lt;strong&gt;JVM 당&lt;/strong&gt; 하나의 &lt;code&gt;Class&lt;/code&gt; 객체만 존재하므로 인스턴스 갯수에 상관없이 &lt;strong&gt;하나의 스레드만 해당 메서드를 실행&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;코드-블록&#34; &gt;&lt;code&gt;코드 블록&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%bd%94%eb%93%9c-%eb%b8%94%eb%a1%9d&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 인스턴스 메서드 내 코드 블록 synchronized
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;performSynchronisedTask&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        setCount&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;getCount&lt;span style=&#34;color:#f92672&#34;&gt;()+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;메서드 중간에 &lt;code&gt;synchronized (obj)&lt;/code&gt; 키워드를 사용하므로써 &lt;strong&gt;코드 일부를 동기화&lt;/strong&gt; 할 수 있습니다.&lt;br&gt;
&lt;code&gt;synchronized&lt;/code&gt;에 &lt;strong&gt;매개변수&lt;/strong&gt;로 전달되는 객체는 &lt;strong&gt;&lt;code&gt;모니터&lt;/code&gt; 객체&lt;/strong&gt;로, 블록 내부의 코드는 해당 객체에서 동기화됩니다. 따라서, &lt;code&gt;모니터&lt;/code&gt; 객체 당 하나의 스레드만 해당 코드 블록 내의 작업을 실행할 수 있습니다.&lt;br&gt;
&lt;em&gt;&lt;code&gt;정적 메서드&lt;/code&gt;의 경우&lt;/em&gt;, 매개변수로 전달되는 &lt;strong&gt;&lt;code&gt;Class&lt;/code&gt; 객체&lt;/strong&gt;에 의해 동기화 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 정적 메서드 내 코드 블록 synchronized
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;performStaticSyncTask&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;SynchronisedBlocks&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        setStaticCount&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;getStaticCount&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;재진입성reentrancy&#34; &gt;&lt;code&gt;재진입성(Reentrancy)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%ac%ec%a7%84%ec%9e%85%ec%84%b1reentrancy&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;스레드가 &lt;em&gt;락을 소유하고 있는 동안&lt;/em&gt;, 해당 &lt;strong&gt;락을 다시 획득&lt;/strong&gt;할 수 있습니다.&lt;br&gt;
이렇게 한 스레드가 &lt;strong&gt;같은 락을 두 번 이상 획득&lt;/strong&gt;할 수 있도록 허용하게 되면 &lt;code&gt;재진입 동기화(reentrant synchronization)&lt;/code&gt;가 가능합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Object&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;lock&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;First time acquiring it&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;lock&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Entering again&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;lock&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;             System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;And again&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;즉, &lt;code&gt;synchronized&lt;/code&gt; 코드가 직접/간접적으로 &lt;code&gt;synchronized&lt;/code&gt; 코드가 포함된 메서드를 호출하고, &lt;strong&gt;두 코드가 같은 락을 사용&lt;/strong&gt;하는 상황이 가능하게 됩니다.&lt;br&gt;
이러한 재진입 동기화 없이는 &lt;code&gt;synchronized&lt;/code&gt; 코드는 스레드 스스로를 차단하지 않도록 추가적인 예방 조치를 취해야합니다.&lt;/p&gt;
&lt;h2 id=&#34;효율적인-코드-작성-측면에서-synchronized는-좋은-키워드일까&#34; &gt;효율적인 코드 작성 측면에서, &lt;code&gt;synchronized&lt;/code&gt;는 좋은 키워드일까?
&lt;span&gt;
    &lt;a href=&#34;#%ed%9a%a8%ec%9c%a8%ec%a0%81%ec%9d%b8-%ec%bd%94%eb%93%9c-%ec%9e%91%ec%84%b1-%ec%b8%a1%eb%a9%b4%ec%97%90%ec%84%9c-synchronized%eb%8a%94-%ec%a2%8b%ec%9d%80-%ed%82%a4%ec%9b%8c%eb%93%9c%ec%9d%bc%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 키워드는 공유 자원에 대한 여러 스레드의 접근을 제어해 간편하게 동기화 처리가 가능한 유용한 키워드지만, 아래와 같은 단점이 존재합니다.&lt;/p&gt;
&lt;h3 id=&#34;성능-저하&#34; &gt;성능 저하
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%b1%eb%8a%a5-%ec%a0%80%ed%95%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;락을 사용해 한 번에 한 스레드만 코드 블록(또는 메서드 전체)에 접근 가능하므로 다른 스레드들은 해당 코드 블록의 모니터가 필요한 다른 메서드들을 실행하지 못하고 대기해야 합니다. 따라서 멀티-스레드 환경의 이점인 &lt;strong&gt;동시성을 잃습니다&lt;/strong&gt;.&lt;br&gt;
또한,  &lt;code&gt;synchronized&lt;/code&gt; 코드 실행을 기다리는 동안 블록된 스레드는 중단(interrupt)될 수 없습니다.&lt;/p&gt;
&lt;h3 id=&#34;데드락&#34; &gt;데드락
&lt;span&gt;
    &lt;a href=&#34;#%eb%8d%b0%eb%93%9c%eb%9d%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;락을 기반&lt;/strong&gt;으로 동기화를 처리하므로, 둘 이상의 스레드가 락을 획득하고 서로의 락을 얻기위해 &lt;strong&gt;무한히 대기&lt;/strong&gt;하는 &lt;strong&gt;데드락이 발생할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;예상치-못한대로-동작할-수-있음&#34; &gt;예상치 못한대로 동작할 수 있음
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%83%81%ec%b9%98-%eb%aa%bb%ed%95%9c%eb%8c%80%eb%a1%9c-%eb%8f%99%ec%9e%91%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;락을 기반으로 하므로, &lt;em&gt;락의 기준으로 설정되는 객체에 따라&lt;/em&gt;  &lt;strong&gt;코드가 예상한대로 동작하지 않을 수&lt;/strong&gt; 있습니다.&lt;br&gt;
예를 들어 인스턴스 메서드 M1, M2에 &lt;code&gt;synchronized&lt;/code&gt; 키워드를 사용했고, 스레드 A,B 가 동작중인 상황이라면 스레드 A가 M1 메서드를 수행하는 동안, B는 &lt;em&gt;M1 메서드 뿐만 아니라&lt;/em&gt; &lt;strong&gt;M2 메서드에도 진입할 수 없습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이는 &lt;strong&gt;&lt;code&gt;synchronized&lt;/code&gt; 인스턴스 메서드&lt;/strong&gt; 의 락이 &lt;strong&gt;인스턴스를 기준&lt;/strong&gt;으로 하기 때문에 동일한 인스턴스에 대해서 메서드들은 이미 한 &lt;code&gt;synchronized&lt;/code&gt; 메서드가 실행 중이라면, 다른 &lt;code&gt;synchronized&lt;/code&gt; 메서드 역시 수행할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;synchronized이외의-다른-동기화-기법&#34; &gt;&lt;code&gt;synchronized&lt;/code&gt;이외의 다른 동기화 기법
&lt;span&gt;
    &lt;a href=&#34;#synchronized%ec%9d%b4%ec%99%b8%ec%9d%98-%eb%8b%a4%eb%a5%b8-%eb%8f%99%ea%b8%b0%ed%99%94-%ea%b8%b0%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Java에서는 &lt;code&gt;synchronized&lt;/code&gt; 키워드 이외에도 동기화를 처리할 수 있는 방법들을 제공하고 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;락-객체lock-object&#34; &gt;&lt;code&gt;락 객체(Lock Object)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%9d%bd-%ea%b0%9d%ec%b2%b4lock-object&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;락 객체는 기존의 &lt;code&gt;synchronized&lt;/code&gt; 블록에서 사용하던 &lt;code&gt;모니터&lt;/code&gt;와 유사하지만 보다 &lt;strong&gt;정교한 형태&lt;/strong&gt;입니다.&lt;br&gt;
&lt;code&gt;모니터&lt;/code&gt;와 마찬가지로 한 번에 한 스레드만 &lt;code&gt;Lock&lt;/code&gt; 객체를 소유할 수 있으며, &lt;code&gt;Lock&lt;/code&gt; 객체는 연결된 &lt;code&gt;Condition&lt;/code&gt; 객체를 통해 &lt;code&gt;대기/알림(wait/notify)&lt;/code&gt; 메커니즘도 지원합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;대기/알림(wait/notify)&lt;/code&gt;: 스레드가 처리할 수 있는 상태면 &lt;code&gt;notify()&lt;/code&gt;를 통해 Runnable 상태로, 그렇지 않다면 &lt;code&gt;wait()&lt;/code&gt;을 통해 대기 상태로 변경하는 방식.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;락 객체를 사용하면, 기존의 &lt;code&gt;모니터&lt;/code&gt;와 달리 락을 획득할 수 없는 경우 &lt;strong&gt;다른행동을 할 수 있다&lt;/strong&gt;는 장점이 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Friend&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; Lock lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ReentrantLock&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Lock을 얻고자 시도하는 함수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;impendingBow&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Friend bower&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		Boolean myLock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		Boolean yourLock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 락 획득 시도
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			myLock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lock&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;tryLock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			yourLock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bower&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;tryLock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(!&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;myLock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yourLock&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;myLock&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					lock&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;yourLock&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					bower&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; myLock &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; yourLock&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 메인 행동 함수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bow&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;Friend bower&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;impendingBow&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;bower&lt;span style=&#34;color:#f92672&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 락 획득에 성공한 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s: %s has&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; bowed to me!%n&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;					&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; bower&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				bower&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bowBack&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				lock&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				bower&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;unlock&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// 락 획득에 실패한 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;			System&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;format&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%s: %s started&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; to bow to me, but saw that&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; I was already bowing to&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; him.%n&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; bower&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 패키지에 인터페이스인 &lt;code&gt;Lock&lt;/code&gt;은 물론 &lt;code&gt;ReentrantLock&lt;/code&gt;와 같은 구현체도 존재합니다.&lt;/p&gt;
&lt;h3 id=&#34;volatile&#34; &gt;&lt;code&gt;Volatile&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#volatile&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;em&gt;공유 메모리 환경&lt;/em&gt;에서 발생할 수 있는 &lt;strong&gt;&lt;code&gt;캐시 일관성&lt;/code&gt;&lt;/strong&gt; 문제를 해결해주는 키워드입니다.
변수에 해당 키워드를 달게되면, &lt;em&gt;변수에 대한 모든 수정&lt;/em&gt;이 &lt;strong&gt;즉시&lt;/strong&gt; 다른 스레드에게 &lt;strong&gt;전파&lt;/strong&gt;됩니다. 이는 &lt;code&gt;Volatile&lt;/code&gt; 키워드가 달린 변수는 &lt;em&gt;CPU 캐시가 아닌&lt;/em&gt; &lt;strong&gt;메인 메모리에서 읽고 쓰기&lt;/strong&gt; 때문에 가능합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; number&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 코드 블록과 달리, 한 번에 &lt;em&gt;여러 스레드가 코드 블록을 실행해도&lt;/em&gt; &lt;strong&gt;변수의 가시성을 보장&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;원자-변수atomic-variable&#34; &gt;&lt;code&gt;원자 변수(Atomic variable)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%9b%90%ec%9e%90-%eb%b3%80%ec%88%98atomic-variable&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html&#34;&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;&lt;/a&gt; 패키지 내에 단일 변수에 대한 원자 연산을 지원하는 클래스들이 정의되어 있습니다.&lt;br&gt;
&lt;code&gt;AtomicBoolean&lt;/code&gt;, &lt;code&gt;AtomicInteger&lt;/code&gt; 등 &lt;strong&gt;원시 타입에 대응&lt;/strong&gt;되는 원자 변수는 물론, &lt;code&gt;AtomicReference&lt;/code&gt; 와 같이 &lt;strong&gt;객체에 대응&lt;/strong&gt;되는 원자 변수도 존재합니다.&lt;br&gt;
클래스들은 &lt;code&gt;volatile&lt;/code&gt; 변수에 대한 읽기/쓰기처럼 동작하는 &lt;code&gt;get()&lt;/code&gt;/&lt;code&gt;set()&lt;/code&gt;를 갖고 있습니다.&lt;br&gt;
따라서, &lt;code&gt;set()&lt;/code&gt;은 같은 변수에 대한 모든 이후의 &lt;code&gt;get()&lt;/code&gt; 호출에 대해 &lt;code&gt;발생-전 관계(happens-before Relationship)&lt;/code&gt; 를 갖습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; java.util.concurrent.atomic.AtomicInteger&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicCounter&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; AtomicInteger c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; AtomicInteger&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;increment&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Atomically increments by one the current value.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;incrementAndGet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decrement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// Atomically decrements by one the current value.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;decrementAndGet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;threadlocal이란&#34; &gt;ThreadLocal이란?
&lt;span&gt;
    &lt;a href=&#34;#threadlocal%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.lang&lt;/code&gt; 패키지에 존재하는 &lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html&#34;&gt;클래스&lt;/a&gt;로써, 이를 사용하면 &lt;em&gt;각 스레드 별로&lt;/em&gt; &lt;strong&gt;스스로만 접근할 수 있는 데이터&lt;/strong&gt;를 저장할 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 먼저, 값을 저장할 ThreadLocal 인스턴스를 생성합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;ThreadLocal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;타입&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; threadLocalValue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// get(), set() 메서드를 통해 값을 읽고, 쓸 수 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;threadLocalValue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Integer result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; threadLocalValue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// remove() 메서드를 통해 값을 지울 수 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;threadLocalValue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;주의사항&#34; &gt;주의사항
&lt;span&gt;
    &lt;a href=&#34;#%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;이를 ThreadPool과 함께 사용 할 경우, &lt;em&gt;ThreadLocal의 값을 지우지 않고&lt;/em&gt; 현재 &lt;strong&gt;스레드를 풀에 반납&lt;/strong&gt;했다 다시 사용하게 되면 &lt;strong&gt;이전에 ThreadLocal에 저장한 값&lt;/strong&gt;이 남아있게 됩니다.&lt;br&gt;
이를 주의해서 사용할 필요가 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;참고-문서&#34; &gt;참고 문서
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0-%eb%ac%b8%ec%84%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/25461463/can-a-synchronized-block-method-be-interrupted&#34;&gt;java - Can a synchronized block/method be interrupted? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1365880/disadvantage-of-synchronized-methods-in-java&#34;&gt;synchronization - Disadvantage of synchronized methods in Java - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://crackjamx.wordpress.com/2013/02/07/java-synchronized-%EC%A3%BC%EC%9D%98%EC%A0%90/&#34;&gt;Java – Synchronized 주의점 | Routine (wordpress.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-synchronized&#34;&gt;Guide to the Synchronized Keyword in Java | Baeldung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-threadlocal&#34;&gt;An Introduction to ThreadLocal in Java | Baeldung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-volatile&#34;&gt;Guide to the Volatile Keyword in Java | Baeldung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/java-synchronization-bad-practices&#34;&gt;Bad Practices With Synchronization | Baeldung&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.gmarket.com/62&#34;&gt;Thread의 개인 수납장 ThreadLocal (gmarket.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html&#34;&gt;Intrinsic Locks and Synchronization (The Java™ Tutorials &amp;gt; Essential Java Classes &amp;gt; Concurrency) (oracle.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html&#34;&gt;Synchronized Methods (The Java™ Tutorials &amp;gt; Essential Java Classes &amp;gt; Concurrency) (oracle.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/atomicvars.html&#34;&gt;Atomic Variables (The Java™ Tutorials &amp;gt; Essential Java Classes &amp;gt; Concurrency) (oracle.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html&#34;&gt;Lock Objects (The Java™ Tutorials &amp;gt; Essential Java Classes &amp;gt; Concurrency) (oracle.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/happens-before-relationship-in-java/&#34;&gt;Happens-Before Relationship in Java - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/inter-thread-communication-java/&#34;&gt;Inter-thread Communication in Java - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/synchronization-in-java/&#34;&gt;Synchronization in Java - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[DB] DB Locking 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/database/db-locking/</link>
      <pubDate>Mon, 26 Feb 2024 01:13:22 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/database/db-locking/</guid>
      <description>&lt;h2 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 2월 20일에 발표한 &lt;strong&gt;DB Locking&lt;/strong&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;db-locking이란&#34; &gt;DB Locking이란?
&lt;span&gt;
    &lt;a href=&#34;#db-locking%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;병행 트랜잭션이 가능한 환경에서&lt;/em&gt;, 변경중인 record를 다른 transaction들이 접근하지 못하도록 막음으로써, 병행 수행 문제를 해결하려는 접근 방법입니다.&lt;br&gt;
이러한 Locking을 위한 규약(Protocol)으로는 &lt;code&gt;Shared Locking Protocol&lt;/code&gt;, &lt;code&gt;2PLP(2-Phase Locking Protocol)&lt;/code&gt;, &lt;code&gt;Multiple Granularity Locking Protocol&lt;/code&gt; 이 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;병행-트랜잭션concurrent-transaction-이란&#34; &gt;병행 트랜잭션(Concurrent Transaction) 이란?
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98concurrent-transaction-%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;동시에 실행되고 있는 둘 이상의 트랜잭션을 의미합니다.&lt;/p&gt;
&lt;h4 id=&#34;병행-트랜잭션의-장점&#34; &gt;병행 트랜잭션의 장점
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%98-%ec%9e%a5%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;db의-공용도sharability-제고&#34; &gt;DB의 공용도(Sharability) 제고
&lt;span&gt;
    &lt;a href=&#34;#db%ec%9d%98-%ea%b3%b5%ec%9a%a9%eb%8f%84sharability-%ec%a0%9c%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;응답시간response-time-단축&#34; &gt;응답시간(Response Time) 단축
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%91%eb%8b%b5%ec%8b%9c%ea%b0%84response-time-%eb%8b%a8%ec%b6%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;시스템-활용도system-utilization-증대&#34; &gt;시스템 활용도(System Utilization) 증대
&lt;span&gt;
    &lt;a href=&#34;#%ec%8b%9c%ec%8a%a4%ed%85%9c-%ed%99%9c%ec%9a%a9%eb%8f%84system-utilization-%ec%a6%9d%eb%8c%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h4 id=&#34;병행-트랜잭션의-동시성-문제&#34; &gt;병행 트랜잭션의 동시성 문제
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%98-%eb%8f%99%ec%8b%9c%ec%84%b1-%eb%ac%b8%ec%a0%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;병행 트랜잭션의 병행 수행률이 상승할수록, 아래와 같은 병행 문제들의 발생률도 상승합니다. &lt;br&gt;
설명의 편의를 위해 병행 실행되는 트랜잭션 두 가지를 아래에서 T1, T2라고 부르도록 하겠습니다.&lt;/p&gt;
&lt;h5 id=&#34;갱신-분실lost-update&#34; &gt;갱신 분실(Lost Update)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b0%b1%ec%8b%a0-%eb%b6%84%ec%8b%a4lost-update&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;Lost-Update.png&#34; alt=&#34;Lost-Update.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;두 트랜잭션이 병렬로 같은 데이터를 읽고 갱신하는 과정에서, 한 트랜잭션이 다른 트랜잭션의 갱신 값을 덮어쓰는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 연산 후 갱신 작업을 수행한 뒤, 이후에 T2가 갱신된 값이 아닌 이전의 값을 기준으로 연산 후 갱신 작업을 수행해 T1의 갱신이 무효화 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;모순적-읽기inconsistent-read&#34; &gt;모순적 읽기(Inconsistent Read)
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%a8%ec%88%9c%ec%a0%81-%ec%9d%bd%ea%b8%b0inconsistent-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;두 트랜잭션이 병렬로 같은 데이터를 읽고 갱신하는 과정에서, 데이터 불일치가 발생하는 문제입니다.&lt;/p&gt;
&lt;h6 id=&#34;dirty-read&#34; &gt;Dirty Read
&lt;span&gt;
    &lt;a href=&#34;#dirty-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Dirty-Read.png&#34; alt=&#34;Dirty-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;격리성 수준이 &lt;code&gt;Read Uncommitted&lt;/code&gt; 이하인 환경에서 발생가능한 문제로, 한 트랜잭션이 다른 트랜잭션으로부터 &lt;strong&gt;커밋되지 않은 값을 읽어 발생&lt;/strong&gt;하는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 커밋되기 전, 중간에 T2가 T1에서 작업하던 데이터(&lt;em&gt;T1의 &lt;strong&gt;수정&lt;/strong&gt;이 &lt;strong&gt;반영되지 않은&lt;/strong&gt;&lt;/em&gt;)을 읽고 작업을 수행해 T1 연산 이전의 값으로 T2가 수행되게 됩니다. 이는 정확하지 않거나 일관되지 않은 결과를 야기할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;non-repeatable-read&#34; &gt;Non-repeatable Read
&lt;span&gt;
    &lt;a href=&#34;#non-repeatable-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Non-repeatable-Read.png&#34; alt=&#34;Non-repeatable-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;같은 데이터를 한 트랜잭션 내에서 읽었음에도, 둘의 값이 다른 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 두 번 읽을 때, 중간에 T2가 해당 데이터의 값을 변경한 뒤 커밋하게 되면 두 번째로 읽었을 때의 값은 처음 읽었던 값과 다르게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;phantom-read&#34; &gt;Phantom Read
&lt;span&gt;
    &lt;a href=&#34;#phantom-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Phantom-Read.png&#34; alt=&#34;Phantom-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;같은 조건에 대한 검색을 한 트랜잭션 내에서 수행했음에도, 다시 읽으려 할 때 이전에 존재하던 값이 없어지거나, 새로운 값이 추가로 검색되는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 두 번 읽을 때, 중간에 T2가 해당 데이터를 삭제한 뒤 커밋하게 되면 두 번째로 읽었을 때 해당 데이터는 존재하지 않게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;연쇄적-롤백cascading-rollback&#34; &gt;연쇄적 롤백(Cascading Rollback)
&lt;span&gt;
    &lt;a href=&#34;#%ec%97%b0%ec%87%84%ec%a0%81-%eb%a1%a4%eb%b0%b1cascading-rollback&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;Cascading-Rollback.png&#34; alt=&#34;Cascading-Rollback.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;한 트랜잭션이 갱신한 데이터를 다른 트랜잭션이 또 다시 갱신한 뒤, 앞선 트랜잭션을 롤백하려할 때 이후 실행했던 트랜잭션도 롤백해야 하나 이미 해당 트랜잭션은 완료되어 롤백이 불가능한 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 갱신한 뒤, T2이 해당 데이터를 또 갱신한 뒤 완료처리한 상태에서 T1을 롤백하려 하면 T2이 처리한 부분에 대해서는 롤백이 불가능하게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;transaction-schedule이란&#34; &gt;Transaction Schedule이란?
&lt;span&gt;
    &lt;a href=&#34;#transaction-schedule%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;트랜잭션들이 연산을 실행하는 순서를 의미합니다.&lt;br&gt;
스케줄의 개수는 &lt;code&gt;Interleaving(트랜잭션을 쪼개서 수행하는 것)&lt;/code&gt;이 가능한 경우 거의 무한대이고, 허용되지 않으면 $n!$ 개 입니다.&lt;br&gt;
병행 수행상 문제가 야기되느냐 그렇지 않느냐에 따라 직렬/비직렬 스케줄로 나뉩니다.&lt;/p&gt;
&lt;h4 id=&#34;직렬-스케줄serial-schedule&#34; &gt;직렬 스케줄(serial Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%eb%a0%ac-%ec%8a%a4%ec%bc%80%ec%a4%84serial-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;스케줄에 포함된 모든 트랜잭션이 하나씩 실행되는 스케줄을 의미합니다.&lt;br&gt;
병행 수행의 문제가 발생하지 않으나, 병행 트랜잭션으로 실행되지 않게 됩니다.&lt;/p&gt;
&lt;h4 id=&#34;비직렬-스케줄non-serial-schedule&#34; &gt;비직렬 스케줄(non-serial Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ec%a7%81%eb%a0%ac-%ec%8a%a4%ec%bc%80%ec%a4%84non-serial-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;스케줄에 포함된 모든 트랜잭션이 서로 interleaved되는 스케줄을 의미합니다.&lt;br&gt;
같은 트랜잭션 내 작업이라도 쪼개서 수행될 수 있기 때문에 쪼개진 작업이 실행되는 시점에 따라 잘못된 결과를 얻을 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;직렬-가능-스케줄serializable-schedule&#34; &gt;직렬 가능 스케줄(serializable Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84serializable-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;어떤 직렬 스케줄과 &lt;strong&gt;동등&lt;/strong&gt;한 비직렬 스케줄을 의미합니다.&lt;br&gt;
&lt;strong&gt;모든 충돌 직렬 가능 스케줄&lt;/strong&gt;은 &lt;strong&gt;뷰 직렬 가능 스케줄&lt;/strong&gt;이지만, &lt;em&gt;&lt;strong&gt;역은 성립하지 않습니다&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;h6 id=&#34;충돌-직렬-가능-스케줄&#34; &gt;충돌 직렬 가능 스케줄
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%a9%eb%8f%8c-%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;비직렬 스케줄 S에 대해 &lt;strong&gt;충돌 동등&lt;/strong&gt;한 직렬 스케줄 S&amp;rsquo;가 존재하면, S를 &lt;code&gt;충돌 직렬 가능 스케줄&lt;/code&gt; 이라고 합니다.&lt;/p&gt;
&lt;h6 id=&#34;뷰-직렬-가능-스케줄&#34; &gt;뷰 직렬 가능 스케줄
&lt;span&gt;
    &lt;a href=&#34;#%eb%b7%b0-%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;비직렬 스케줄 S에 대해 &lt;strong&gt;뷰 동등&lt;/strong&gt;한 직렬 스케줄 S&amp;rsquo;가 존재하면, S를 &lt;code&gt;뷰 직렬 가능 스케줄&lt;/code&gt; 이라고 합니다.&lt;/p&gt;
&lt;h5 id=&#34;스케줄-동등&#34; &gt;스케줄 동등
&lt;span&gt;
    &lt;a href=&#34;#%ec%8a%a4%ec%bc%80%ec%a4%84-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h6 id=&#34;결과result-동등&#34; &gt;결과(result) 동등
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%b0%ea%b3%bcresult-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;결과가 동일한 스케줄을 의미합니다.&lt;/p&gt;
&lt;h6 id=&#34;충돌conflict-동등&#34; &gt;충돌(conflict) 동등
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%a9%eb%8f%8cconflict-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;충돌 연산의 순서가 동일한 스케줄을 의미합니다.&lt;/p&gt;
&lt;h6 id=&#34;뷰view-동등&#34; &gt;뷰(view) 동등
&lt;span&gt;
    &lt;a href=&#34;#%eb%b7%b0view-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;스케줄 S1, S2에 포함된 트랜잭션이 같고 아래 조건을 만족하는 경우를 의미합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S1에서 $T_i$가 $x$의 초기 값을 읽는다면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;li&gt;S1에서 $T_i$의 모든 read(x)가 $T_j$가 write한 x값을 읽는다면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;li&gt;S1에서 $T_i$가 write(x)를 마지막으로 수행하면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lock-이란&#34; &gt;Lock 이란?
&lt;span&gt;
    &lt;a href=&#34;#lock-%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;DB상의 데이터 항목에 대한 잠금장치입니다.&lt;br&gt;
Lock이 걸린 데이터 항목은 Lock을 건 트랜잭션만 접근할 수 있습니다.&lt;br&gt;
Lcok은 Lock을 건 트랜잭션에 의해서만 Unlock할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;lock의-종류&#34; &gt;Lock의 종류
&lt;span&gt;
    &lt;a href=&#34;#lock%ec%9d%98-%ec%a2%85%eb%a5%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;공용-로크shared-lock-s-lock&#34; &gt;공용 로크(Shared Lock, S-Lock)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%b5%ec%9a%a9-%eb%a1%9c%ed%81%acshared-lock-s-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;다른 트랜잭션이 해당 데이터를 Read 할 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;전용-로크exclusive-lock-x-lock&#34; &gt;전용 로크(Exclusive Lock, X-Lock)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%84%ec%9a%a9-%eb%a1%9c%ed%81%acexclusive-lock-x-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;다른 트랜잭션이 해당 데이터를 Read/Write 할 수 없습니다.&lt;/p&gt;
&lt;h4 id=&#34;로크-단위lock-granularity&#34; &gt;로크 단위(Lock granularity)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%ed%81%ac-%eb%8b%a8%ec%9c%84lock-granularity&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;row, table, database 등 Locking할 자원의 크기를 말합니다.&lt;br&gt;
단위의 크기가 커질수록 병행성 수준은 낮아지고, 병행 제어 기법은 간단해집니다.&lt;/p&gt;
&lt;h4 id=&#34;로크-호환성-lock-compatibility&#34; &gt;로크 호환성 (Lock Compatibility)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%ed%81%ac-%ed%98%b8%ed%99%98%ec%84%b1-lock-compatibility&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;이미 자원에 특정 Lock이 설정되어 있는 경우, 다른 트랜잭션도 해당 자원에 대해 Lock을 설정할 수 있는지 여부를 말합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구 분&lt;/th&gt;
&lt;th&gt;Request S-lock&lt;/th&gt;
&lt;th&gt;Request X-lock&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S-locked data item&lt;/td&gt;
&lt;td&gt;ok&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-locked data item&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;locking-protocol&#34; &gt;Locking Protocol
&lt;span&gt;
    &lt;a href=&#34;#locking-protocol&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;아래 설명된 Protocol들 이외에도 기본적인 Locking Protocol은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션 T가 x에 대해 read(x)/write(x) 연산을 하려면 먼저 lock(x) 연산을 실행해야 한다.&lt;/li&gt;
&lt;li&gt;트랜잭션 T가 실행한 lock(x)에 대해서는 T가 모든 실행(Task)을 종료하기 전에 unlock(x) 연산을 수행해야 한다.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;em&gt;다른 트랜잭션에 의해 lock이 걸려있는&lt;/em&gt; x에 대해 &lt;strong&gt;lock(x)&lt;/strong&gt; 를 &lt;strong&gt;실행할 수 없다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;em&gt;자신이 lock을 걸지않은 x&lt;/em&gt;에 대해 &lt;strong&gt;unlock(x)&lt;/strong&gt; 을 &lt;strong&gt;실행할 수 없다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shared-locking-protocol공용-로킹-규약&#34; &gt;&lt;code&gt;Shared Locking Protocol(공용 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#shared-locking-protocol%ea%b3%b5%ec%9a%a9-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션 T는 &lt;strong&gt;read(x)&lt;/strong&gt; 전 반드시 &lt;mark style=&#34;background: #ADCCFFA6;&#34;&gt;lock-S(x)&lt;/mark&gt; 또는 &lt;mark style=&#34;background: #FFB86CA6;&#34;&gt;lock-X(x)&lt;/mark&gt;를 실행해야 함.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;strong&gt;write(x)&lt;/strong&gt; 전 반드시 &lt;mark style=&#34;background: #FFB86CA6;&#34;&gt;lock-X(x)&lt;/mark&gt;를 실행해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 규약 때문에 공용 로킹 규약은 &lt;strong&gt;&lt;code&gt;직렬가능성(serializability)&lt;/code&gt;&lt;/strong&gt; 을 보장하지 못합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;직렬가능성(serializability)&lt;/code&gt;&lt;/strong&gt; : 비직렬 스케줄을 직렬 스케줄로 변환할 수 있는지를 의미합니다.
&lt;ul&gt;
&lt;li&gt;lock과 unlock이 병렬로 수행될 수 있으므로 병행 처리되는 트랜잭션들이 서로 간섭할 수 있어 직렬 가능성이 보장되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2plp2-phase-locking-protocol-2단계-로킹-규약&#34; &gt;&lt;code&gt;2PLP(2-Phase Locking Protocol, 2단계 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#2plp2-phase-locking-protocol-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;lock만 가능한 Phase와 unlock만 가능한 phase를 나누어 로킹을 수행하는 규약입니다.&lt;br&gt;
&lt;code&gt;직렬가능성&lt;/code&gt;을 &lt;strong&gt;보장&lt;/strong&gt;하지만, &lt;strong&gt;&lt;code&gt;Deadlock&lt;/code&gt;&lt;/strong&gt; 문제가 존재하는 규약입니다.&lt;br&gt;
변형으로는 &lt;code&gt;Strict 2PLP&lt;/code&gt;, &lt;code&gt;Rigorous 2PLP&lt;/code&gt;가 존재하며, 상용 DBMS에서는 이 둘 중 하나를 사용합니다.&lt;/p&gt;
&lt;h5 id=&#34;1-단계growing-phase&#34; &gt;1 단계(Growing Phase)
&lt;span&gt;
    &lt;a href=&#34;#1-%eb%8b%a8%ea%b3%84growing-phase&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션은 계속해 lock을 획득할 수 있으나, unlock 연산은 실행할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-단계shrink-phase&#34; &gt;2 단계(Shrink Phase)
&lt;span&gt;
    &lt;a href=&#34;#2-%eb%8b%a8%ea%b3%84shrink-phase&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;unlock 연산만 실행할 수 있으며, 일단 Lock을 해제하면 더 이상 lock을 획득할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;strict-2plp엄격-2단계-로킹-규약&#34; &gt;Strict 2PLP(엄격 2단계 로킹 규약)
&lt;span&gt;
    &lt;a href=&#34;#strict-2plp%ec%97%84%ea%b2%a9-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;2PLP에 &amp;lsquo;모든 &lt;strong&gt;X-lock&lt;/strong&gt;은 &lt;em&gt;트랜잭션 완료시까지&lt;/em&gt; &lt;strong&gt;unlock 할 수 없다&lt;/strong&gt;&amp;lsquo;는 규칙이 추가된 형태입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현이 어려우나 성능이 높고&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;연쇄 복귀 문제(Cascading Rollback)&lt;/code&gt;&lt;/strong&gt; 가 발생하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;rigorous-2plp엄밀-2단계-로킹-규약&#34; &gt;Rigorous 2PLP(엄밀 2단계 로킹 규약)
&lt;span&gt;
    &lt;a href=&#34;#rigorous-2plp%ec%97%84%eb%b0%80-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;2PLP에 &amp;lsquo;모든 &lt;strong&gt;lock&lt;/strong&gt;은 &lt;em&gt;트랜잭션 완료시까지&lt;/em&gt; &lt;strong&gt;unlock 할 수 없다&lt;/strong&gt;&amp;lsquo;는 규칙이 추가된 형태입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현은 쉬우나 성능이 낮다&lt;/strong&gt;는 단점이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;multiple-granularity-locking-protocol다중-단위-로킹-규약&#34; &gt;&lt;code&gt;Multiple Granularity Locking Protocol(다중 단위 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#multiple-granularity-locking-protocol%eb%8b%a4%ec%a4%91-%eb%8b%a8%ec%9c%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;병행성 수준을 감소시키지 않기 위해, 필요 이상의 크기로 locking 하지 않는 방법입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;로킹 계층 트리 : DB -&amp;gt; 구역(Area) -&amp;gt; 파일(File) -&amp;gt; 레코드(Record)
&lt;img src=&#34;Multi-Granularity-tree-Hiererchy.png&#34; alt=&#34;Multi-Granularity-tree-Hiererchy.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DB: 모든 파일을 포함하는 데이터베이스입니다. 데이터베이스는 여러 파일로 구성됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구역(Area): 파일들로 이뤄진 데이터베이스 내 특정 영역입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일(File): 관련된 레코드들의 그룹입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;레코드(Record): DB 테이블에서 하나의 행입니다. 레코드는 여러 필드로 구성됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;optimistic-lockpessimistic-lock란&#34; &gt;Optimistic Lock/Pessimistic Lock란?
&lt;span&gt;
    &lt;a href=&#34;#optimistic-lockpessimistic-lock%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;h3 id=&#34;낙관적-로크optimistic-lock&#34; &gt;낙관적 로크(Optimistic Lock)
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%99%ea%b4%80%ec%a0%81-%eb%a1%9c%ed%81%acoptimistic-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;다른 트랜잭션과 충돌하지 않는다고 가정하고, 별도의 Locking 없이 자원에 접근하는 것을 말합니다.&lt;br&gt;
병행 제어를 위해 아래 세 과정을 수행하며, 각 과정마다 Start(T), Validation(T), Finish(T) 세 가지의 &lt;strong&gt;&lt;code&gt;타임스탬프&lt;/code&gt;&lt;/strong&gt; 를 사용합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;타임스탬프&lt;/code&gt;&lt;/strong&gt; : 시스템에서 &lt;strong&gt;트랜잭션&lt;/strong&gt;을 &lt;strong&gt;유일하게 식별&lt;/strong&gt;하기 위해 부여한 &lt;strong&gt;식별자(identifier)&lt;/strong&gt; 로, 트랜잭션이 &lt;strong&gt;시스템에 들어온 순서대로&lt;/strong&gt; 부여합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;과정&#34; &gt;과정
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%bc%ec%a0%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;판독 단계(Read Step)&lt;/code&gt; : 트랜잭션에 필요한 자료를 DB로 부터 읽어 &lt;strong&gt;Local Working Area에 복사&lt;/strong&gt;합니다. 이후 &lt;strong&gt;모든 갱신은 사본을 대상&lt;/strong&gt;으로 수행합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;확인 단계(Validation Step)&lt;/code&gt;: &lt;strong&gt;직렬(Serialization) 가능성 위반 여부&lt;/strong&gt;를 &lt;strong&gt;검사&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;기록 단계(Write Step)&lt;/code&gt;: 확인 단계를 통과하면 &lt;strong&gt;DB에 반영&lt;/strong&gt;하고, &lt;em&gt;통과하지 못했다면 실행 결과는 취소&lt;/em&gt;하고 트랜잭션은 복귀합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;비관적-로크pessimistic-lock&#34; &gt;비관적 로크(Pessimistic Lock)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ea%b4%80%ec%a0%81-%eb%a1%9c%ed%81%acpessimistic-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;다른 트랜잭션과 충돌한다고 가정하고, 트랜잭션을 처리하기 전에 자원에 대해 Locking을 시도하는것을 말합니다.&lt;/p&gt;
&lt;h4 id=&#34;과정-1&#34; &gt;과정
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%bc%ec%a0%95-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;자원에 대해 Lock을 겁니다.&lt;/li&gt;
&lt;li&gt;트랜잭션을 실행합니다.&lt;/li&gt;
&lt;li&gt;자원에 대해 Unlock을 수행합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;트랜잭션이-비정상-종료된-경우-lock을-해제할-해결책이-있는가-없다면-직접-해결-가능한가&#34; &gt;트랜잭션이 비정상 종료된 경우 Lock을 해제할 해결책이 있는가? 없다면 직접 해결 가능한가?
&lt;span&gt;
    &lt;a href=&#34;#%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%b4-%eb%b9%84%ec%a0%95%ec%83%81-%ec%a2%85%eb%a3%8c%eb%90%9c-%ea%b2%bd%ec%9a%b0-lock%ec%9d%84-%ed%95%b4%ec%a0%9c%ed%95%a0-%ed%95%b4%ea%b2%b0%ec%b1%85%ec%9d%b4-%ec%9e%88%eb%8a%94%ea%b0%80-%ec%97%86%eb%8b%a4%eb%a9%b4-%ec%a7%81%ec%a0%91-%ed%95%b4%ea%b2%b0-%ea%b0%80%eb%8a%a5%ed%95%9c%ea%b0%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;잘 설계된 DBMS에서는 Lock이 오랫동안 유지되어 Deadlock과 같은 상황을 발생시키지 않도록 여러 대비책을 갖고 있으며, 대부분의 DBMS에서는 Lock 관리를 위한 기능을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;lock-timeout&#34; &gt;Lock Timeout
&lt;span&gt;
    &lt;a href=&#34;#lock-timeout&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;Lock을 걸 때, 타임아웃을 설정해 일정시간이 지나면 자동으로 Lock을 해제하도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;deadlock-detection&#34; &gt;Deadlock Detection
&lt;span&gt;
    &lt;a href=&#34;#deadlock-detection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;교착상태가 발생하면 사후에 트랜잭션들 중 하나를 강제종료(&lt;code&gt;rollback&lt;/code&gt;) 시키는 조치를 취하는 방식입니다.&lt;/p&gt;
&lt;h3 id=&#34;일반적인-회복-방법&#34; &gt;일반적인 회복 방법
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ed%9a%8c%eb%b3%b5-%eb%b0%a9%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;이외에도 Redo, Undo와 같은 회복 방법을 통해 트랜잭션으로 손상된 부분을 회복시킬 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;redo-media-recovery&#34; &gt;Redo (Media Recovery)
&lt;span&gt;
    &lt;a href=&#34;#redo-media-recovery&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;비소멸장치(디스크, 테이프 등)의 내용 손상에 대한 회복 기법입니다.&lt;br&gt;
가장 최근의 복제본(dump)을 적재시키고, 해당 복제본 이후의 변경을 log를 이용해 재실행하여 DB를 복원합니다.&lt;/p&gt;
&lt;h4 id=&#34;undo&#34; &gt;Undo
&lt;span&gt;
    &lt;a href=&#34;#undo&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;log를 이용해 모든 변경을 취소시키므로써 DB를 복원합니다.&lt;/p&gt;
&lt;h4 id=&#34;소멸-장치의-정보-회복&#34; &gt;소멸 장치의 정보 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%86%8c%eb%a9%b8-%ec%9e%a5%ec%b9%98%ec%9d%98-%ec%a0%95%eb%b3%b4-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;log-이용-회복&#34; &gt;Log 이용 회복
&lt;span&gt;
    &lt;a href=&#34;#log-%ec%9d%b4%ec%9a%a9-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;트랜잭션이 Write 연산을 실행하거나, 트랜잭션의 시작/완료/철회와 같은 특별 활동시 기록되는 Log를 활용해 회복하는 방법입니다.&lt;br&gt;
Log는 &lt;code&gt;On-line log(실행중인 트랜잭션에 대한 로그)&lt;/code&gt;, &lt;code&gt;Archival log(누적되는 로그를 안정 저장장치에 저장한 것)&lt;/code&gt;로 나뉩니다.&lt;/p&gt;
&lt;h6 id=&#34;지연-갱신deferred-update의-회복&#34; &gt;지연 갱신(Deferred Update)의 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%80%ec%97%b0-%ea%b0%b1%ec%8b%a0deferred-update%ec%9d%98-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;트랜잭션이 부분 완료될 때 까지 DB 변경내역을 log에 전부 기록한 뒤, 부분 완료되면 보류시킨 Output 연산을 log를 사용해 처리합니다.&lt;br&gt;
트랜잭션 &lt;strong&gt;실행 중 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;처음부터 다시 실행&lt;/strong&gt;하고, &lt;strong&gt;완료 후 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;Log을 사용해 트랜잭션을 Redo&lt;/strong&gt; 합니다.&lt;/p&gt;
&lt;h6 id=&#34;즉시-갱신immediate-update의-회복&#34; &gt;즉시 갱신(Immediate Update)의 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%a6%89%ec%8b%9c-%ea%b0%b1%ec%8b%a0immediate-update%ec%9d%98-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;트랜잭션이 실행되는 동안 발생한 변경 내용을 DB에 그대로 반영해 처리합니다.&lt;br&gt;
트랜잭션 &lt;strong&gt;실행 중 장애가 발생&lt;/strong&gt;했다면 해당 &lt;strong&gt;트랜잭션에 대한 Undo&lt;/strong&gt;를 실행하고, &lt;strong&gt;완료 후 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;트랜잭션을 Redo&lt;/strong&gt; 합니다.&lt;/p&gt;
&lt;h5 id=&#34;검사시점check-point-회복&#34; &gt;검사시점(Check Point) 회복
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%80%ec%82%ac%ec%8b%9c%ec%a0%90check-point-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;em&gt;Log를 이용할 경우&lt;/em&gt; Redo/Undo 대상 트랜잭션을 찾기위해 &lt;strong&gt;log 전체를 조사&lt;/strong&gt;하거나,&lt;strong&gt;불필요한 Redo를 반복&lt;/strong&gt;한다는 &lt;strong&gt;문제를 해결&lt;/strong&gt;하기 위해 일정 간격으로 &lt;strong&gt;CheckPoint를 설치&lt;/strong&gt;해 이를 사용하는 기법입니다.&lt;br&gt;
Log를 차례로 검사하며 트랜잭션의 start를 만났다면 해당 트랜잭션을 Undo-list에, 트랜잭션의 commit을 만났다면 Undo-list에서 삭제하고 Redo-list에 추가합니다. 이후 Undo-list의 트랜잭션을 log에 기록된 역순으로 Undo를, Redo-list의 트랜잭션을 log에 기록된 순서로 Redo를 수행합니다.&lt;/p&gt;
&lt;h5 id=&#34;그림자-페이징shadow-paging-기법&#34; &gt;그림자 페이징(Shadow Paging) 기법
&lt;span&gt;
    &lt;a href=&#34;#%ea%b7%b8%eb%a6%bc%ec%9e%90-%ed%8e%98%ec%9d%b4%ec%a7%95shadow-paging-%ea%b8%b0%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;트랜잭션을 실행하는 동안 2개의 page table을 유지하는 방법입니다.&lt;br&gt;
current page table은 write 연산을 실행할 때 변경하며, shadow page table은 트랜잭션 실행 직전의 상태를 유지합니다.&lt;br&gt;
트랜잭션 완료 전 장애가 발생한 경우 shadow page table을 복사해 실행 직전으로 복귀시킵니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34; &gt;참고 자료
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0-%ec%9e%90%eb%a3%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;전공과목 강의자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)&#34;&gt;Isolation (database systems) - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/dbms-dirty-read-in-sql/&#34;&gt;Dirty Read in SQL - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/concurrency-problems-in-dbms-transactions/&#34;&gt;Concurrency problems in DBMS Transactions - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jidum.com/jidums/view.do?jidumId=282&#34;&gt;동시성제어개요 - 지식덤프&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/serializability-in-dbms/&#34;&gt;Serializability in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.jboss.org/hibernate/orm/4.1/devguide/en-US/html/ch05.html&#34;&gt;Chapter 5. Locking - Hibernate Community Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms/&#34;&gt;Lock Based Concurrency Control Protocol in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/docs/en/db2/11.5?topic=overview-optimistic-locking&#34;&gt;Optimistic locking - IBM Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.sap.com/doc/saphelp_nw73ehp1/7.31.19/en-us/47/dc35af5bc33b8be10000000a421937/content.htm?no_cache=true&#34;&gt;How Optimistic Locks Work - SAP Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://magicsoftware.my.salesforce-sites.com/PublicKnowledge/articles/bl_Reference/Physical-Locks-xpa-3x&#34;&gt;Reference: Physical Locks (Magic xpa 3.x) - Salesforce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/multiple-granularity-locking-in-dbms/&#34;&gt;Multiple Granularity Locking in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&#34;&gt;MySQL :: MySQL 8.0 Reference Manual :: 17.7.1 InnoDB Locking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.umsl.edu/~joshik/msis480/chapt06.htm&#34;&gt;6 Database Management - University of Missouri–St. Louis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

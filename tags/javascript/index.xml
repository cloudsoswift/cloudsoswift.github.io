<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on 오늘도 개발을 한다.</title>
    <link>https://cloudsoswift.github.io/tags/javascript/</link>
    <description>오늘도 개발을 한다. (Javascript)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 01 Aug 2024 10:05:48 +0900</lastBuildDate>
    
    <atom:link href="https://cloudsoswift.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Javascript] 추상 구문 트리(AST) 알아보기(w. 파스 트리, CFG, BNF)</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/ast/</link>
      <pubDate>Thu, 01 Aug 2024 10:05:48 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/ast/</guid>
      <description>&lt;h2 id=&#34;ast&#34; &gt;AST?
&lt;span&gt;
    &lt;a href=&#34;#ast&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;추상 구문 트리(Abstract Syntax Tree, AST)&lt;/code&gt;란, 프로그램 또는 코드 조각의 구조를 표현하기 위해 사용되는 &lt;code&gt;자료구조&lt;/code&gt;를 말합니다. 이때 트리를 이루는 각 노드들은 코드에서 발생되는 구문을 나타냅니다.&lt;br&gt;
구문이 &lt;code&gt;추상적이다(Abstract)&lt;/code&gt; 라는 말의 뜻은, 이 트리가 실제 구문의 모든 세부 사항들을 나타내지는 않고 구조나 내용과 관련된 세부 사항들만 나타낸다는 뜻입니다.&lt;br&gt;
이러한 특징은 &lt;code&gt;구문 트리(또는 파스 트리)&lt;/code&gt;라고 불리는 개념과 &lt;code&gt;추상 구문 트리&lt;/code&gt;를 구분되게 합니다.&lt;/p&gt;
&lt;h3 id=&#34;구문-트리파스-트리&#34; &gt;구문 트리(파스 트리)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b5%ac%eb%ac%b8-%ed%8a%b8%eb%a6%ac%ed%8c%8c%ec%8a%a4-%ed%8a%b8%eb%a6%ac&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;구문 트리(파스 트리)&lt;/code&gt;란, &lt;code&gt;문맥 자유 문법(Context-Free Grammar, CFG)&lt;/code&gt;을 따르는 문자열의 구문 구조를 나타내는 트리로, 유도과정 또는 구문 구조를 보여줍니다.&lt;br&gt;
만약 주어진 표현을 &lt;code&gt;구문 트리&lt;/code&gt;로 나타낼 수 있을 경우, 해당 표현은 주어진 &lt;code&gt;BNF&lt;/code&gt;에 의해 작성되었다고 할 수 있습니다.&lt;br&gt;
파스 트리는 아래 설명할 &lt;code&gt;추상 구문 트리&lt;/code&gt;처럼 &lt;code&gt;어휘 분석&lt;/code&gt;과 &lt;code&gt;구문 분석&lt;/code&gt; 과정을 통해 생성되며, 이는 &lt;code&gt;생성 규칙&lt;/code&gt;을 바탕으로 시작 기호부터 점점 반복적으로 &lt;code&gt;비-터미널 기호&lt;/code&gt;들을 치환해나가 궁극적으로 문자열을 유도하는 &lt;code&gt;유도 과정&lt;/code&gt;을 그래픽으로 표현한 것으로도 볼 수 있습니다. (그래서 &lt;code&gt;구문 트리&lt;/code&gt;를 &lt;code&gt;유도&lt;/code&gt;의 &lt;code&gt;역&lt;/code&gt;이라고 일컫기도 합니다.)&lt;/p&gt;
&lt;h4 id=&#34;파스-트리-규칙&#34; &gt;파스 트리 규칙
&lt;span&gt;
    &lt;a href=&#34;#%ed%8c%8c%ec%8a%a4-%ed%8a%b8%eb%a6%ac-%ea%b7%9c%ec%b9%99&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;모든 리프 노드는 &lt;code&gt;터미널&lt;/code&gt;이어야 한다.&lt;/li&gt;
&lt;li&gt;모든 내부 노드는 &lt;code&gt;터미널이 아니어야(Non-Terminal)&lt;/code&gt; 한다.&lt;/li&gt;
&lt;li&gt;트리를 &lt;code&gt;중위순회&lt;/code&gt; 할 경우, 주어진 문자열을 완성해야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;여기서 &lt;code&gt;터미널&lt;/code&gt;이란, &lt;code&gt;터미널 기호(Terminal Symbol)&lt;/code&gt;를 뜻하며 &lt;code&gt;형식 문법(Formal Grammar)&lt;/code&gt; 의 일부로 정의된 언어의 &lt;code&gt;기본 기호&lt;/code&gt;를 말합니다.&lt;br&gt;
&lt;code&gt;비-터미널 기호(Non-terminal Symbol)&lt;/code&gt;의 경우, &lt;code&gt;생성 규칙(Production Rule)&lt;/code&gt;에 따라 &lt;code&gt;터미널 기호&lt;/code&gt;로 대체되는 기호들을 말합니다.&lt;/p&gt;
&lt;h4 id=&#34;예시&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;다음과 같은 &lt;code&gt;생성 규칙&lt;/code&gt;을 갖는 문법이 있다고 가정하겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;생성 규칙&lt;/code&gt;: 규칙의 왼쪽에 정의될 대상이, 오른쪽에 그 대상에 대한 정의가 나타나는 구문 규율&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;S -&amp;gt; AB
A -&amp;gt; c/aA
B -&amp;gt; d/bB
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이때 주어진 입력 문자열이 &amp;ldquo;acbd&amp;quot;라고 할 경우, 파스 트리는 다음과 같습니다.
&lt;img src=&#34;parse-tree-example.jpg&#34; alt=&#34;parse-tree-example.jpg&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;문맥-자유-문법context-free-grammar-cfg&#34; &gt;문맥 자유 문법(Context-Free Grammar, CFG)
&lt;span&gt;
    &lt;a href=&#34;#%eb%ac%b8%eb%a7%a5-%ec%9e%90%ec%9c%a0-%eb%ac%b8%eb%b2%95context-free-grammar-cfg&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;문맥 자유 문법(CFG)&lt;/code&gt;이란, 문맥과 관계 없이 &lt;code&gt;비-터미널 기호&lt;/code&gt;에 &lt;code&gt;생성 규칙&lt;/code&gt;을 적용할 수 있는 형식 문법을 말합니다.&lt;br&gt;
다르게 말하면, 문법 $G$가 다음과 같다고 할 때,
$$G = (V, T, S, P)$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;V: 변수라고 부르는 객체들의 유한 집합&lt;br&gt;
T : 터미널 기호라 불리는 객체들의 유한 집합&lt;br&gt;
S : 시작 변수(V 중 시작할 때 사용하는 것)&lt;br&gt;
P : 생성 규칙들의 유한집합&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;모든 생성 규칙이 다음을 만족할 경우 G를 &lt;code&gt;문맥 자유 문법&lt;/code&gt; 이라고 합니다.&lt;br&gt;
$$ A \rightarrow x $$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A$는 &lt;code&gt;비-터미널 기호&lt;/code&gt;, $x$는 &lt;code&gt;터미널&lt;/code&gt; 및(또는) &lt;code&gt;비-터미널&lt;/code&gt; 문자열(또는 비어있을 수 있음)입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;배커스-나우르-표기법backus-naur-form-bnf&#34; &gt;배커스-나우르 표기법(Backus-Naur Form, BNF)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b0%b0%ec%bb%a4%ec%8a%a4-%eb%82%98%ec%9a%b0%eb%a5%b4-%ed%91%9c%ea%b8%b0%eb%b2%95backus-naur-form-bnf&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;기호&amp;gt; ::= &amp;lt;표현식&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;배커스-나우르 표기법(BNF)&lt;/code&gt;이란, &lt;code&gt;문맥 자유 문법&lt;/code&gt;을 나타내기 위해 만들어진 표기법(메타 언어)을 말합니다. 다르게 말하면 한 언어의 구문에 대한 &lt;code&gt;생성 규칙들의 집합&lt;/code&gt;이라고 할 수 있습니다.&lt;br&gt;
&lt;code&gt;BNF&lt;/code&gt;는 위와 같은 문법을 사용하는데, 여기서 &lt;code&gt;&amp;lt;기호&amp;gt;&lt;/code&gt;는 &lt;code&gt;터미널 기호&lt;/code&gt;가 될 수 없고 꺾쇠쌍으로 감싸져있으며, &lt;code&gt;표현식&lt;/code&gt;은 &lt;code&gt;터미널&lt;/code&gt; 또는 &lt;code&gt;비-터미널 기호&lt;/code&gt;로 이뤄진 하나 이상의 시퀀스들로 구성되고 각 시퀀스들은 &lt;code&gt;|&lt;/code&gt;로 구분됩니다.&lt;br&gt;
구문적으로 올바른 시퀀스들은 &lt;code&gt;시작 심볼&lt;/code&gt;이 하나만 포함되도록 시퀀스를 초기화하고, 이 &lt;code&gt;시작 심볼&lt;/code&gt;과 이어지는 심볼 시퀀스들에 파생 규칙들을 적용해야 합니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-1&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;bnf-example.png&#34; alt=&#34;bnf-example.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;추상-구문-트리&#34; &gt;추상 구문 트리
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%94%ec%83%81-%ea%b5%ac%eb%ac%b8-%ed%8a%b8%eb%a6%ac&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;process-of-compiler.png&#34; alt=&#34;process-of-compiler.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;출처: &lt;a href=&#34;https://courses.cs.washington.edu/courses/cse401/06sp/syn.pdf&#34;&gt;CSE401: Introduction to Compiler Construction - Syntactic Analysis&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;추상 구문 트리&lt;/code&gt;는 &lt;code&gt;컴파일러&lt;/code&gt;를 구성하는 &lt;code&gt;프론트엔드(소스 코드를 스캔하고 파싱함)&lt;/code&gt; 및 &lt;code&gt;백엔드(아웃풋을 생성함)&lt;/code&gt; 중 프론트엔드의 결과물로 만들어지게 됩니다.&lt;br&gt;
또한 앞서 말했듯, &lt;code&gt;추상 구문 트리&lt;/code&gt;는 실제 구문의 모든 세부 사항을 나타내지는 않습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예시로 그룹화 괄호는 &amp;ldquo;&lt;code&gt;트리 구조&lt;/code&gt;&amp;ldquo;라는 &lt;em&gt;형태로 이미 내포&lt;/em&gt;되어 있으므로 &lt;strong&gt;별도의 노드로 나타내지 않습니다&lt;/strong&gt;.
&lt;ul&gt;
&lt;li&gt;마찬가지로, &lt;code&gt;if-condition-then&lt;/code&gt; 문과 같은 구문 구조는 3개의 가지를 갖는 단일 노드로 표현됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그리고 AST는 포함된 요소들의 속성, 애너테이션과 같은 정보를 사용해 소스 코드의 변경 없이 수정 및 개선이 가능하고, 소스 코드의 불필요한 기호(중괄호, 세미콜론 등)들이 포함되지 않는 등의 특징을 지닙니다.&lt;br&gt;
이 때문에 주로 컴파일러가 &lt;code&gt;의미 분석(Semantic Analysis, 선언과 구문이 의미론적으로 정확한지 확인하는 작업으로 각 연산자가 일치하는 피연산자를 갖고 있는지 확인하는 &amp;quot;타입 검사&amp;quot;와 같은 작업을 포함함)&lt;/code&gt;을 수행할 때 유용하게 사용됩니다.&lt;/p&gt;
&lt;h4 id=&#34;생성-과정&#34; &gt;생성 과정
&lt;span&gt;
    &lt;a href=&#34;#%ec%83%9d%ec%84%b1-%ea%b3%bc%ec%a0%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;process-of-generate-ast.png&#34; alt=&#34;process-of-generate-ast.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;출처: &lt;a href=&#34;https://dev.to/balapriya/abstract-syntax-tree-ast-explained-in-plain-english-1h38&#34;&gt;Abstract Syntax Tree (AST) - Explained in Plain English - DEV Community&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;소스 코드로부터 &lt;code&gt;추상 구문 트리&lt;/code&gt;를 생성해내기 위해서는 위 그림과 같이 &lt;code&gt;어휘 분석(Lexical Analysis, 또는 스캐너)&lt;/code&gt;과 &lt;code&gt;구문 분석(Syntactic Analysis)&lt;/code&gt; 과정을 거쳐야합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그리고 컴파일러에서 이들을 수행하는 부분을 &lt;code&gt;Parser&lt;/code&gt;라고 일컫습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;어휘-분석lexical-analysis&#34; &gt;어휘 분석(Lexical Analysis)
&lt;span&gt;
    &lt;a href=&#34;#%ec%96%b4%ed%9c%98-%eb%b6%84%ec%84%9dlexical-analysis&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;어휘 분석기(Lexer 또는 Scanner)&lt;/code&gt;가 소스 코드를 한 글자씩 읽으며 문자열을 (의미론 또는 구문론적으로)의미있는 &lt;code&gt;어휘 토큰(코드의 가장 작은 단위)&lt;/code&gt;으로 그룹화하게 됩니다.&lt;br&gt;
이러한 토큰은 상수, 연산자, 구두점(중괄호, 세미콜론 등), 키워드(if, while 등)와 같은 범주 중 하나에 속하게 됩니다.&lt;br&gt;
대부분의 어휘 분석은 다음과 같은 단계를 따릅니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;토큰 식별하기(토큰화)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;입력 텍스트들을 일련의 토큰으로 분할해, 입력 기호들의 고정된 집합을 결정합니다. 이는 &lt;code&gt;문자(letter)&lt;/code&gt;, &lt;code&gt;숫자(digit)&lt;/code&gt;, &lt;code&gt;연산자(operator)&lt;/code&gt; 등을 포함합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;문자열을 토큰에 할당하기&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;어휘 분석기(Lexer)&lt;/code&gt;에 설정된 분류 체계대로 입력 문자들을 인식하고 분류합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;토큰의 어휘 반환하기&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;어휘&lt;/strong&gt;는 기본적으로 토큰을 구성하는 하위 문자열 집합에서 가장 작은 단위를 말합니다. &lt;code&gt;어휘 분석기&lt;/code&gt;는 이 어휘를 반환하게 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;예시-2&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-2&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x = a + b * 2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;만약 다음과 같은 표현식을 &lt;code&gt;어휘 분석&lt;/code&gt;할 경우, 다음과 같은 &lt;code&gt;토큰 시퀀스&lt;/code&gt;를 얻을 수 있습니다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[(identifier, x), (operator, =), (identifier, a), (operator, +), (identifier, b), (operator, *), (literal, 2), (separator, ;)]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;구문-분석syntactic-analysis&#34; &gt;구문 분석(Syntactic Analysis)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b5%ac%eb%ac%b8-%eb%b6%84%ec%84%9dsyntactic-analysis&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;파싱(Parsing)&lt;/code&gt;이라고도 불리는 이 작업은, &lt;code&gt;어휘 분석기&lt;/code&gt;로부터 전달받은 &lt;code&gt;토큰 스트림&lt;/code&gt;을 이것의 문법적 구조를 나타내는 &lt;code&gt;트리 형태의 표현&lt;/code&gt;을 생성하게 됩니다.&lt;br&gt;
그리고 위 과정에서 주어진 프로그램이 구문론적으로 정확한지 판단하며, 만약 에러를 찾은 경우 &lt;code&gt;구문 분석기&lt;/code&gt;는 진단 메세지를 생성하고 오류를 복구해야 합니다.&lt;br&gt;
&lt;code&gt;구문 분석기&lt;/code&gt;, 즉 &lt;code&gt;파서(Parser)&lt;/code&gt;는 &lt;code&gt;파스 트리&lt;/code&gt;를 구축하는 방향에 따라 크게 &lt;code&gt;탑-다운 파서&lt;/code&gt;와 &lt;code&gt;바텀-업 파서&lt;/code&gt;로 나뉩니다.&lt;/p&gt;
&lt;h6 id=&#34;예시-3&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-3&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;어휘 분석 예시에서 나왔던 표현식을 &lt;code&gt;구문 분석&lt;/code&gt;할 경우, 다음과 같은 &lt;code&gt;추상 구문 트리&lt;/code&gt;를 얻을 수 있습니다.&lt;br&gt;
&lt;img src=&#34;syntactic-analysis-example.jpg&#34; alt=&#34;syntactic-analysis-example.jpg&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;종합-예시&#34; &gt;종합 예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%a2%85%ed%95%a9-%ec%98%88%ec%8b%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;while (x &amp;lt; 30) {
	x = x + y * 2;
}
return x;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위와 같은 코드가 있다고 할 때, 이를 기반으로 &lt;code&gt;추상 구문 트리&lt;/code&gt;를 만들어보겠습니다.&lt;br&gt;
먼저, &lt;code&gt;어휘 분석&lt;/code&gt;을 통해 소스 코드를 &lt;code&gt;어휘 토큰&lt;/code&gt;들로 변환합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;어휘소(Lexeme)&lt;/th&gt;
&lt;th&gt;토큰 구분&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;while&lt;/td&gt;
&lt;td&gt;WHILE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;variable Identifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;comparison Operator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;integer Literal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;variable Identifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;assignment Operator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;variable Identifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;addition Operator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;variable Identifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;multiplication Operator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;integer Literal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;;&lt;/td&gt;
&lt;td&gt;Semicolon&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;return&lt;/td&gt;
&lt;td&gt;RETURN&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;variable Identifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;;&lt;/td&gt;
&lt;td&gt;Semicolon&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;이후, 이들을 기반으로 &lt;code&gt;추상 구문 트리&lt;/code&gt;를 만들면, 다음과 같습니다.&lt;br&gt;
&lt;img src=&#34;ast-example.png&#34; alt=&#34;ast-example.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;트리의 간략화를 위해 토큰 구분은 생략했습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이를 자바스크립트 코드로 생성한 &lt;code&gt;AST&lt;/code&gt;(&lt;em&gt;편의를 위해 JSON 형태로 변환함&lt;/em&gt;)로 표현한다면 다음과 같습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Program&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;71&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;body&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;FunctionDeclaration&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;70&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Identifier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;func&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;expression&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;generator&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;async&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;params&amp;#34;&lt;/span&gt;: [],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;body&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BlockStatement&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;70&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;body&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;WhileStatement&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;21&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;57&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;test&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BinaryExpression&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Identifier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;operator&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Literal&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;34&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;raw&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;30&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;body&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BlockStatement&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;36&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;57&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;body&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ExpressionStatement&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;54&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;expression&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;AssignmentExpression&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;53&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;operator&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Identifier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;41&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BinaryExpression&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;44&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;53&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Identifier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;44&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;45&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;operator&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BinaryExpression&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;53&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;left&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Identifier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;49&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;y&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;operator&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;right&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Literal&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;52&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;53&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                          &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;raw&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ReturnStatement&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;59&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;68&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;argument&amp;#34;&lt;/span&gt;: {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Identifier&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;start&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;66&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;end&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;67&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;sourceType&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;module&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;ast의-활용-예시&#34; &gt;AST의 활용 예시
&lt;span&gt;
    &lt;a href=&#34;#ast%ec%9d%98-%ed%99%9c%ec%9a%a9-%ec%98%88%ec%8b%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;AST는 &lt;a href=&#34;https://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html&#34;&gt;Java 소스 코드를 분석해 Eclipse IDE의 도구들을 사용하거나&lt;/a&gt;, &lt;code&gt;Annotation Processor&lt;/code&gt;가 AST를 조작해 애너테이션의 동작을 수행하거나, &lt;a href=&#34;https://www-old.cs.utah.edu/flux/flick/current/doc/guts/gutsch6.html&#34;&gt;C/C++ 소스 코드의 내부 표현을 제공하거나(CAST)&lt;/a&gt;, &lt;a href=&#34;https://docs.python.org/3/library/ast.html&#34;&gt;Python 코드를 정적 분석하는&lt;/a&gt; 등 언어를 가리지 않고 다양한 곳에서 사용되고 있습니다.&lt;br&gt;
특히, Javascript에서는 다음과 같은 도구들에서 AST를 사용하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;최신 자바스크립트 문법을 이전 자바스크립트 버전과 호환시키는 작업인 &lt;code&gt;트랜스파일링&lt;/code&gt;을 수행하는데 &lt;a href=&#34;https://babeljs.io/docs/babel-parser&#34;&gt;&lt;code&gt;AST 파서(구 Babylon 현 @babel/parser)&lt;/code&gt;&lt;/a&gt; 및 &lt;a href=&#34;https://babeljs.io/docs/babel-generator&#34;&gt;&lt;code&gt;생성기(@babel/generator)&lt;/code&gt;&lt;/a&gt;를 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;Typescript&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;타입스크립트에서 &lt;code&gt;타입을 체크&lt;/code&gt;하고, &lt;code&gt;에러를 검출&lt;/code&gt;한 뒤 자바스크립트 코드로 변환하는데 있어 AST 표현을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eslint.org/&#34;&gt;ESLint&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;정적 분석 도구&lt;/code&gt;인 &lt;code&gt;ESLint&lt;/code&gt;는 &lt;code&gt;AST&lt;/code&gt;(&lt;a href=&#34;https://github.com/estree/estree&#34;&gt;ESTree&lt;/a&gt; 포맷을 따르는)를 사용해 코드를 검사하며, 코딩 표준을 지키지 않았거나 에러가 발생할 수 있는 곳을 발견합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jestjs.io/&#34;&gt;Jest&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트 코드의 단위 테스트, 통합 테스트 등을 수행하는데 사용되는 테스트 프레임워크인 &lt;code&gt;Jest&lt;/code&gt;에서 역시 &lt;code&gt;AST&lt;/code&gt;를 사용해 &lt;code&gt;코드를 표현&lt;/code&gt;하고 &lt;code&gt;테스트를 수행&lt;/code&gt;합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Context-free_grammar&#34;&gt;Context-free grammar - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Abstract_syntax_tree&#34;&gt;Abstract syntax tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols&#34;&gt;Terminal and nonterminal symbols - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;구문 트리
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Parsing&#34;&gt;Parsing - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/parse-tree-in-compiler-design/&#34;&gt;Parse Tree in Compiler Design - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://web.mit.edu/6.005/www/fa15/classes/18-parser-generators/&#34;&gt;Reading 18: Parser Generators (mit.edu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://web.mit.edu/6.031/www/sp17/classes/18-parsers/#handling_errors&#34;&gt;Reading 18: Parsers (mit.edu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/kelly9509/222330672820&#34;&gt;프로그래밍 언어의 구문 BNF, EBNF, 파.. : 네이버블로그 (naver.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/bestowing/221769416451&#34;&gt;오토마타 이론 공부 (11) - 파스 트리(P.. : 네이버블로그 (naver.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aistudy.com/linguistics/BNF.htm&#34;&gt;BNF : Backus Naur Form (aistudy.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.aistudy.com/linguistics/context_free_grammar.htm&#34;&gt;문맥 자유 문법 : Context Free Grammar (aistudy.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://web.donga.ac.kr/jwjo/Lectures/PL/chap4.pdf&#34;&gt;컴파일러 - 제4장 구문 (donga.ac.kr)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://contents.kocw.or.kr/KOCW/document/2014/deagucatholic/kimhangkon/3.pdf&#34;&gt;PowerPoint Template (kocw.or.kr)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://contents2.kocw.or.kr/KOCW/document/2016/keimyung/jangduksung/4.pdf&#34;&gt;1장 기본적인 사항 (kocw.or.kr)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어휘 분석 및 구문 분석
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tinman.cs.gsu.edu/~raj/4330/slides/c04.pdf&#34;&gt;Programming Language Concepts - 4. LEXICAL AND SYNTAX ANALYSIS (gsu.edu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://web.cs.ucdavis.edu/~pandey/Teaching/ECS142/Lects/syntax.pdf&#34;&gt;ECS 142: Compilers - Syntactic Analysis (ucdavis.edu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cs.mtsu.edu/~zdong/3210/OldSlides/SyntaxAnalyzerIntroduction.pdf&#34;&gt;Introduction to Syntax Analysis - CSCI4160: Compiler Design and Software Development (mtsu.edu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://courses.cs.washington.edu/courses/cse401/06sp/syn.pdf&#34;&gt;CSE401: Introduction to Compiler Construction - Syntactic Analysis (washington.edu)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/compiler_design/compiler_design_syntax_analysis.htm&#34;&gt;Compiler Design - Syntax Analysis (tutorialspoint.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.coursera.org/articles/lexical-analysis&#34;&gt;What Is Lexical Analysis? | Coursera&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Lexical_analysis&#34;&gt;Lexical analysis - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/introduction-of-lexical-analysis/&#34;&gt;Introduction of Lexical Analysis - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;추상 구문 트리(AST)
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.to/shreyvijayvargiya/what-is-an-abstract-syntax-tree-in-programming-1nae&#34;&gt;What is an Abstract Syntax Tree in Programming? - DEV Community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.to/balapriya/abstract-syntax-tree-ast-explained-in-plain-english-1h38&#34;&gt;Abstract Syntax Tree (AST) - Explained in Plain English - DEV Community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itnext.io/ast-for-javascript-developers-3e79aeb08343&#34;&gt;AST for JavaScript developers. TL;DR This article is my talk for… | by Bohdan Liashenko | ITNEXT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://astexplorer.net/&#34;&gt;AST explorer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AST를 이해하는데 유용한 영상
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=wINY109MG10&#34;&gt;What Is An Abstract Syntax Tree, With WealthFront Engineer Spencer Miskoviak (youtube.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Javascript] Scope 알아보기 (w. 일반 프로그래밍에서의 Scope)</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/scope/</link>
      <pubDate>Thu, 18 Jul 2024 12:10:45 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/scope/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 7월 16일 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/6_Scope/Readme.md&#34;&gt;&lt;strong&gt;자바스크립트의 Scope&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;스코프&#34; &gt;스코프?
&lt;span&gt;
    &lt;a href=&#34;#%ec%8a%a4%ec%bd%94%ed%94%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;프로그래밍에서 &lt;code&gt;스코프&lt;/code&gt;란, 프로그램의 요소들(변수 및 상수, 함수 등)이 유효한 영역을 말합니다. 또한, &lt;code&gt;스코프&lt;/code&gt;는 프로그램의 부분 또는 특정 지점에서 유효한 모든 &lt;code&gt;이름 바인딩&lt;/code&gt; 집합을 가리키는 데에도 사용되며, 이때 &lt;code&gt;컨텍스트&lt;/code&gt; 또는 &lt;code&gt;환경(Environment)&lt;/code&gt; 라고도 일컬어집니다.&lt;br&gt;
스코프 개념에 따라 프로그램에서 영역을 벗어난 변수는 가리킬 수 없고, 영역 내부의 요소들은 바인딩 된 &lt;code&gt;이름(identifier)&lt;/code&gt;을 통해 가리킬 수 있게 됩니다.&lt;br&gt;
이는 스코프가 &lt;em&gt;프로그램의 다른 부분에 존재하는 변수&lt;/em&gt;를 &lt;strong&gt;서로 구분&lt;/strong&gt;하기 위해 등장했기 때문입니다.&lt;br&gt;
스코프 개념은 1960년 등장한 &lt;a href=&#34;https://www.algol60.org/&#34;&gt;알골 60(ALGOL 60)&lt;/a&gt;에서 처음 등장했으며, &lt;code&gt;블록&lt;/code&gt;이라는 영역 단위를 통해 변수의 스코프를 지정했습니다.&lt;/p&gt;
&lt;h3 id=&#34;스코프의-종류&#34; &gt;스코프의 종류
&lt;span&gt;
    &lt;a href=&#34;#%ec%8a%a4%ec%bd%94%ed%94%84%ec%9d%98-%ec%a2%85%eb%a5%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;스코프는 &lt;em&gt;어디에서 변수를 참조하느냐&lt;/em&gt;에 따라 &lt;code&gt;정적 범위(Static Scope)&lt;/code&gt;와 &lt;code&gt;동적 범위(Dynamic Scope)&lt;/code&gt; 두 가지로 나뉩니다.&lt;br&gt;
C, C++, Java와 같은 대부분의 현대 언어들은 &lt;code&gt;정적 범위&lt;/code&gt; 방식을 채택하고 있으며, &lt;code&gt;LISP&lt;/code&gt;, &lt;code&gt;TeX&lt;/code&gt;등의 스크립팅 언어에서는 &lt;code&gt;동적 범위&lt;/code&gt; 방식을 채택하기도 합니다.&lt;/p&gt;
&lt;h4 id=&#34;정적-범위static-scope&#34; &gt;&lt;code&gt;정적 범위(Static Scope)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%ec%a0%81-%eb%b2%94%ec%9c%84static-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;정적 범위&lt;/code&gt;, 또는 &lt;code&gt;렉시컬 스코프(Lexical Scope)&lt;/code&gt;라고도 부르는 이 방식에서는 소스코드의 위치와, 변수 또는 함수가 정의된(선언된) 위치에 의해 정의된 &lt;code&gt;렉시컬 컨텍스트(또는 정적 컨텍스트)&lt;/code&gt;에 따라 참조가 정해집니다.&lt;br&gt;
이름을 탐색할 때, 먼저 로컬 &lt;code&gt;렉시컬 컨텍스트&lt;/code&gt;를 검색하고, 실패하면 외부 &lt;code&gt;렉시컬 컨텍스트&lt;/code&gt;로 점차 검색해나가는 식으로 탐색을 진행합니다.&lt;br&gt;
주로 &lt;code&gt;블록&lt;/code&gt; 단위로 묶어 스코프를 정의합니다. 따라서 &lt;em&gt;블록 내부에서 선언한 변수&lt;/em&gt;는 &lt;strong&gt;외부에서 보이지 않으며&lt;/strong&gt;, &lt;em&gt;블록 외부의 변수&lt;/em&gt;는 (&lt;em&gt;블록 내부에서 재정의하지 않는 한&lt;/em&gt;)&lt;strong&gt;블록 내부에서 볼 수 있습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;h5 id=&#34;예시&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// g()에 의해 호출 됨
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// g()는 스스로 x라는 내부 변수를 갖고 있으며,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// f()를 호출함
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;10&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;정적 범위&lt;/code&gt;에서는 컴파일러가 먼저 선언된 현재의 블록을 탐색하고, 이후 이를 감싸는 더 넓은 범위로 계속해서 탐색해 변수를 검색합니다.&lt;br&gt;
따라서 위 코드에서는 &lt;code&gt;g()&lt;/code&gt;가 호출한 &lt;code&gt;f()&lt;/code&gt;는 내부 -&amp;gt; 외부(전역)에서 x 값을 탐색하게 되고, &lt;code&gt;10&lt;/code&gt;을 출력하게 됩니다.&lt;/p&gt;
&lt;h4 id=&#34;동적-범위dynamic-scope&#34; &gt;&lt;code&gt;동적 범위(Dynamic Scope)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%a0%81-%eb%b2%94%ec%9c%84dynamic-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;동적 범위&lt;/code&gt; 방식에서는 실행 컨텍스트, 즉 함수 호출 순서에 따른 컨텍스트에 의해 참조가 정해지게 됩니다.&lt;br&gt;
이름을 탐색할 때, 먼저 &lt;code&gt;로컬 컨텍스트&lt;/code&gt;에서 검색하고, 찾지 못하면 호출 스택에서 변수 정의를 검색해나가는 식으로 탐색을 진행합니다.&lt;br&gt;
&lt;strong&gt;구현이 쉽지만&lt;/strong&gt;, &lt;em&gt;런타임에 어떤 변수에 접근할 수 있을지 알게되므로&lt;/em&gt; &lt;strong&gt;컴파일러가 최적화할 수 없어&lt;/strong&gt; &lt;code&gt;변수 조회 비용&lt;/code&gt;이 &lt;strong&gt;더 비싸고&lt;/strong&gt;, &lt;strong&gt;함수 호출 순서에 따라 다르게 동작&lt;/strong&gt;할 수 있다는 단점(때로는 장점)이 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-1&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// g()에 의해 호출 됨
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// g()는 스스로 x라는 내부 변수를 갖고 있으며,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// f()를 호출함
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;printf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;20&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;동적 범위&lt;/code&gt;에서는 먼저 현재 블록에서 변수를 검색한 뒤, 호출 스택의 함수들을 연속적으로 검색합니다.&lt;br&gt;
따라서 위 코드에서 &lt;code&gt;g()&lt;/code&gt;가 호출한 &lt;code&gt;f()&lt;/code&gt;는 내부(&lt;code&gt;f()&lt;/code&gt;) -&amp;gt; 이전 호출 함수(&lt;code&gt;g()&lt;/code&gt;) 에서 x 값을 탐색하게 되고, &lt;code&gt;g()&lt;/code&gt;에서 선언된 &lt;code&gt;20&lt;/code&gt;이란 값을 출력하게 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;javascript에서의-scope&#34; &gt;Javascript에서의 Scope
&lt;span&gt;
    &lt;a href=&#34;#javascript%ec%97%90%ec%84%9c%ec%9d%98-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;자바스크립트&lt;/code&gt;에서는 &lt;code&gt;전역 스코프&lt;/code&gt;, &lt;code&gt;모듈 스코프&lt;/code&gt;, &lt;code&gt;함수 스코프&lt;/code&gt;, 그리고 추가로 &lt;code&gt;블록 스코프&lt;/code&gt;까지 총 3가지의 스코 프가 존재합니다.&lt;/p&gt;
&lt;h4 id=&#34;전역-스코프global-scope&#34; &gt;&lt;code&gt;전역 스코프(Global Scope)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%84%ec%97%ad-%ec%8a%a4%ec%bd%94%ed%94%84global-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;스크립트 모드&lt;/code&gt;에서 실행되는 모든 코드들의 기본 범위.&lt;br&gt;
자바스크립트에서 &lt;em&gt;함수 영역 내부가 아닌&lt;/em&gt; &lt;strong&gt;전역에 선언&lt;/strong&gt;된 요소들은 모두 전역 스코프를 갖는 전역 변수로 취급됩니다. 또한 &lt;strong&gt;&lt;code&gt;var&lt;/code&gt; 키워드로 선언된 전역 변수&lt;/strong&gt;는 &lt;code&gt;전역 객체&lt;/code&gt;인 &lt;code&gt;window&lt;/code&gt;의 프로퍼티로 등록됩니다.&lt;br&gt;
그리고 &lt;em&gt;선언하지 않은 변수&lt;/em&gt;에 &lt;strong&gt;값을 할당&lt;/strong&gt;하려고 하면, 이는 자동적으로 &lt;code&gt;전역 변수&lt;/code&gt;가 됩니다. 이를 &lt;code&gt;암묵적 전역(implicit global)&lt;/code&gt;이라고 합니다. 참고로 &lt;code&gt;암묵적 전역&lt;/code&gt;은 &lt;code&gt;&amp;quot;strict mode&amp;quot;&lt;/code&gt; 에서 동작하지 않습니다.&lt;br&gt;
자바스크립트 프로그램 &lt;strong&gt;어디에서나 접근할 수 있다&lt;/strong&gt;는 장점이 존재하지만, 남발할 경우 &lt;code&gt;변수 이름이 중복&lt;/code&gt;될 수 있고, &lt;code&gt;재할당&lt;/code&gt;되거나 내부 스코프에 의해 외부 스코프 변수가 가려지는 &lt;code&gt;변수 섀도잉(Variable Shadowing)&lt;/code&gt;이 발생할 수 있다는 단점이 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-2&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-2&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;global_let&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 전역에 선언한 let 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;global_var&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 전역에 선언한 var 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inner_var&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 블록에 선언한 var 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;global_let&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;20&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;global_var&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;30&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;inner_var&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;40&amp;#34; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// var 키워드로 선언한 변수는 블록 스코프에 포함되지 않는다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myFunction&lt;/span&gt;();  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;carName&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;Volvo&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;myFunction&lt;/span&gt;() {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;carName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Volvo&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 선언하지 않은 변수에 값을 할당할 경우 자동적으로 전역 변수가 된다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;모듈-스코프module-scope&#34; &gt;&lt;code&gt;모듈 스코프(Module Scope)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%a8%eb%93%88-%ec%8a%a4%ec%bd%94%ed%94%84module-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;모듈 모드&lt;/code&gt;에서 실행되는 코드들의 범위.&lt;br&gt;
&lt;code&gt;전역 스코프&lt;/code&gt;와 달리, 모듈에서 &lt;em&gt;함수 영역 외부에 선언된&lt;/em&gt; &lt;code&gt;요소(변수, 함수 및 기타 코드)&lt;/code&gt;는 &lt;strong&gt;&lt;code&gt;명시적으로 내보내지(export)&lt;/code&gt; 않는 한&lt;/strong&gt;, &lt;strong&gt;숨겨져있으며&lt;/strong&gt; 다른 모듈에서 사용할 수 없습니다.&lt;br&gt;
그리고 모듈을 가져오게(&lt;code&gt;import()&lt;/code&gt;, &lt;code&gt;require()&lt;/code&gt; 등) 되면, &lt;code&gt;가져온 모듈&lt;/code&gt;은 이를 &lt;strong&gt;&lt;code&gt;가져온 코드의 스코프&lt;/code&gt; 내부에서만 사용&lt;/strong&gt;할 수 있습니다. 즉, 만약 함수 내부에서 모듈을 가져올 경우, 가져온 모듈은 해당 함수 내에서만 접근할 수 있고 함수 외부에서는 접근할 수 없습니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-3&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-3&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// in abc.js
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;var1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// in main.js
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./abc&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;var1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// ReferenceError: var1 is not defined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;함수-스코프function-scope&#34; &gt;&lt;code&gt;함수 스코프(Function Scope)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ed%95%a8%ec%88%98-%ec%8a%a4%ec%bd%94%ed%94%84function-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;함수로 생성된 범위.&lt;br&gt;
각각의 함수는 새로운 스코프를 생성하며, &lt;code&gt;함수의 매개변수&lt;/code&gt; 및 &lt;code&gt;함수 내부에서 정의된 변수&lt;/code&gt;는 &lt;strong&gt;&lt;code&gt;함수 외부&lt;/code&gt;에서 접근할 수 없습니다&lt;/strong&gt;. 이는 &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; 어떤 키워드로 선언했든 동일하게 적용됩니다.&lt;br&gt;
또한 &lt;code&gt;함수 내부에서 정의된 변수&lt;/code&gt;와 &lt;code&gt;외부의 변수&lt;/code&gt;의 이름이 동일해도 정상적으로 동작하며, 이때 해당 이름으로 접근하게 될 경우 &lt;code&gt;함수 내부에서 정의된 변수&lt;/code&gt;를 우선적으로 접근합니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-4&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;global_let&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 전역에 선언한 let 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;global_var&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 전역에 선언한 var 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func_var&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 함수에 선언한 let 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;global_var&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 함수에 선언한 var 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;global_let&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;20&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;global_var&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;40&amp;#34; &amp;lt;&amp;lt; 함수 내부에서 선언한 값을 우선
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;func_let&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// ReferenceError: func_var is not defined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;global_var&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;30&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;블록-스코프block-scope&#34; &gt;&lt;code&gt;블록 스코프(Block Scope)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%b8%94%eb%a1%9d-%ec%8a%a4%ec%bd%94%ed%94%84block-scope&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;중괄호 쌍(블록)으로 만들어진 범위.&lt;br&gt;
아무것도 없는 중괄호 쌍으로 만들어진 블록 또는 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt; 등의 블록 내부에서 선언된 변수를 해당 스코프에서만 사용 가능한 것을 말합니다.&lt;br&gt;
&lt;code&gt;ES6&lt;/code&gt;에서 등장했으며, 마찬가지로 &lt;code&gt;ES6&lt;/code&gt;에서 등장한 &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; 키워드로 선언된 변수들만 &lt;code&gt;블록 스코프&lt;/code&gt;를 적용 받습니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-5&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// ReferenceError: abc is not defined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 함수 스코프에 선언된 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 블록 스코프에 선언된 변수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 30
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;변수-섀도잉variable-shadowing&#34; &gt;&lt;code&gt;변수 섀도잉(Variable Shadowing)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%80%ec%88%98-%ec%84%80%eb%8f%84%ec%9e%89variable-shadowing&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;블록 스코프&lt;/code&gt;, 또는 &lt;code&gt;함수 스코프&lt;/code&gt;에서 발생가능한 현상으로, 동일한 이름을 갖는 내부 스코프의 변수와 외부 스코프의 변수를 접근할 경우 &lt;code&gt;내부 스코프&lt;/code&gt;의 값이 우선되는 것을 말합니다.&lt;br&gt;
참고로 &lt;code&gt;변수 섀도잉&lt;/code&gt;을 사용할 때, 외부-내부 변수들을 같은 유형으로 선언하는 것이 좋습니다. 특정 경우 충돌이 발생할 수 있기 때문입니다.&lt;br&gt;
아래 코드처럼, &lt;code&gt;var&lt;/code&gt;로 선언한 외부 변수를 &lt;code&gt;let&lt;/code&gt;으로 선언한 내부 변수로 가리는 것은 정상적 동작하지만, &lt;code&gt;let&lt;/code&gt;으로 선언한 외부 변수를 &lt;code&gt;var&lt;/code&gt;로 선언한 내부 변수로 가리려 하는 경우 &amp;ldquo;이미 정의된 변수&amp;quot;라는 오류가 발생하게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 정상 동작
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// SyntaxError: Identifier &amp;#39;y&amp;#39; has already been declared
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;X&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 에러 출력
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;호이스팅hoisting&#34; &gt;&lt;code&gt;호이스팅(Hoisting)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ed%98%b8%ec%9d%b4%ec%8a%a4%ed%8c%85hoisting&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// var 변수 호이스팅
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// undefined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 함수 호이스팅
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 함수를 이후에 선언해도, 앞에서 호출할 수 있다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;TEST&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TEST&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 다만, 함수를 변수에 할당한 경우, 선언-초기화가 분리되므로 함수 호출시 에러가 발생한다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// ReferenceError: func is not defined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TEST&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;자바스크립트의 &lt;code&gt;호이스팅&lt;/code&gt;이란, 인터프리터가 코드를 실행하기 전, &lt;code&gt;함수&lt;/code&gt;/&lt;code&gt;변수&lt;/code&gt;/&lt;code&gt;클래스&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; &lt;strong&gt;선언&lt;/strong&gt;을 &lt;code&gt;현재 스코프 맨 위&lt;/code&gt;로 이동시키는 과정을 말합니다.&lt;br&gt;
&lt;strong&gt;&lt;code&gt;선언&lt;/code&gt;&lt;/strong&gt; 만 끌어올린다는 것을 유의해야 하는데, &lt;code&gt;초기화(값 할당)&lt;/code&gt;은 위로 끌어올려지지 않기 때문입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// ReferenceError: Cannot access &amp;#39;x&amp;#39; before initialization
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 정상 케이스
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// const는 애초에 선언시 함께 초기화가 이뤄져야 하므로 에러 발생
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Test&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// SyntaxError: Missing initializer in const declaration
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;또한, &lt;code&gt;let&lt;/code&gt;과 &lt;code&gt;const&lt;/code&gt;로 선언한 요소 및 &lt;code&gt;클래스&lt;/code&gt;의 경우 &lt;code&gt;호이스팅&lt;/code&gt;되긴 하지만, 선언 이전에 이 값들을 초기화할 수 없습니다.&lt;br&gt;
블록의 시작부터 이들이 선언 및 초기화가 된 위치에 도달하기 전까지의 구간을 &lt;strong&gt;&lt;code&gt;일시적 데드 존(Temporal dead zone, TDZ)&lt;/code&gt;&lt;/strong&gt; 이라고 하며, 해당 구간에서 변수에 접근하는 것을 엄격히 금하고 있습니다.&lt;/p&gt;
&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Scope_(computer_science)#Expression_scope&#34;&gt;Scope (computer science) - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://courses.cs.washington.edu/courses/cse341/03wi/imperative/scoping.html&#34;&gt;CSE 341 Lecture Notes &amp;ndash; Static and Dynamic Scoping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cs.cornell.edu/courses/cs6110/2017sp/lectures/lec12.pdf&#34;&gt;CS 6110 S17 Lecture 12 Static vs Dynamic Scope - lec12.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/static-and-dynamic-scoping/&#34;&gt;Static and Dynamic Scoping - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.showwcase.com/article/27294/module-scope&#34;&gt;Module Scope | Showwcase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/an-introduction-to-scope-in-javascript-cbd957022652/&#34;&gt;An introduction to scope in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/variable-shadowing-in-javascript/&#34;&gt;Variable Shadowing in JavaScript - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.showwcase.com/article/27294/module-scope&#34;&gt;Module Scope | Showwcase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/an-introduction-to-scope-in-javascript-cbd957022652/&#34;&gt;An introduction to scope in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Javascript] Prototype 알아보기 (w. 왜 JS는 Prototype을 채택했나?)</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/prototype/</link>
      <pubDate>Thu, 18 Jul 2024 11:47:14 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/prototype/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 7월 9일 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/5_Prototype/Readme.md&#34;&gt;&lt;strong&gt;Prototype&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;prototype-in-javascript&#34; &gt;&lt;code&gt;prototype&lt;/code&gt; in Javascript
&lt;span&gt;
    &lt;a href=&#34;#prototype-in-javascript&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;객체지향 프로그래밍 언어들에서 기존 코드를 확장하는 방식 중 대표적인 방식으로 &lt;code&gt;상속(Inheritance)&lt;/code&gt;이 있습니다.&lt;br&gt;
자바스크립트에서는 이러한 상속을 &lt;code&gt;객체&lt;/code&gt;를 사용해 구현합니다.&lt;/p&gt;
&lt;h3 id=&#34;프로토타입-체인&#34; &gt;프로토타입 체인
&lt;span&gt;
    &lt;a href=&#34;#%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85-%ec%b2%b4%ec%9d%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;각 객체들은 &lt;strong&gt;&lt;code&gt;프로토타입(prototype)&lt;/code&gt;&lt;/strong&gt; 이라는 다른 객체에 대한 내부적인 링크를 갖고 있습니다. 그리고 그 &lt;code&gt;프로토타입&lt;/code&gt; 객체는 또 다른 자체 &lt;code&gt;프로토타입&lt;/code&gt;을 가지며, &lt;code&gt;프로토타입 체인&lt;/code&gt;이라 부르는 이러한 연결은 &lt;code&gt;null&lt;/code&gt;을 &lt;code&gt;프로토타입&lt;/code&gt;으로 가지는 객체에 도달할 때 까지 계속됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 &lt;code&gt;null&lt;/code&gt;은 &lt;code&gt;프로토타입 체인&lt;/code&gt;의 최종 링크 역할을 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;프로토타입 체인&lt;/code&gt;을 이루는 객체 중 어떤 멤버든 변경할 수 있으며, &lt;code&gt;런타임&lt;/code&gt;에 &lt;strong&gt;프로토타입을 교체&lt;/strong&gt;하는 것이 가능하므로 &lt;code&gt;정적 디스패치(static dispatching)&lt;/code&gt;와 같은 개념은 자바스크립트에 &lt;strong&gt;존재하지 않습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;정적 디스패치(static dispatch)&lt;/code&gt;: 다형성의 구현 방식 중 하나로, &lt;strong&gt;&lt;code&gt;컴파일 시간&lt;/code&gt;&lt;/strong&gt; 에 어떤 메서드나 함수의 구현을 사용할 지 선택하는 방법입니다. 이에 대응되는 개념으로는 &lt;code&gt;런타임 시간&lt;/code&gt;에 이를 결정하는 &lt;code&gt;동적 디스패치(dynamic dispatch)&lt;/code&gt;가 있습니다.
&lt;ul&gt;
&lt;li&gt;C++의 &lt;code&gt;template&lt;/code&gt;이 이러한 예이며, Rust 역시 아래와 같은 코드가 있다고 할때, &lt;code&gt;컴파일러&lt;/code&gt;가 전달된 인자의 타입을 보고, 그에 맞는 코드를 따로 실행하게 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// rust의 trait은 타입 간의 공통된 사항들을 정의합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// (Java의 Interface와 유사하지만 더 강력한 개념)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 예를 들어, 아래 Speak이라는 trait을 가지는 타입은 반드시 speak 함수를 가져야 합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; Speak {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;speak&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Cat&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Cat 타입에 Speak trait을 붙이는 코드입니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Speak &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; Cat {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Speak trait에 포함된 &amp;#39;speak&amp;#39; 함수를 구현해야 합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;speak&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        println!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Meow!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Speak trait을 갖는 타입을 인자로 받는 함수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;talk&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T: &lt;span style=&#34;color:#a6e22e&#34;&gt;Speak&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(pet: &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pet.speak();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pet &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Cat;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    talk(pet);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;코드 출처: &lt;a href=&#34;https://en.wikipedia.org/wiki/Static_dispatch&#34;&gt;Static dispatch - Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;프로퍼티-상속하기&#34; &gt;프로퍼티 상속하기
&lt;span&gt;
    &lt;a href=&#34;#%ed%94%84%eb%a1%9c%ed%8d%bc%ed%8b%b0-%ec%83%81%ec%86%8d%ed%95%98%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;자바스크립트의 객체는 자유롭게 &lt;code&gt;프로퍼티&lt;/code&gt;를 추가 및 제거할 수 있는, &lt;code&gt;property&lt;/code&gt;로 이뤄진 &lt;code&gt;동적인 가방&lt;/code&gt;이라고 할 수 있습니다.&lt;br&gt;
객체에서 &lt;code&gt;프로퍼티&lt;/code&gt;를 탐색할 때는 &lt;code&gt;현재 객체가 가진 프로퍼티(own property)&lt;/code&gt; 뿐만 아니라, &lt;code&gt;프로토타입 체인&lt;/code&gt;의 끝까지 탐색하며 이를 구성하는 &lt;code&gt;프로토타입&lt;/code&gt;들에서도 찾는 형태로 동작합니다.&lt;br&gt;
다음 코드는 후술할 &lt;strong&gt;프로토타입 접근 및 설정 방법&lt;/strong&gt; 중 대표적인 방식인 &lt;code&gt;obj.__proto__&lt;/code&gt; 구문을 통해 객체의 &lt;code&gt;프로토타입&lt;/code&gt;을 설정하고, &lt;code&gt;프로토타입 체인&lt;/code&gt;을 이루는 코드입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// __proto__ 프로퍼티를 통해 프로토타입을 설정합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 이때, 다른 객체 변수명을 할당하거나, 객체 리터럴을 할당할 수 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 이렇게 되면, 객체 o를 이루는 프로토타입 체인은 다음과 같습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// { a: 1, b: 2 } ---&amp;gt; { b: 3, c: 4 } ---&amp;gt; { d: 5 } ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o에는 내부 프로퍼티인 a가 존재하므로 해당 값을 가져옵니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o와 o의 프로토타입 모두 b를 가지고 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 이러한 경우, 프로토타입 체인에서 더 가까운 위치에 존재하는 프로퍼티를 우선합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 즉, 여기서는 o의 내부 프로퍼티 b의 값인 2를 가져옵니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 이처럼 프로토타입 체인 상에서 동일한 이름의 프로퍼티가 존재할 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 프로토타입 체인에서 더 가까운 프로퍼티를 찾으면 이후 프토토타입들을 더 탐색하지 않는 것을
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 프로퍼티 섀도잉(Property Shadowing)이라고 합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o에는 c 프로퍼티가 없기 때문에, 프로토타입 체인을 탐색합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o.[[prototype]]에 c가 존재하기 때문에, 해당 값인 4를 가져옵니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// undefined
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o에는 e 프로퍼티가 없기 때문에, 프로토타입 체인을 탐색합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o.[[prototype]]을 탐색하나, 이 역시 e 프로퍼티가 없습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o.[[prototype]].[[prototype]]을 탐색하나, 이 역시 e 프로퍼티가 없습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// o.[[prototype]].[[prototype]].[[prototype]], 즉 Object.prototype을 탐색하나, 이 역시 e 프로퍼티가 없습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Object.prototype의 프로토타입은 null이므로, 프로토타입 체인 탐색을 종료합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 프로퍼티를 찾지 못했기 때문에, undefined를 반환합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 구조를 그림으로 표현하면 아래와 같습니다.&lt;br&gt;
&lt;img src=&#34;example-prototype.png&#34; alt=&#34;example-prototype&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;메서드-상속하기&#34; &gt;메서드 상속하기
&lt;span&gt;
    &lt;a href=&#34;#%eb%a9%94%ec%84%9c%eb%93%9c-%ec%83%81%ec%86%8d%ed%95%98%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;자바스크립트에서는 클래스-기반 언어들에 존재하는 &lt;em&gt;&lt;code&gt;메서드&lt;/code&gt;라는 개념이 존재하지 않으며&lt;/em&gt;, 대신 &lt;code&gt;프로퍼티 형태&lt;/code&gt;로 객체에 &lt;strong&gt;함수를 추가&lt;/strong&gt;할 수 있습니다.&lt;br&gt;
이와 같은 방식으로 상속한 함수는 상기한 프로퍼티들의 동작방식 대로 동작하며, 마찬가지로 &lt;code&gt;프로퍼티 섀도잉&lt;/code&gt;이 이뤄집니다.&lt;br&gt;
유의할 점은, 상속된 함수가 실행될 경우 해당 함수 내부의 &lt;code&gt;this&lt;/code&gt; 값은 &lt;code&gt;해당 함수를 지닌 프로토타입 객체&lt;/code&gt;가 아닌 &lt;strong&gt;&lt;code&gt;함수를 상속받은 객체&lt;/code&gt;&lt;/strong&gt; 를 가리킵니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;child&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;child&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// child.add() 를 호출한 순간, 프로토타입 체인을 탐색하며 add 함수를 찾습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 그리고 add 함수 내부의 this는 child를 가리키게 됩니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 이때, child는 value 프로퍼티를 갖고있지 않기 때문에, 프로토타입 체인을 탐색하며 value 프로터피를 찾습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 그리고 parent의 value 프로퍼티 값인 3을 가져와 1을 더하고, this.value에 할당합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 따라서 child 역시 내부 프로퍼티인 value를 갖게되며, 이 값은 4가 됩니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/ { value: 4,  __proto__: { value: 3, add: [Function] } }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;child&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 앞선 child.add()로 child 역시 value 프로퍼티를 갖게 되었으므로 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// child.value가 parent.value를 가리게되고(프로퍼티 섀도잉), 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// child.value 값인 4에 1을 더한 5를 반환합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;생성자-함수constructor&#34; &gt;&lt;code&gt;생성자 함수(Constructor)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%83%9d%ec%84%b1%ec%9e%90-%ed%95%a8%ec%88%98constructor&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;프로토타입을-활용한-생성자-함수-개선&#34; &gt;프로토타입을 활용한 생성자 함수 개선
&lt;span&gt;
    &lt;a href=&#34;#%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85%ec%9d%84-%ed%99%9c%ec%9a%a9%ed%95%9c-%ec%83%9d%ec%84%b1%ec%9e%90-%ed%95%a8%ec%88%98-%ea%b0%9c%ec%84%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;또한 &lt;code&gt;프로토타입&lt;/code&gt;은 객체를 생성하는 &lt;code&gt;생성자 함수&lt;/code&gt;에서, 함수를 통해 생성된 인스턴스들이 가지는 프로퍼티를 지정하는데 사용할 수 있습니다.&lt;br&gt;
&lt;code&gt;value&lt;/code&gt;라는 값과 &lt;code&gt;method&lt;/code&gt;라는 함수를 가지는 객체 여럿을 생성해야 한다고 합시다.
단순히 구현한다면 다음과 같이 구현할 수도 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;; } },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;; } },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;() { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;; } },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이는 각 인스턴스 마다 동일한 작업을 수행하는 자체 함수 프로퍼티가 있는 형태로, 함수들이 중복되고 불필요한 형태입니다.&lt;br&gt;
&lt;code&gt;method&lt;/code&gt; 함수를 &lt;code&gt;프로토타입&lt;/code&gt;으로 옮긴다면 어떨까요?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxPrototype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxPrototype&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxPrototype&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxPrototype&lt;/span&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이젠 모든 Box들이 똑같은 함수를 참조하므로, 중복이 없어지고 메모리를 덜 사용할 것입니다.
하지만 Box를 생성할 때 마다 &lt;code&gt;__proto__&lt;/code&gt;를 직접 지정한다는 불편함은 계속 존재합니다.&lt;br&gt;
이럴때, 생성자 함수를 만들고 해당 함수의 &lt;code&gt;프로토타입&lt;/code&gt;에 &lt;code&gt;method&lt;/code&gt; 함수를 추가한다면 더 간단화시킬 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 생성자 함수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//Box() 생성자로 생성된 인스턴스들은 다음 프로퍼티를 갖습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boxes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)];
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;생성자 함수로 생성된 모든 인스턴스&lt;/code&gt;들은 자동으로 &lt;code&gt;생성자 함수&lt;/code&gt;의 &lt;code&gt;prototype&lt;/code&gt; 프로퍼티를 &lt;code&gt;프로토타입&lt;/code&gt;으로 갖습니다. 따라서 &lt;code&gt;프로토타입&lt;/code&gt;에 존재하는 &lt;code&gt;프로퍼티&lt;/code&gt;들을 공유하게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;box&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 인스턴스들이 생성 된 후에도 Box.prototype를 수정해 동작을 변경할 수 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getValue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;method&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;추가로 &lt;code&gt;Constructor.prototype&lt;/code&gt;(&lt;code&gt;Constructor&lt;/code&gt;는 생성자 함수, 여기서는 &lt;code&gt;Box&lt;/code&gt;)는 모든 인스턴스들의 &lt;code&gt;prototype&lt;/code&gt;과 동일한 객체를 참조하므로, &lt;code&gt;Constructor.prototype&lt;/code&gt;을 수정해 해당 &lt;strong&gt;인스턴스들의 동작을 변경&lt;/strong&gt;할 수도 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다만 이러한 행위를 할 경우, &lt;code&gt;재할당 이전에 생성된 인스턴스들의 프로토타입&lt;/code&gt;과 &lt;code&gt;재할당 이후에 생성된 인스턴스들의 프로토타입&lt;/code&gt;이 다른 객체를 가리키게 되고, &lt;code&gt;constructor&lt;/code&gt; 프로퍼티를 명시적으로 재설정하지 않을 경우 인스턴스에서 이를 추적할 수 없게 되는 단점이 있어 &lt;strong&gt;권장되지 않습니다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;constructor&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ƒ Box(value) {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//   this.value = value;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;getOwnPropertyNames&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// (2) [&amp;#39;constructor&amp;#39;, &amp;#39;method&amp;#39;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;그리고 &lt;code&gt;Constructor.prototype&lt;/code&gt;에는 생성자 함수 자체를 참조하는 &lt;code&gt;constructor&lt;/code&gt;라는 프로퍼티가 존재합니다.&lt;br&gt;
이를 통해 해당 생성자 함수로 생성된 모든 인스턴스에서 원래 생성자 함수를 접근할 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;주의사항&#34; &gt;주의사항
&lt;span&gt;
    &lt;a href=&#34;#%ec%a3%bc%ec%9d%98%ec%82%ac%ed%95%ad&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WrongBox&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;WrongBox&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;method1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;WrongBox&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;method2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;abcd&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WrongBox&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;abcd&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;method1&lt;/span&gt;(); &lt;span style=&#34;color:#75715e&#34;&gt;// TypeError: abcd.method1 is not a function
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;추가로, &lt;code&gt;생성자 함수&lt;/code&gt;가 &lt;code&gt;원시 타입이 아닌 값&lt;/code&gt;을 반환할 경우, 해당 값이 &lt;code&gt;new&lt;/code&gt; 표현식의 결과가 됩니다.&lt;br&gt;
따라서 이러한 경우 &lt;code&gt;prototype&lt;/code&gt;이 올바르게 바인딩 되지 않을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;리터럴의-암시적-생성자&#34; &gt;리터럴의 암시적 생성자
&lt;span&gt;
    &lt;a href=&#34;#%eb%a6%ac%ed%84%b0%eb%9f%b4%ec%9d%98-%ec%95%94%ec%8b%9c%ec%a0%81-%ec%83%9d%ec%84%b1%ec%9e%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;자바스크립트에서 몇몇 리터럴 구문은 인스턴스의 &lt;code&gt;prototype&lt;/code&gt;을 암시적으로 설정해 생성합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 객체 리터럴(`__proto__` 프로퍼티를 기입하지 않은)은 자동으로 `Object.prototype`을 프로토타입으로 갖습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;object&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 배열 리터럴은 자동으로 `Array.prototype`을 프로토타입으로 갖습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;array&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;array&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; Array.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 정규식 리터럴은 자동으로 `RegExp.prototype`을 프로토타입으로 갖습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;regexp&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/abc/&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;regexp&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; RegExp.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// true
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;추가로, 일부 빌트-인 생성자의 &lt;code&gt;prototype&lt;/code&gt; 프로퍼티는 그들 스스로의 인스턴스를 가리킵니다.
예를 들어 &lt;code&gt;Number.prototype&lt;/code&gt;는 숫자 0을, &lt;code&gt;Array.prototype&lt;/code&gt;은 빈 배열을, &lt;code&gt;RegExp.prototype&lt;/code&gt;은 &lt;code&gt;/(?:)/&lt;/code&gt;을 가리킵니다.&lt;/p&gt;
&lt;h4 id=&#34;생성자-함수의-프로토타입-체인&#34; &gt;생성자 함수의 프로토타입 체인
&lt;span&gt;
    &lt;a href=&#34;#%ec%83%9d%ec%84%b1%ec%9e%90-%ed%95%a8%ec%88%98%ec%9d%98-%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85-%ec%b2%b4%ec%9d%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;생성자 함수로 생성된 인스턴스는 &lt;code&gt;Constructor.prototype&lt;/code&gt;을 프로토타입으로 갖고, &lt;code&gt;Constructor.prototype&lt;/code&gt;은 순수 객체이므로 다음과 같은 &lt;code&gt;프로토타입 체인&lt;/code&gt;을 구성하게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Constructor&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Constructor&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// obj ---&amp;gt; Constructor.prototype ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;만약 &lt;code&gt;Constructor&lt;/code&gt; 함수의 프로토타입으로 다른 함수의 프로토타입을 연결한다면, 프로토타입 체인은 더 길어집니다. 이는 Class에서의 &lt;code&gt;extends&lt;/code&gt; 구문와 유사합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Constructor&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Extender&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;setPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;Constructor&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;Extender&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Constructor&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// obj ---&amp;gt; Constructor.prototype ---&amp;gt; Extender.prototype ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;프로토타입-접근-및-설정&#34; &gt;프로토타입 접근 및 설정
&lt;span&gt;
    &lt;a href=&#34;#%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85-%ec%a0%91%ea%b7%bc-%eb%b0%8f-%ec%84%a4%ec%a0%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;구문-생성자을-통한-객체-생성&#34; &gt;구문 생성자을 통한 객체 생성
&lt;span&gt;
    &lt;a href=&#34;#%ea%b5%ac%eb%ac%b8-%ec%83%9d%ec%84%b1%ec%9e%90%ec%9d%84-%ed%86%b5%ed%95%9c-%ea%b0%9d%ec%b2%b4-%ec%83%9d%ec%84%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 위처럼 객체 리터럴 이니셜라이저에서 __proto__ 프로퍼티를 통해 프로토타입을 지정하는 방식이
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// `Object.prototype.__proto__` 을 사용하는 것보다 표준화 및 최적화 되어있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;중괄호(&lt;code&gt;{}&lt;/code&gt;)로 묶인 &lt;code&gt;프로퍼티 이름-값 쌍&lt;/code&gt; 목록인 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer&#34;&gt;객체 이니셜라이저&lt;/a&gt;에서 &lt;code&gt;__proto__&lt;/code&gt; 프로퍼티를 통해 프로토타입을 지정하는 방식입니다.&lt;br&gt;
이때 &lt;code&gt;__proto__&lt;/code&gt; 프로퍼티가 객체가 아닌 값을 가리킬 경우 별도의 &lt;code&gt;Exception&lt;/code&gt; 없이 프로토타입 연결에 실패합니다.&lt;/p&gt;
&lt;h4 id=&#34;생성자-함수를-통한-객체-생성&#34; &gt;생성자 함수를 통한 객체 생성
&lt;span&gt;
    &lt;a href=&#34;#%ec%83%9d%ec%84%b1%ec%9e%90-%ed%95%a8%ec%88%98%eb%a5%bc-%ed%86%b5%ed%95%9c-%ea%b0%9d%ec%b2%b4-%ec%83%9d%ec%84%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Graph&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;vertices&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;edges&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Graph&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addVertex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;vertices&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;g&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Graph&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;생성자 함수는 초기 자바스크립트부터 사용되었기 때문에 표준적이고, JIT 최적화가 가능하다는 장점이 있습니다.&lt;br&gt;
하지만, 이 방식으로 추가된 메서드는 &lt;code&gt;열거 가능(enumerable)&lt;/code&gt;하므로 클래스 구문 또는 빌트-인 메서드의 동작 방식과 일치하지 않아 정상 동작하지 않을 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;objectcreate를-통한-객체&#34; &gt;&lt;code&gt;Object.create()&lt;/code&gt;를 통한 객체
&lt;span&gt;
    &lt;a href=&#34;#objectcreate%eb%a5%bc-%ed%86%b5%ed%95%9c-%ea%b0%9d%ec%b2%b4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// a ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 1 (상속된 값)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// c ---&amp;gt; b ---&amp;gt; a ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;abc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Object.create()&lt;/code&gt; 함수를 통해 객체를 생성할 경우, 해당 함수에 &lt;code&gt;첫 번째로 넘겨진 인수&lt;/code&gt;가 &lt;code&gt;생성된 객체의 프로토타입&lt;/code&gt;으로 지정됩니다.&lt;br&gt;
참고로 &lt;code&gt;두 번째 인자&lt;/code&gt;를 사용하면 생성될 새로운 객체의 각 속성 값을 정확히 지정할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이는 &lt;code&gt;객체 리터럴&lt;/code&gt;에서 불가능한 &lt;code&gt;열거할 수 없는 프로퍼티&lt;/code&gt; 생성을 할 수 있지만, &lt;code&gt;객체 리터럴&lt;/code&gt;보다 오류가 발생하기 쉽고 느릴 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;클래스를-통한-객체-생성&#34; &gt;클래스를 통한 객체 생성
&lt;span&gt;
    &lt;a href=&#34;#%ed%81%b4%eb%9e%98%ec%8a%a4%eb%a5%bc-%ed%86%b5%ed%95%9c-%ea%b0%9d%ec%b2%b4-%ec%83%9d%ec%84%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Rectangle&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;constructor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Rectangle&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FilledRectangle&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Rectangle&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;constructor&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;height&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;width&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Filled rectangle&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;color&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;filledRectangle&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FilledRectangle&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;blue&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// filledRectangle ---&amp;gt; FilledRectangle.prototype ---&amp;gt; Rectangle.prototype ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;높은 가독성과 유지보수성을 제공하는 클래스 구조는 프로토타입 상속에서는 존재하지 않는 &lt;code&gt;개인 속성(Private property)&lt;/code&gt;을 갖고 있지만, &lt;code&gt;전통적인 생성자 함수&lt;/code&gt;에 비해 &lt;strong&gt;덜 최적화&lt;/strong&gt; 되어있고 &lt;strong&gt;ES6에 이르러서야 등장&lt;/strong&gt;했기 때문에 &lt;strong&gt;이전 환경과 호환되지 않을 수 있습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;개인 속성(Private property)&lt;/code&gt;: 접두어 &lt;code&gt;#&lt;/code&gt;로 시작하는 프로퍼티로, 클래스 외부에서 합법적으로 참조할 수 없는 프로퍼티입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;objectsetgetprototypeof를-사용한-프로토타입-지정-및-접근&#34; &gt;&lt;code&gt;Object.set/getPrototypeOf()&lt;/code&gt;를 사용한 프로토타입 지정 및 접근
&lt;span&gt;
    &lt;a href=&#34;#objectsetgetprototypeof%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%9c-%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85-%ec%a7%80%ec%a0%95-%eb%b0%8f-%ec%a0%91%ea%b7%bc&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;anotherObj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// obj의 프로토타입을 anotherObj로 설정
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;setPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;anotherObj&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// obj ---&amp;gt; anotherObj ---&amp;gt; Object.prototype ---&amp;gt; null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;getPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;anotherObj&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;// {b: 2} &amp;lt;&amp;lt; anotherObj
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Object&lt;/code&gt;에 존재하는 정적 메서드인 &lt;code&gt;setPrototypeOf(obj, prototype)&lt;/code&gt; 함수와 &lt;code&gt;getPrototypeOf(obj)&lt;/code&gt; 함수를 통해 특정 객체의 프로토타입을 설정하거나, 가져올 수 있습니다.&lt;br&gt;
대부분의 JS 엔진은 &lt;code&gt;프로토타입&lt;/code&gt;을 &lt;strong&gt;동적으로 수정&lt;/strong&gt;시 &lt;code&gt;프로토타입 체인&lt;/code&gt;에 적용된 최적화가 중단될 수 있기 때문에, 가능한 생성 중에 프로토타입을 설정하는 것이 좋습니다.&lt;/p&gt;
&lt;h4 id=&#34;__proto__-접근자를-사용한-프로토타입-지정-및-접근&#34; &gt;&lt;code&gt;__proto__&lt;/code&gt; 접근자를 사용한 프로토타입 지정 및 접근
&lt;span&gt;
    &lt;a href=&#34;#__proto__-%ec%a0%91%ea%b7%bc%ec%9e%90%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%9c-%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85-%ec%a7%80%ec%a0%95-%eb%b0%8f-%ec%a0%91%ea%b7%bc&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;주의: &lt;code&gt;Object.prototype.__proto__&lt;/code&gt;는 &lt;strong&gt;표준이 아니며&lt;/strong&gt;, 많은 JS 엔진에서 구현하고 있긴 하지만 &lt;strong&gt;Deprecated&lt;/strong&gt; 되어있으므로 &lt;code&gt;setPrototypeOf&lt;/code&gt; 또는 &lt;code&gt;getPrototypeOf&lt;/code&gt;를 사용하는 것이 권장됩니다. &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto&#34;&gt;#&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;barProp&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bar val&amp;#34;&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// {barProp: &amp;#39;bar val&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;성능-관련&#34; &gt;성능 관련
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%b1%eb%8a%a5-%ea%b4%80%eb%a0%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;프로퍼티 순회 및 조회시 다음과 같이 동작하기 때문에, 성능을 고려해 코드를 작성하는게 좋습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;존재하지 않는 프로퍼티에 접근하려 하면 항상 &lt;code&gt;프로토타입 체인&lt;/code&gt; 전체를 순회하게 됩니다.&lt;/li&gt;
&lt;li&gt;객체의 프로퍼티들을 순회할 때, 모든 &lt;code&gt;열거 가능한 프로퍼티&lt;/code&gt;들이 열거됩니다.&lt;/li&gt;
&lt;li&gt;프로퍼티를 &lt;code&gt;전체 프로토타입 체인&lt;/code&gt;이 아닌, &lt;code&gt;자체 프로퍼티&lt;/code&gt;에서 찾고 싶다면 &lt;code&gt;Object.hasOwn()&lt;/code&gt; 메서드를 사용해야 합니다.(&lt;code&gt;Object.prototype.hasOwnProperty&lt;/code&gt; 가 아닌)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt;이 프로토타입으로 지정되어 있지 않고, 프로토타입 체인 아래로 재정의되지 않은 경우, 모든 객체는 &lt;code&gt;Object.prototype&lt;/code&gt;의 &lt;code&gt;hasOwnProperty()&lt;/code&gt;를 상속받습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;class와-prototype&#34; &gt;&lt;code&gt;class&lt;/code&gt;와 &lt;code&gt;prototype&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#class%ec%99%80-prototype&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;자바스크립트에서 &lt;code&gt;클래스&lt;/code&gt;가 구현되는 방식 역시 &lt;code&gt;프로토타입 모델&lt;/code&gt;을 기반으로 하고 있으며, &lt;code&gt;클래스&lt;/code&gt;는 &lt;code&gt;프로토타입&lt;/code&gt;을 추상화합니다.&lt;br&gt;
즉, 기존에 존재하는 프로토타입-기반 상속의 &lt;code&gt;문법적 설탕(Syntactical Sugar)&lt;/code&gt;이라고 할 수 있습니다. 다만, &lt;code&gt;클래스에서만 사용할 수 있는&lt;/code&gt; 구문도 존재하는데, &lt;code&gt;static 프로퍼티 및 메서드&lt;/code&gt;, &lt;code&gt;Private Property&lt;/code&gt;과 같은 문법이 바로 그것입니다.&lt;/p&gt;
&lt;h3 id=&#34;class와-생성자-함수&#34; &gt;&lt;code&gt;class&lt;/code&gt;와 &lt;code&gt;생성자 함수&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#class%ec%99%80-%ec%83%9d%ec%84%b1%ec%9e%90-%ed%95%a8%ec%88%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;또한 클래스와 생성자 함수 역시 종종 비교되는데, &lt;code&gt;클래스&lt;/code&gt;가 실제로는 &lt;code&gt;런타임 시간&lt;/code&gt;에 &lt;code&gt;생성자 함수&lt;/code&gt;로 동작하기 때문입니다.&lt;br&gt;
심지어 &lt;code&gt;prototype&lt;/code&gt;과 달리, &lt;code&gt;생성자 함수&lt;/code&gt;도 &lt;code&gt;static 프로퍼티 및 메서드&lt;/code&gt;, &lt;code&gt;Private Property&lt;/code&gt;를 가질 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 클래스의 스태틱 메서드
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;greetStatic&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Static hello!&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 클래스의 프라이빗 프로퍼티와 해당 값을 접근하는 getter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;privateField&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;getField&lt;/span&gt; () {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;privateField&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FuncPerson&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 생성자 함수의 프라이빗 프로퍼티
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateField&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 프라이빗 프로퍼티를 접근하는 getter
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getField&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;privateField&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 생성자 함수의 스태틱 함수
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;FuncPerson&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;greetStatic&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Static Hello!&amp;#39;&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;greetStatic&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;Static hello!&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;FuncPerson&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;greetStatic&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;Static hello!&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;getField&lt;/span&gt;()); &lt;span style=&#34;color:#75715e&#34;&gt;// 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FuncPerson&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;getField&lt;/span&gt;()) &lt;span style=&#34;color:#75715e&#34;&gt;// 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;따라서 자바스크립트의 &lt;code&gt;클래스&lt;/code&gt;는 &lt;code&gt;생성자 함수&lt;/code&gt;와 &lt;code&gt;프로토타입-기반 상속&lt;/code&gt;을 종합한 &lt;code&gt;문법적 설탕&lt;/code&gt;이라 할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;왜-javascript는-프로토타입-기반prototype-based을-채택했을까&#34; &gt;왜 &lt;code&gt;Javascript&lt;/code&gt;는 &lt;code&gt;프로토타입 기반(prototype-based)&lt;/code&gt;을 채택했을까?
&lt;span&gt;
    &lt;a href=&#34;#%ec%99%9c-javascript%eb%8a%94-%ed%94%84%eb%a1%9c%ed%86%a0%ed%83%80%ec%9e%85-%ea%b8%b0%eb%b0%98prototype-based%ec%9d%84-%ec%b1%84%ed%83%9d%ed%96%88%ec%9d%84%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;결론부터 말하자면, &lt;code&gt;Javascript&lt;/code&gt;는 &lt;code&gt;Java&lt;/code&gt;의 보조 수단으로써 설계되었기 때문입니다.&lt;br&gt;
넷스케이프에 재직하며, 브라우저인 &lt;code&gt;넷스케이프 네비게이터&lt;/code&gt;에서 사용할 스크립트 언어를 개발을 맡은 &lt;code&gt;브랜든 아이크&lt;/code&gt;는, &lt;code&gt;Scheme&lt;/code&gt; 언어를 브라우저에 구현하라는 지시를 받았었습니다.&lt;br&gt;
하지만 넷스케이프가 웹에서 &lt;code&gt;Java&lt;/code&gt;를 구현하기 위해 &lt;code&gt;썬 마이크로시스템즈&lt;/code&gt;와 계약을 체결하고, 이를 위한 언어인 &lt;code&gt;자바스크립트&lt;/code&gt;(이전에는 &lt;code&gt;Mocha&lt;/code&gt; -&amp;gt; &lt;code&gt;LiveScript&lt;/code&gt;로 이름이 계속 바뀌었다.)를 개발하게 되었습니다.&lt;br&gt;
따라서 Java에 존재하는 &lt;code&gt;Class&lt;/code&gt;를 자바스크립트에 포함하는 것이 허용되지 않았고, 자바스크립트는 이를 대체할 객체 지향 모델이 필요했고 &lt;code&gt;브랜든 아이크&lt;/code&gt;는 프로토타입 기반 상속을 구현했습니다.&lt;br&gt;
이는 &lt;a href=&#34;https://brendaneich.com/2005/06/javascript-1-2-and-in-between/&#34;&gt;브랜든 아이크의 블로그&lt;/a&gt;에 등록된 글 내용에서도 확인할 수 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;넷스케이프 2, 3 시절에는 &lt;code&gt;Javascript&lt;/code&gt;를 최소화하고, &lt;code&gt;DOM&lt;/code&gt;을 구현하며 &lt;strong&gt;&amp;ldquo;진짜 프로그래밍&amp;quot;은 Java에 맡겨야 한다&lt;/strong&gt;는 큰 압박을 받았습니다.&lt;br&gt;
(during Netscape 2 and 3 days I was under great pressure to minimize JS-the-language, implement JS-the-DOM, and defer to Java for “real programming” )&lt;br&gt;
(중략)&lt;br&gt;
따라서 &lt;code&gt;Javascript&lt;/code&gt;를 최소화하기 위해, 명시적 &lt;strong&gt;프로토타입-기반 위임&lt;/strong&gt;을 추가해 사용자가 &lt;strong&gt;단일 프로토타입 네임스페이스&lt;/strong&gt;에서 빌트-인 메서드를 자신만의 메서드로 보완할 수 있도록 했습니다.&lt;br&gt;
(Therefore in minimizing JS-the-language, I added explicit prototype-based delegation, allowing users to supplement built-in methods with their own in the same given single-prototype namespace.)&lt;br&gt;
출처: &lt;a href=&#34;https://brendaneich.com/2005/06/javascript-1-2-and-in-between/&#34;&gt;JavaScript 1, 2, and in between – Brendan Eich&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;참조&#34; &gt;참조
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ec%a1%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://modoocode.com/334&#34;&gt;Rust 의 다형성 - static 과 dynamic dispatch (C++ 을 곁들인..) (modoocode.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#different_ways_of_creating_and_mutating_prototype_chains&#34;&gt;Inheritance and the prototype chain - JavaScript | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties&#34;&gt;Private properties - JavaScript | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static&#34;&gt;static - JavaScript | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://brendaneich.com/2005/06/javascript-1-2-and-in-between/&#34;&gt;JavaScript 1, 2, and in between – Brendan Eich&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Javascript] 모듈 시스템들 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/module-system/</link>
      <pubDate>Wed, 03 Jul 2024 14:24:26 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/module-system/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 7월 2일 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/4_Module-System/Readme.md&#34;&gt;&lt;strong&gt;모듈 시스템&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;module-in-javascript&#34; &gt;Module in Javascript
&lt;span&gt;
    &lt;a href=&#34;#module-in-javascript&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Javascript에서 &lt;code&gt;모듈&lt;/code&gt;이란, &lt;em&gt;다른 프로그래밍 언어의 모듈처럼&lt;/em&gt;, 커진 자바스크립트 코드들을 여러 파일로 분리하는 것을 말합니다.&lt;br&gt;
초기에는 자바스크립트 코드들이 &lt;em&gt;크기도 작고 단순한 작업을 수행&lt;/em&gt;했기 때문에 &lt;strong&gt;코드의 분리를 필요로 하지 않았지만&lt;/strong&gt;, 자바스크립트가 &lt;strong&gt;완전한 애플리케이션을 실행&lt;/strong&gt;할 수 있게 되고, 이에 따라 코드의 크기도 커지고 복잡해졌습니다.&lt;br&gt;
특히 기존의 경우, &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 통해 여러 자바스크립트 파일을 불러올 수 밖에 없었는데, 이들은 전역 네임스페이스를 공유하기 때문에 이전 스크립트의 변수를 뒤집어쓰는 등 혼동을 초래하기 쉬웠습니다.&lt;br&gt;
따라서 이들을 보완하고자, 자바스크립트를 모듈화 하는 방법에 대해 여러 매커니즘이 등장하게 되었습니다.&lt;br&gt;
이러한 모듈 시스템으로는 주로 &lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJS&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;ESM&lt;/code&gt; 4개의 시스템이 주로 사용됩니다.&lt;br&gt;
상세하게는, &lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJS&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;와 같은 비표준 시스템이 등장해 사용되다가, &lt;code&gt;ES2015(ES6)&lt;/code&gt;에 &lt;code&gt;ESM(ES Modules)&lt;/code&gt;가 등장하므로써 모듈 시스템이 표준으로 자리잡게 되었습니다.&lt;br&gt;
2018년 Firefox 60이 등장한 이후, &lt;strong&gt;모든 주요 브라우저&lt;/strong&gt;들은 &lt;strong&gt;&lt;code&gt;ES Module&lt;/code&gt;을 지원&lt;/strong&gt;하게 되었으며 &lt;code&gt;CommonJS&lt;/code&gt;를 기본적으로 지원하는 &lt;code&gt;Node.js&lt;/code&gt; 역시 &lt;strong&gt;12버전&lt;/strong&gt; 부터 &lt;code&gt;ESM&lt;/code&gt;를 지원하기 시작했으며, 현재 &lt;code&gt;완전한 지원(fully-support)&lt;/code&gt;을 제공하고 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Node.js fully supports ECMAScript modules as they are currently specified and provides interoperability between them and its original module format, &lt;a href=&#34;https://nodejs.org/api/modules.html&#34;&gt;CommonJS&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/api/esm.html&#34;&gt;Modules: ECMAScript modules | Node.js v22.3.0 Documentation (nodejs.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;amd&#34; &gt;&lt;code&gt;AMD&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#amd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Asynchronous module definition(비동기 모듈 정의)&lt;/code&gt;, 줄여서 &lt;code&gt;AMD&lt;/code&gt;란 &lt;code&gt;비동기&lt;/code&gt;적으로 모듈과 그 종속성을 불러올 수 있도록 모듈을 정의하는 메커니즘을 말합니다.&lt;br&gt;
&lt;img src=&#34;AMD-Loading.png&#34; alt=&#34;AMD-Loading.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;위 그림처럼, AMD 방식은 불러올 파일들 간에 종속성이 존재하더라도 이들을 순서대로 로딩하지 않고 모두 개별적으로 로딩할 수 있습니다.&lt;br&gt;
&lt;code&gt;AMD&lt;/code&gt;는 전역 변수(또는 &lt;code&gt;자유 변수&lt;/code&gt;)로 사용할 수 있는 함수인 &lt;code&gt;define()&lt;/code&gt;과, &lt;code&gt;CommonJS&lt;/code&gt;와의 상호운용성을 제공하기 위해 유사한 형태의 &lt;code&gt;exports&lt;/code&gt;와 &lt;code&gt;require()&lt;/code&gt; 인터페이스를 제공합니다. (다만, 보통 &lt;code&gt;define()&lt;/code&gt;을 사용하는 것이 더 선호됩니다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;자유 변수&lt;/code&gt;: 함수에 사용되는 변수 중 &lt;strong&gt;지역 변수&lt;/strong&gt; 또는 &lt;strong&gt;해당 함수의 매개 변수&lt;/strong&gt;가 &lt;strong&gt;아닌&lt;/strong&gt; 변수를 의미합니다.&lt;br&gt;
알려진 &lt;code&gt;AMD&lt;/code&gt; 구현체로는 &lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo Toolkit&lt;/a&gt;, &lt;a href=&#34;https://requirejs.org/&#34;&gt;RequireJS&lt;/a&gt; 등이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-사양-httpsgithubcomamdjsamdjs-apiwikiamd&#34; &gt;API 사양 &lt;a href=&#34;https://github.com/amdjs/amdjs-api/wiki/AMD&#34;&gt;#&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#api-%ec%82%ac%ec%96%91-httpsgithubcomamdjsamdjs-apiwikiamd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;define-함수&#34; &gt;&lt;code&gt;define()&lt;/code&gt; 함수
&lt;span&gt;
    &lt;a href=&#34;#define-%ed%95%a8%ec%88%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;전역변수로 사용할 수 있는 이 함수는 일종의 &lt;strong&gt;네임스페이스 역할&lt;/strong&gt;을 해, 모듈에서 사용하는 변수와 전역 변수를 분리하는 역할을 해주는 함수입니다. 이를 통해 브라우저 환경의 Javascript에는 존재하지 않는 &lt;strong&gt;&lt;code&gt;파일 스코프&lt;/code&gt;를 대신&lt;/strong&gt;할 수 있습니다.&lt;br&gt;
&lt;code&gt;define()&lt;/code&gt; 함수는 다음과 같은 함수 시그니처를 가지며, 각 인수들은 다음을 뜻합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;define&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;dependencies&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;factory&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;모듈을 식별&lt;/code&gt;하는데 사용되는 인수로, &lt;code&gt;문자열 리터럴&lt;/code&gt;입니다.&lt;/li&gt;
&lt;li&gt;선택 사항이며, 이 값이 주어지지 않으면 로더가 요청하는 &amp;lt;script&amp;gt; 태그의 src 값(id)를 기본 id로 설정합니다.
&lt;ul&gt;
&lt;li&gt;만약 명시할 경우, 모듈 id는 반드시 &lt;code&gt;최상위&lt;/code&gt; 또는 &lt;code&gt;절대 id(절대 경로)&lt;/code&gt; 여야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;모듈 id&lt;/code&gt;는 정의중인 모듈을 식별하는데 사용할 수 있고, 종속성 배열 인수에도 사용됩니다. &lt;code&gt;AMD&lt;/code&gt;의 &lt;code&gt;모듈 id&lt;/code&gt;는 &lt;a href=&#34;https://wiki.commonjs.org/wiki/Modules/1.1.1#Module_Identifiers&#34;&gt;CommonJS 모듈 식별자에서 허용되는 것&lt;/a&gt;의 상위 집합입니다.
&lt;ul&gt;
&lt;li&gt;모듈 식별자는 &lt;code&gt;/(슬래쉬)&lt;/code&gt;로 구분되는 &lt;code&gt;용어들(terms)&lt;/code&gt;의 문자열입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;용어&lt;/code&gt;는 카멜 케이스 식별자, &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 여야 합니다.&lt;/li&gt;
&lt;li&gt;모듈 식별자는 &lt;code&gt;&amp;quot;.js&amp;quot;&lt;/code&gt;와 같은 파일이름 확장자를 가질 수 없습니다.&lt;/li&gt;
&lt;li&gt;모듈 식별자는 &lt;code&gt;상대적&lt;/code&gt;이거나, &lt;code&gt;최상위&lt;/code&gt; 일 수 있습니다. 만약 첫 번째 용어가 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; 인 경우 &lt;code&gt;상대적&lt;/code&gt;입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;최상위&lt;/code&gt; 식별자는 개념적 모듈 네임스페이스루트에서 확인됩니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;상대적&lt;/code&gt; 식별자는 &lt;code&gt;require&lt;/code&gt; 코드가 작성 및 호출되는 모듈의 식별자를 기준으로 합니다.
&lt;ul&gt;
&lt;li&gt;만약 &lt;code&gt;a/b/c&lt;/code&gt; 모듈이 &lt;code&gt;../d&lt;/code&gt; 모듈을 요청하면, 이는 &lt;code&gt;a/d&lt;/code&gt;로 요청됩니다.&lt;/li&gt;
&lt;li&gt;만약 &lt;code&gt;a/b/c&lt;/code&gt; 모듈이 &lt;code&gt;./e&lt;/code&gt; 모듈을 요청하면, 이는 &lt;code&gt;a/b/e&lt;/code&gt;로 요청됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dependencies&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;현재 정의 중인 모듈에 필요한 의존성&lt;/em&gt;인 &lt;code&gt;모듈 id&lt;/code&gt;의 배열 리터럴입니다.&lt;/li&gt;
&lt;li&gt;이는 모듈 팩토리 함수가 실행되기 전 요청되어야 하며, 요청된 값은 &lt;code&gt;의존성 배열에서의 인덱스&lt;/code&gt;와 &lt;strong&gt;동일한 순서&lt;/strong&gt;로 &lt;code&gt;팩토리 함수의 인자&lt;/code&gt;로 &lt;strong&gt;전달&lt;/strong&gt;되어야 합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;종속성 모듈 id&lt;/code&gt;는 &lt;code&gt;상대적 id&lt;/code&gt;일 수 있으며, 정의되는 모듈을 기준으로 요청됩니다.&lt;/li&gt;
&lt;li&gt;만약 종속성 목록에 &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt; 이라는 값이 등장한다면 이는 &lt;code&gt;CommonJS&lt;/code&gt; 모듈 사양에 정의된 해당 자유 변수로 해석되어야 합니다.&lt;/li&gt;
&lt;li&gt;만약 이를 생략하면, 기본 값은 &lt;code&gt;[&amp;quot;require&amp;quot;, &amp;quot;exports&amp;quot;, &amp;quot;module&amp;quot;]&lt;/code&gt;이 됩니다.
- 그러나 팩토리 함수의 &lt;code&gt;항수(매개변수의 개수)&lt;/code&gt;가 3보다 작은 경우, 로더는 함수의 &lt;code&gt;항수(또는 길이)&lt;/code&gt;에 해당하는 수의 인수만 사용해 팩토리 함수를 호출하도록 선택할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;factory&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;모듈 또는 객체를 인스턴스화하기위해 실행해야 하는 함수입니다.&lt;/li&gt;
&lt;li&gt;만약 &lt;code&gt;factory&lt;/code&gt;가 함수라면 &lt;code&gt;싱글톤&lt;/code&gt;으로 한 번만 실행되며, 객체인 경우 해당 객체를 모듈의 &lt;code&gt;exports&lt;/code&gt; 객체의 속성값으로 할당합니다.
&lt;ul&gt;
&lt;li&gt;만약 &lt;code&gt;factory&lt;/code&gt; 함수가 값(&lt;code&gt;객체&lt;/code&gt;, &lt;code&gt;함수&lt;/code&gt;, 또는 &lt;code&gt;true로 인식되는 모든 값&lt;/code&gt;)을 반환할 경우, 이 역시 해당 값을 &lt;code&gt;exports&lt;/code&gt; 객체의 속성값으로 할당합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;defineamd-프로퍼티&#34; &gt;&lt;code&gt;define.amd&lt;/code&gt; 프로퍼티
&lt;span&gt;
    &lt;a href=&#34;#defineamd-%ed%94%84%eb%a1%9c%ed%8d%bc%ed%8b%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;&amp;lt;script&amp;gt; src&lt;/code&gt; 브라우저 로딩에 필요한 전역 &lt;code&gt;define&lt;/code&gt; 함수가 &lt;code&gt;AMD&lt;/code&gt; API를 준수한다는 표시를 하기 위해, 모든 전역 &lt;code&gt;define&lt;/code&gt; 함수는 값이 객체인 &lt;strong&gt;&lt;code&gt;amd&lt;/code&gt; 라는 프로퍼티&lt;/strong&gt;를 갖고 있어야 합니다.&lt;br&gt;
이는 &lt;code&gt;AMD&lt;/code&gt; API를 준수하지 않는 &lt;code&gt;define&lt;/code&gt; 함수를 정의하는 다른 코드와의 충돌을 막을 수 있습니다.&lt;br&gt;
&lt;code&gt;define.amd&lt;/code&gt;객체 내부의 속성은 지정되어 있지 않기 때문에, &lt;code&gt;AMD&lt;/code&gt; 로더 구현체에 따라 해당 객체 내부의 프로퍼티를 활용해 여러 기능들을 추가할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;예시-코드&#34; &gt;예시 코드
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-%ec%bd%94%eb%93%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;define&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alpha&amp;#34;&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;require&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;exports&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;beta&amp;#34;&lt;/span&gt;], &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;beta&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 외부에 verb 라는 프로퍼티를 내보냄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;verb&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 의존성으로 설정된 다른 모듈을 사용하려면
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 넘겨받는 인수를 사용하거나,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;beta&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;verb&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 또는 require()를 이용해
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#75715e&#34;&gt;// 얻어 온 모듈을 사용해도 된다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;beta&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;verb&lt;/span&gt;();  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;장점&#34; &gt;장점
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%a5%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;전역변수-문제가-없음&#34; &gt;전역변수 문제가 없음
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%84%ec%97%ad%eb%b3%80%ec%88%98-%eb%ac%b8%ec%a0%9c%ea%b0%80-%ec%97%86%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;define()&lt;/code&gt; 함수를 이용해 모듈을 구현하므로, 즉, 클로저를 사용해 모듈 정의를 캡슐화 하므로 전역 네임스페이스 오염을 방지할 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;commonjs와의-상호운용성을-제공함&#34; &gt;&lt;code&gt;CommonJS&lt;/code&gt;와의 상호운용성을 제공함
&lt;span&gt;
    &lt;a href=&#34;#commonjs%ec%99%80%ec%9d%98-%ec%83%81%ed%98%b8%ec%9a%b4%ec%9a%a9%ec%84%b1%ec%9d%84-%ec%a0%9c%ea%b3%b5%ed%95%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h3 id=&#34;commonjs&#34; &gt;&lt;code&gt;CommonJS&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#commonjs&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CommonJS&lt;/code&gt;란 &lt;a href=&#34;https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/&#34;&gt;모질라의 Kevin Dangoor에 의해 2009년 시작된&lt;/a&gt;(당시 이름은 &lt;code&gt;ServerJS&lt;/code&gt;), &amp;ldquo;웹 브라우저 외부(특히 웹 서버 등 서버사이드)에서의 Javascript용 모듈 생태계를 표준화하기 위한 명세&amp;quot;를 포함한 프로젝트를 말합니다.&lt;br&gt;
&lt;code&gt;웹 브라우저 외부(특히 서버사이드)&lt;/code&gt;에서의 &lt;strong&gt;사용을 목표&lt;/strong&gt;로 했기 때문에, &lt;code&gt;Node.js&lt;/code&gt;와 같은 런타임에서 &lt;a href=&#34;https://nodejs.org/api/modules.html&#34;&gt;채택해 사용 중&lt;/a&gt;입니다.&lt;/p&gt;
&lt;h4 id=&#34;특징&#34; &gt;특징
&lt;span&gt;
    &lt;a href=&#34;#%ed%8a%b9%ec%a7%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CommonJS&lt;/code&gt;는 &lt;code&gt;동기식&lt;/code&gt; &lt;strong&gt;모듈 시스템&lt;/strong&gt;이기 때문에, 특정 모듈을 &lt;code&gt;import&lt;/code&gt;한 경우 &lt;em&gt;해당 모듈이 로드될 때 까지&lt;/em&gt; &lt;strong&gt;코드 실행이 중단&lt;/strong&gt;됩니다.&lt;/li&gt;
&lt;li&gt;모듈을 가져오기 위해 &lt;code&gt;require&lt;/code&gt; 함수를, 모듈을 내보내기 위해 &lt;code&gt;module.exports&lt;/code&gt; 객체를 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;api-명세-httpswikicommonjsorgwikimodules111&#34; &gt;API 명세 &lt;a href=&#34;https://wiki.commonjs.org/wiki/Modules/1.1.1&#34;&gt;#&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#api-%eb%aa%85%ec%84%b8-httpswikicommonjsorgwikimodules111&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;앞서 설명한 것 처럼, CommonJS에서 모듈을 불러오고, 내보내기 위해 &lt;code&gt;require()&lt;/code&gt;  함수와 &lt;code&gt;module.exports&lt;/code&gt; 객체를 사용합니다.&lt;br&gt;
&lt;a href=&#34;https://wiki.commonjs.org/wiki/Modules/1.1.1&#34;&gt;API 명세&lt;/a&gt;에는 이들에 대해 다음과 같은 계약이 명시되어 있으며, &lt;code&gt;CommonJS&lt;/code&gt; 구현체들은 이를 지켜야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;require()&lt;/code&gt; 함수는 &lt;code&gt;모듈 식별자(id)&lt;/code&gt;를 인자로 받으며, 해당 모듈이 &lt;code&gt;내보낸 API&lt;/code&gt;를 반환합니다.&lt;/li&gt;
&lt;li&gt;만약 &lt;code&gt;의존성 사이클&lt;/code&gt;이 존재할 경우, 외부 모듈이 &lt;code&gt;전이적 의존성&lt;/code&gt; 중 하나에 의해 &lt;code&gt;require&lt;/code&gt; 될 때 실행이 완료되지 않았을 수 있습니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;전이적 의존성&lt;/code&gt;: A가 B를 의존하고, B가 C를 의존할 경우 C는 A의 전이적 의존성이다.&lt;/li&gt;
&lt;li&gt;이 경우, &lt;code&gt;require&lt;/code&gt;가 반환하는 객체에는 현재 모듈의 실행을 유도한 &lt;code&gt;require&lt;/code&gt;의 실행 이전에 준비된 하나 이상의 &lt;code&gt;exports&lt;/code&gt;를 포함해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;요청된 모듈이 반환될 수 없으면, &lt;code&gt;require&lt;/code&gt;는 에러를 던져야 합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt; 함수는 &lt;code&gt;main&lt;/code&gt; 프로퍼티를 가질 수 있으며, 이는 &lt;code&gt;undefined&lt;/code&gt; 이거나 로드된 모듈의 &lt;code&gt;module&lt;/code&gt; 객체와 동일해야 합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require&lt;/code&gt; 함수는 &lt;code&gt;paths&lt;/code&gt; 속성을 가질 수 있으며, 이는 최상위 모듈 디렉토리 까지의 경로를 우선순위대로 배열한 문자열 배열입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; 컨텍스트 안에는 위 정의를 따르는 자유 변수인 &lt;code&gt;require&lt;/code&gt;가 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; 컨텍스트 안에는 모듈이 실행될 때 API를 추가할 수 있는 객체인 자유 변수 &lt;code&gt;exports&lt;/code&gt;가 있습니다.
&lt;ul&gt;
&lt;li&gt;모듈은 &lt;code&gt;exports&lt;/code&gt;를 &lt;strong&gt;유일한 내보내기 수단&lt;/strong&gt;으로 사용해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; 안에는 &lt;code&gt;module&lt;/code&gt;이라는 객체인 자유 변수가 존재해야 합니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; 객체는 모듈의 최상위 식별자인 &lt;code&gt;id&lt;/code&gt; 프로퍼티를 갖고 있어야 합니다.
&lt;ul&gt;
&lt;li&gt;또한 이 &lt;code&gt;id&lt;/code&gt; 프로퍼티를 사용해 &lt;code&gt;require(module.id)&lt;/code&gt;를 호출한 경우, &lt;code&gt;module.id&lt;/code&gt;의 출처가 된 &lt;code&gt;exports&lt;/code&gt; 객체를 반환해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt; 객체는 &lt;em&gt;모듈이 생성된 리소스에 대한 정규화된 URI&lt;/em&gt;인 &lt;code&gt;uri&lt;/code&gt; 문자열이 있을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;예시-코드-1&#34; &gt;예시 코드
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-%ec%bd%94%eb%93%9c-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// customers.js
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customers&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Rachel&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Galen&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Charles&amp;#34;&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 해당 모듈에서 내보내고자 하는 것들을 `exports`에 담아줍니다. 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// exports에 포함되지 않은 지역 변수는 외부에서 접근할 수 없습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;module&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;getCustomers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {     
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt;   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;sortCustomers&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {     
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;()   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  },   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;firstCustomer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {     
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;users&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]   
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  } 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// acounting.js  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;customers&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;./customers&amp;#39;&lt;/span&gt;)  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;customers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getCustomers&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// [&amp;#34;Rachel&amp;#34;, &amp;#34;Galen&amp;#34;, &amp;#34;Charles&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;customers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;sortCustomers&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// [&amp;#34;Charles&amp;#34;, &amp;#34;Galen&amp;#34;, &amp;#34;Rachel&amp;#34;]  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;customers&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;firsCustomer&lt;/span&gt;() &lt;span style=&#34;color:#75715e&#34;&gt;// [&amp;#34;Charles&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;장점-1&#34; &gt;장점
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%a5%ec%a0%90-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;배우고-사용하기-쉬움&#34; &gt;배우고 사용하기 쉬움
&lt;span&gt;
    &lt;a href=&#34;#%eb%b0%b0%ec%9a%b0%ea%b3%a0-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0-%ec%89%ac%ec%9b%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;nodejs에서-널리-사용됨&#34; &gt;&lt;code&gt;Node.js&lt;/code&gt;에서 널리 사용됨
&lt;span&gt;
    &lt;a href=&#34;#nodejs%ec%97%90%ec%84%9c-%eb%84%90%eb%a6%ac-%ec%82%ac%ec%9a%a9%eb%90%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;동기식이기-때문에-모듈-실행-전-모든-종속성이-로드됨을-보장함&#34; &gt;동기식이기 때문에, 모듈 실행 전 모든 종속성이 로드됨을 보장함
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ea%b8%b0%ec%8b%9d%ec%9d%b4%ea%b8%b0-%eb%95%8c%eb%ac%b8%ec%97%90-%eb%aa%a8%eb%93%88-%ec%8b%a4%ed%96%89-%ec%a0%84-%eb%aa%a8%eb%93%a0-%ec%a2%85%ec%86%8d%ec%84%b1%ec%9d%b4-%eb%a1%9c%eb%93%9c%eb%90%a8%ec%9d%84-%eb%b3%b4%ec%9e%a5%ed%95%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h4 id=&#34;단점&#34; &gt;단점
&lt;span&gt;
    &lt;a href=&#34;#%eb%8b%a8%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;동기식이기-때문에-대규모-앱에서-성능-문제를-야기할-수-있음&#34; &gt;동기식이기 때문에, 대규모 앱에서 성능 문제를 야기할 수 있음
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ea%b8%b0%ec%8b%9d%ec%9d%b4%ea%b8%b0-%eb%95%8c%eb%ac%b8%ec%97%90-%eb%8c%80%ea%b7%9c%eb%aa%a8-%ec%95%b1%ec%97%90%ec%84%9c-%ec%84%b1%eb%8a%a5-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%ec%95%bc%ea%b8%b0%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;모든 파일이 로컬 디스크에 있어 필요할 때 바로 불러올 수 있는 상황을 전제, 즉 &lt;em&gt;동기적으로 동작 가능한 Server-side JS 환경&lt;/em&gt;을 전제로 하기 때문입니다.&lt;/p&gt;
&lt;h5 id=&#34;tree-shaking이-없기-때문에-번들-크기가-커질-수-있음&#34; &gt;tree-shaking이 없기 때문에 번들 크기가 커질 수 있음
&lt;span&gt;
    &lt;a href=&#34;#tree-shaking%ec%9d%b4-%ec%97%86%ea%b8%b0-%eb%95%8c%eb%ac%b8%ec%97%90-%eb%b2%88%eb%93%a4-%ed%81%ac%ea%b8%b0%ea%b0%80-%ec%bb%a4%ec%a7%88-%ec%88%98-%ec%9e%88%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;브라우저에서-지원하지-않기-때문에-클라이언트-측-개발에-적합하지-않음&#34; &gt;브라우저에서 지원하지 않기 때문에, 클라이언트 측 개발에 적합하지 않음
&lt;span&gt;
    &lt;a href=&#34;#%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80%ec%97%90%ec%84%9c-%ec%a7%80%ec%9b%90%ed%95%98%ec%a7%80-%ec%95%8a%ea%b8%b0-%eb%95%8c%eb%ac%b8%ec%97%90-%ed%81%b4%eb%9d%bc%ec%9d%b4%ec%96%b8%ed%8a%b8-%ec%b8%a1-%ea%b0%9c%eb%b0%9c%ec%97%90-%ec%a0%81%ed%95%a9%ed%95%98%ec%a7%80-%ec%95%8a%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;만약 브라우저측에서 사용하고 싶다면 트랜스컴파일이 필요합니다.&lt;/p&gt;
&lt;h3 id=&#34;umd&#34; &gt;&lt;code&gt;UMD&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#umd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Universal Module Definition(범용 모듈 정의)&lt;/code&gt;, 줄여서 &lt;code&gt;UMD&lt;/code&gt;란 모듈 작성 방식이 &lt;strong&gt;CommonJS&lt;/strong&gt;와 &lt;strong&gt;AMD&lt;/strong&gt; 두 방식으로 나누어져서 호환 문제가 발생하자, 이를 해결하기 위해 나온 디자인 패턴입니다.&lt;br&gt;
&lt;code&gt;CommonJS&lt;/code&gt; 방식과 &lt;code&gt;AMD&lt;/code&gt; 방식 모두 사용할 수 있다는 장점이 있기 때문에 여러 모듈 로더에서 사용할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;예시-코드-httpsgithubcomumdjsumdblobmastertemplatescommonjsstrictjsl9&#34; &gt;예시 코드 &lt;a href=&#34;https://github.com/umdjs/umd/blob/master/templates/commonjsStrict.js#L9&#34;&gt;#&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-%ec%bd%94%eb%93%9c-httpsgithubcomumdjsumdblobmastertemplatescommonjsstrictjsl9&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 모듈을 생성하기 위해 CommonJS, AMD, 또는 이외의 브라우저 global을 사용합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 해당 예시는 `b` 라는 모듈을 의존하는 모듈을 불러옵니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 만약 브라우저 전역 경로(global path)를 사용하고 싶지 않다면, 인수로 root 대신 `this`를 넘겨주어야 합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 모듈 로더를 확인하는 IIFE(즉시 실행 함수)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;factory&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;define&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;function&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;define&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;amd&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// AMD 방식. 익명 모듈로 등록합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;define&lt;/span&gt;([&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;exports&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;], &lt;span style=&#34;color:#a6e22e&#34;&gt;factory&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;object&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nodeName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;string&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// CommonJS
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;factory&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;require&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// Browser globals
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;factory&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;commonJsStrict&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}), &lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}(&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;undefined&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Use b in some fashion.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// `exports` 객체에 프로퍼티를 추가해 모듈로 내보낼 프로퍼티들을 정의합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;exports&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;esm&#34; &gt;&lt;code&gt;ESM&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#esm&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ECMAScript Module&lt;/code&gt;, 줄여서 &lt;code&gt;ESM&lt;/code&gt;(또는 &lt;code&gt;ES Module&lt;/code&gt;)이란 &lt;code&gt;ECMAScript2015(ES6)&lt;/code&gt;에 도입된 네이티브 모듈 시스템을 말합니다. 즉 Javascript 언어의 일부로 모듈 시스템이 자리잡은 것으로, 웹 브라우저는 물론 Node.js와 같은 런타임에서도 광범위하게 지원되고 있습니다.&lt;br&gt;
&lt;code&gt;ES Module&lt;/code&gt;을 사용하기 위해서는 &lt;code&gt;&amp;lt;script type=&amp;quot;module&amp;quot;&amp;gt;&lt;/code&gt; 로 스크립트를 불러오거나, &lt;em&gt;&lt;code&gt;Node.js&lt;/code&gt;의 경우&lt;/em&gt; &lt;code&gt;package.json&lt;/code&gt; 파일에 &lt;code&gt;&amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;&lt;/code&gt; 속성을 추가하거나 파일 확장자를 &lt;code&gt;.mjs&lt;/code&gt;로 설정해야 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추가로, 만약 파일 확장자가 &lt;code&gt;.cjs&lt;/code&gt;라면 항상 &lt;code&gt;package&lt;/code&gt; 설정에 상관 없이 &lt;code&gt;CommonJS&lt;/code&gt; 모듈로 취급됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;로드-과정&#34; &gt;로드 과정
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%eb%93%9c-%ea%b3%bc%ec%a0%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;ES Module&lt;/code&gt;은 &lt;code&gt;비동기적&lt;/code&gt;으로 모듈을 불러온다고 알려져 있는데, 이는 &lt;code&gt;ES Module&lt;/code&gt; 을 불러오는 3단계 과정이 개별적으로 될 수 있기 때문입니다.&lt;br&gt;
&lt;a href=&#34;https://tc39.es/ecma262/#table-abstract-methods-of-module-records&#34;&gt;&lt;code&gt;ECMAScript&lt;/code&gt; 명세&lt;/a&gt;에 따르면, 3단계 과정은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LoadRequestedModules()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;모든 종속성들을 재귀적으로 로드해 모듈을 &lt;code&gt;연결(Link)&lt;/code&gt;할 준비를 하고, &lt;code&gt;Promise&lt;/code&gt;를 반환합니다.
&lt;ul&gt;
&lt;li&gt;모듈들을 비동기적으로 불러와, &lt;code&gt;모듈 레코드&lt;/code&gt;로 저장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Link()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;모듈의 모든 종속성들을 전이적으로 불러오고, &lt;code&gt;모듈 환경 레코드(Module Environment Record)&lt;/code&gt;를 생성해 모듈을 평가할 수 있도록 준비합니다.
&lt;ul&gt;
&lt;li&gt;모듈의 &lt;code&gt;exports&lt;/code&gt;와 메모리 상의 &lt;code&gt;imports&lt;/code&gt;를 연결합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Evaluate()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;모듈과 종속성의 평가에 대한 &lt;code&gt;Promise&lt;/code&gt;를 반환합니다. 평가가 성공적으로 이뤄진 경우 &lt;code&gt;resolve&lt;/code&gt;, 에러가 발생한 경우 &lt;code&gt;reject&lt;/code&gt; 합니다. host는 &lt;code&gt;Promise&lt;/code&gt;가 &lt;code&gt;reject&lt;/code&gt;된 경우 평가 에러를 던져야 합니다.
&lt;ul&gt;
&lt;li&gt;코드를 실행해 변수의 실제 값(모듈 레코드)으로 채웁니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;명세-httpsdevelopermozillaorgkodocswebjavascriptguidemodulesimporting_features_into_your_script&#34; &gt;명세 &lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Modules#importing_features_into_your_script&#34;&gt;#&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%85%ec%84%b8-httpsdevelopermozillaorgkodocswebjavascriptguidemodulesimporting_features_into_your_script&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;ES Module&lt;/code&gt;은 &lt;code&gt;export&lt;/code&gt; 문을 통해 내보내고, &lt;code&gt;import&lt;/code&gt; 문을 통해 다른 모듈을 불러옵니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;내보내고 싶은 항목 앞에 export를 배치하거나, 중괄호로 묶어 내보낼 수 있습니다.&lt;/li&gt;
&lt;li&gt;또는 &lt;code&gt;default&lt;/code&gt;로 &lt;code&gt;export&lt;/code&gt;할 수 있는데, 이는 &lt;code&gt;CommonJS&lt;/code&gt;와 &lt;code&gt;AMD&lt;/code&gt; 모듈 시스템과 함께 상호운용하는데 도움이 됩니다.&lt;/li&gt;
&lt;li&gt;또한, &lt;code&gt;as&lt;/code&gt; 키워드를 활용해 새로운 이름으로 내보낼 수도 있습니다.&lt;/li&gt;
&lt;li&gt;추가로, 다른 모듈의 요소들을 불러와 함께 &lt;code&gt;export&lt;/code&gt; 할 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1. 내보내고 싶은 항목 앞에 export 배치
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;square&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2. 내보내고 싶은 항목들을 중괄호로 묶기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;draw&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reportArea&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reportPerimeter&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 3. 내보내고 싶은 항목을 default로 내보내기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;randomSquare&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 4. as를 사용해 새로운 이름으로 내보내기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;function1&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newFunctionName&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;function2&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;anotherNewFunctionName&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 5. 다른 모듈의 요소들 함께 export 하기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 현재 모듈과 다른 모듈의 요소들을 함께 내보내고 싶다면 다음과 같이 할 수 있습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;x.js&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;불러오고 싶은 모듈의 항목들을 쉼표로 구분해 나열한 뒤 중괄호로 묶어 불러올 수 있습니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;from&lt;/code&gt;을 통해 모듈 파일 경로를 작성해야 하는데, 전체 절대 경로를 작성하거나, 상대 경로를 사용할 수 있습니다.&lt;/li&gt;
&lt;li&gt;이 역시 &lt;code&gt;export&lt;/code&gt;와 마찬가지로, &lt;code&gt;as&lt;/code&gt; 키워드를 활용해 새로운 이름으로 불러올 수 있습니다.&lt;/li&gt;
&lt;li&gt;추가로, &lt;code&gt;import()&lt;/code&gt; 함수를 통해 모듈을 동적으로 불러올 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1. 불러오고 싶은 항목들을 지정해 묶어 불러오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;draw&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reportArea&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;reportPerimeter&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./modules/square.js&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2. 모듈 객체로 묶어 불러오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Module&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./modules/module.js&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 3. default로 내보낸 모듈 불러오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;randomSquare&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./modules/square.js&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 위는 아래 코드를 단축한 형태와 같습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;randomSquare&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./modules/square.js&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 4. as를 사용해 새로운 이름으로 불러오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;function1&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;newFunctionName&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;function2&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;anotherNewFunctionName&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./modules/module.js&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 5. 동적으로 모듈 불러오기
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/modules/myModule.js&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;module&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Do something with the module.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;장점-2&#34; &gt;장점
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%a5%ec%a0%90-2&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;자바스크립트-언어에-내장된-표준화된-모듈-시스템임&#34; &gt;자바스크립트 언어에 내장된 표준화된 모듈 시스템임
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%eb%b0%94%ec%8a%a4%ed%81%ac%eb%a6%bd%ed%8a%b8-%ec%96%b8%ec%96%b4%ec%97%90-%eb%82%b4%ec%9e%a5%eb%90%9c-%ed%91%9c%ec%a4%80%ed%99%94%eb%90%9c-%eb%aa%a8%eb%93%88-%ec%8b%9c%ec%8a%a4%ed%85%9c%ec%9e%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;비동기-방식으로-모듈을-로딩해-성능-향상&#34; &gt;비동기 방식으로 모듈을 로딩해 성능 향상
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%eb%8f%99%ea%b8%b0-%eb%b0%a9%ec%8b%9d%ec%9c%bc%eb%a1%9c-%eb%aa%a8%eb%93%88%ec%9d%84-%eb%a1%9c%eb%94%a9%ed%95%b4-%ec%84%b1%eb%8a%a5-%ed%96%a5%ec%83%81&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;tree-shaking을-통해-번들-크기-줄일-수-있음&#34; &gt;Tree-shaking을 통해 번들 크기 줄일 수 있음
&lt;span&gt;
    &lt;a href=&#34;#tree-shaking%ec%9d%84-%ed%86%b5%ed%95%b4-%eb%b2%88%eb%93%a4-%ed%81%ac%ea%b8%b0-%ec%a4%84%ec%9d%bc-%ec%88%98-%ec%9e%88%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h4 id=&#34;단점-1&#34; &gt;단점
&lt;span&gt;
    &lt;a href=&#34;#%eb%8b%a8%ec%a0%90-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;비교적-최근에-등장했기-때문에-구형-브라우저에서는-완전히-지원되지-않음&#34; &gt;비교적 최근에 등장했기 때문에, 구형 브라우저에서는 완전히 지원되지 않음
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ea%b5%90%ec%a0%81-%ec%b5%9c%ea%b7%bc%ec%97%90-%eb%93%b1%ec%9e%a5%ed%96%88%ea%b8%b0-%eb%95%8c%eb%ac%b8%ec%97%90-%ea%b5%ac%ed%98%95-%eb%b8%8c%eb%9d%bc%ec%9a%b0%ec%a0%80%ec%97%90%ec%84%9c%eb%8a%94-%ec%99%84%ec%a0%84%ed%9e%88-%ec%a7%80%ec%9b%90%eb%90%98%ec%a7%80-%ec%95%8a%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;모듈을-import-하고-export-하는-구문이-복잡할-수-있음&#34; &gt;모듈을 import 하고 export 하는 구문이 복잡할 수 있음
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%a8%eb%93%88%ec%9d%84-import-%ed%95%98%ea%b3%a0-export-%ed%95%98%eb%8a%94-%ea%b5%ac%eb%ac%b8%ec%9d%b4-%eb%b3%b5%ec%9e%a1%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;모듈을-캐시하지-않아-추가적인-네트워크-요청-발생-가능&#34; &gt;모듈을 캐시하지 않아 추가적인 네트워크 요청 발생 가능
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%a8%eb%93%88%ec%9d%84-%ec%ba%90%ec%8b%9c%ed%95%98%ec%a7%80-%ec%95%8a%ec%95%84-%ec%b6%94%ea%b0%80%ec%a0%81%ec%9d%b8-%eb%84%a4%ed%8a%b8%ec%9b%8c%ed%81%ac-%ec%9a%94%ec%b2%ad-%eb%b0%9c%ec%83%9d-%ea%b0%80%eb%8a%a5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;모듈이 로드되면 메모리에 캐시하는 &lt;code&gt;CommonJS&lt;/code&gt;와 달리, 기본적으로 모듈을 캐시하지 않습니다.&lt;/p&gt;
&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/amdjs/amdjs-api/wiki/AMD&#34;&gt;AMD · amdjs/amdjs-api Wiki (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Asynchronous_module_definition&#34;&gt;Asynchronous module definition - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://requirejs.org/docs/whyamd.html&#34;&gt;Why AMD? (requirejs.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://d2.naver.com/helloworld/12864&#34;&gt;JavaScript 표준을 위한 움직임: CommonJS와 AMD (naver.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wiki.commonjs.org/wiki/Modules/1.1.1&#34;&gt;Modules/1.1.1 - CommonJS Spec Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/umdjs/umd?tab=readme-ov-file&#34;&gt;umdjs/umd: UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere. (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@lisa.berteau.smith/commonjs-and-the-history-of-javascript-modularity-63d8518f103e&#34;&gt;CommonJS and the History of Javascript Modularity | by Lisa Berteau Smith | Medium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.syncfusion.com/blogs/post/js-commonjs-vs-es-modules&#34;&gt;Understanding CommonJS vs. ES Modules in JavaScript (syncfusion.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/&#34;&gt;ES modules: A cartoon deep-dive - Mozilla Hacks - the Web developer blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tc39.es/ecma262/#table-abstract-methods-of-module-records&#34;&gt;ECMAScript® 2025 Language Specification (tc39.es)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/modules-in-javascript/#commonjsmodules&#34;&gt;Modules in JavaScript – CommonJS and ESmodules Explained (freecodecamp.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.freecodecamp.org/news/javascript-modules-beginners-guide/&#34;&gt;JavaScript Modules – A Beginner&amp;rsquo;s Guide (freecodecamp.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Javascript] 이벤트 전파 단계(버블링과 캡처링) 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/event-bubbling-capturing/</link>
      <pubDate>Wed, 26 Jun 2024 17:00:00 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/event-bubbling-capturing/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 6월 25일 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/3_Event-Bubbling-Capturing/Readme.md&#34;&gt;&lt;strong&gt;이벤트 캡처링과 버블링&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;이벤트-버블링과-캡처링&#34; &gt;이벤트 버블링과 캡처링
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%b4%eb%b2%a4%ed%8a%b8-%eb%b2%84%eb%b8%94%eb%a7%81%ea%b3%bc-%ec%ba%a1%ec%b2%98%eb%a7%81&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;HTML 태그에서 발생할 수 있는 이벤트는 &lt;a href=&#34;https://www.w3.org/TR/uievents/&#34;&gt;표준&lt;/a&gt;에 따르면 다음과 같은 순서로 전파됩니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;캡처링 단계(&lt;a href=&#34;https://dom.spec.whatwg.org/#dom-event-capturing_phase&#34;&gt;&lt;code&gt;CAPTURING_PHASE&lt;/code&gt;&lt;/a&gt;) : 이벤트가 DOM 트리 상의 하위 요소로 전파되는 단계&lt;/li&gt;
&lt;li&gt;타깃 단계(&lt;a href=&#34;https://dom.spec.whatwg.org/#dom-event-at_target&#34;&gt;&lt;code&gt;AT_TARGET&lt;/code&gt;&lt;/a&gt;) : 이벤트가 실제 대상 요소에 전달되는 단계&lt;/li&gt;
&lt;li&gt;버블링 단계(&lt;a href=&#34;https://dom.spec.whatwg.org/#dom-event-bubbling_phase&#34;&gt;&lt;code&gt;BUBBLING_PHASE&lt;/code&gt;&lt;/a&gt;) : 이벤트가 DOM 트리 상의 상위 요소로 전파되는 단계&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;event-flow-dom-tree.png&#34; alt=&#34;event-flow-dom-tree.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;즉, 위와 같은 형태로 DOM 트리가 구성되어 있다면, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;을 클릭하면 이벤트가 최상위 조상부터 시작해 아래로 전파되고, 타겟 요소에 도착해 이벤트가 실행된 후, 다시 위로 전파됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;참고로 이벤트 흐름 순서는 &lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/API/Event/eventPhase&#34;&gt;&lt;code&gt;Event.eventPhase&lt;/code&gt;&lt;/a&gt; 프로퍼티를 통해 알 수 있습니다.
&lt;ul&gt;
&lt;li&gt;이 값이 &lt;code&gt;1&lt;/code&gt;일 경우 &lt;code&gt;캡처링 단계&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;일 경우 &lt;code&gt;타깃 단계&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;일 경우 &lt;code&gt;버블링 단계&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;일 경우 현재 이 이벤트가 처리중이지 않음을 의미합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;또한, 이벤트 캡처링 방식과 버블링 방식 모두 존재하는 이유는, 기존에 분리되어 있던 이벤트 전파 방식들을 W3C에서 표준화 하며 둘을 모두 포함하는 시스템을 만들었기 때문입니다.
&lt;ul&gt;
&lt;li&gt;정확히는 &lt;code&gt;Netscape&lt;/code&gt;에서는 이벤트 캡처링만, &lt;code&gt;IE&lt;/code&gt;에서는 이벤트 버블링만 사용했기 때문에 상호 호환성을 위해 이들을 모두 포함하는 시스템이 표준으로 자리잡게 된 것입니다.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quirksmode.org/js/events_order.html&#34;&gt;Javascript - Event order (quirksmode.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quirksmode.org/js/events_access.html&#34;&gt;Javascript - Event accessing (quirksmode.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;이벤트&#34; &gt;이벤트?
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%b4%eb%b2%a4%ed%8a%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;Web API에서의 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Events&#34;&gt;&lt;code&gt;이벤트&lt;/code&gt;&lt;/a&gt;란, 마우스 클릭, 키보드 입력 등 DOM 상의 요소에서 발생할 수 있는 이벤트를 말합니다.&lt;br&gt;
&lt;code&gt;이벤트&lt;/code&gt;는 &lt;em&gt;사용자의 행동 뿐만 아니라&lt;/em&gt;, &lt;code&gt;HTMLElement.click()&lt;/code&gt;과 같은 메서드를 직접 호출하거나, &lt;code&gt;EventTarget.dispatchEvent()&lt;/code&gt;와 같은 메서드를 통해 타겟 객체로 이벤트를 보내는 등 프로그래밍적으로도 발생시킬 수 있습니다.&lt;br&gt;
이렇게 발생한 이벤트에 대응하고 싶다면, &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;와 같은 DOM 요소에 &lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/API/EventTarget/addEventListener&#34;&gt;&lt;code&gt;EventTarget.addEventListener()&lt;/code&gt;&lt;/a&gt;를 통해 이벤트 처리기를 연결할 수 있습니다.&lt;br&gt;
하나의 &lt;code&gt;요소(Element)&lt;/code&gt;는 하나 이상의 이벤트 처리기를 가질 수 있으며, 동일한 이벤트에 대해 여러 이벤트 처리기를 연결할 수도 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;같은 요소 / 같은 이벤트 / 같은 단계로 설정한 이벤트 처리기들은 설정한 순서대로 동작합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alert&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 먼저 트리거
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alert&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;발생한 이벤트는 상기한대로 캡처링 -&amp;gt; 타깃 -&amp;gt; 버블링의 흐름을 순서대로 거치게 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;캡처링-단계&#34; &gt;캡처링 단계
&lt;span&gt;
    &lt;a href=&#34;#%ec%ba%a1%ec%b2%98%eb%a7%81-%eb%8b%a8%ea%b3%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;캡처링 단계&lt;/code&gt;란, 이벤트가 하위 요소로 전파되는 이벤트 전파 단계를 말합니다.&lt;br&gt;
&lt;code&gt;on&amp;lt;event&amp;gt;&lt;/code&gt; 프로퍼티, HTML 속성, &lt;code&gt;addEventListener(event, handler)&lt;/code&gt;를 이용해 이벤트 처리기를 연결한 경우, 이들은 캡처링에 대해 알 수 없습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;즉, &lt;code&gt;타깃&lt;/code&gt;, &lt;code&gt;버블링&lt;/code&gt; 단계에서만 동작합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 이들을 &lt;code&gt;캡처링 단계&lt;/code&gt;에서 &lt;strong&gt;이벤트를 인식&lt;/strong&gt;하게 하려면, &lt;code&gt;addEventListener()&lt;/code&gt;의 &lt;code&gt;capture&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt;로 설정해주어야 합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(..., { &lt;span style=&#34;color:#a6e22e&#34;&gt;capture&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 또는
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(..., &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이렇게 &lt;code&gt;capture&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt;로 할당해주면 특정 요소에서 이벤트가 발생했을 때, 최상위 조상부터 차례대로 이벤트가 전파될 것입니다.&lt;br&gt;
&lt;code&gt;이벤트&lt;/code&gt;는 &lt;code&gt;document&lt;/code&gt;부터 DOM 트리를 따라 타깃(&lt;code&gt;event.target&lt;/code&gt;)까지 전파되며, &lt;em&gt;해당 이벤트 유형을 처리하는&lt;/em&gt; &lt;code&gt;addEventListener(... , { capture: true })&lt;/code&gt;로 할당된 핸들러들을 동작시킵니다.&lt;/p&gt;
&lt;p&gt;이어서 나올 버블링과 달리 캡처링은 실제 코드에서 사용될 일이 흔치 않습니다.&lt;br&gt;
논리적으로 생각해보면, &lt;em&gt;더 세부적이고 특정적인 요소에 핸들러가 할당될수록&lt;/em&gt; 그 요소에 대한 &lt;strong&gt;세부 사항과 어떤 동작을 요하는지 더 잘 알 것&lt;/strong&gt;입니다.&lt;br&gt;
따라서 &lt;em&gt;이벤트가 발생한 타깃 위치부터 전파되는&lt;/em&gt; &lt;code&gt;버블링 단계&lt;/code&gt;에서 &lt;strong&gt;이벤트를 처리하는 것이 더 적합&lt;/strong&gt;할 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;타깃-단계&#34; &gt;타깃 단계
&lt;span&gt;
    &lt;a href=&#34;#%ed%83%80%ea%b9%83-%eb%8b%a8%ea%b3%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;타깃 단계&lt;/code&gt;란, 이벤트가 실제 타깃 요소에 전달되는 이벤트 전파 단계를 말합니다.&lt;br&gt;
엄밀히 말하면, &lt;em&gt;&lt;strong&gt;타깃 단계는 별도로 처리되지 않으며&lt;/strong&gt;&lt;/em&gt; (즉, 이벤트를 더 전파시키지 않음) 캡처링 및 버블링 단계의 &lt;strong&gt;핸들러&lt;/strong&gt;가 &lt;code&gt;타깃 단계에 트리거&lt;/code&gt; 됩니다.&lt;/p&gt;
&lt;h4 id=&#34;eventtarget&#34; &gt;&lt;code&gt;Event.target&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#eventtarget&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;이벤트가 발생한 요소는 이벤트 핸들러 내부에서 &lt;code&gt;Event.target&lt;/code&gt;을 통해 접근할 수 있습니다.
이와 관련해 주의해야 할 사항으로, &lt;code&gt;Event.target&lt;/code&gt;를 &lt;code&gt;Event.currentTarget&lt;/code&gt;과 헷갈리지 않아야 한다는 것입니다.&lt;br&gt;
&lt;code&gt;Event.target&lt;/code&gt;은 실제로 이벤트가 시작된, 타깃 요소를 의미하며, 이는 이벤트가 버블링되어 전파되어도 변하지 않습니다.&lt;br&gt;
반면, &lt;code&gt;Event.currentTarget&lt;/code&gt;(또는 핸들러 내부에서 호출한 &lt;code&gt;this&lt;/code&gt;)은 현재 실행중인 이벤트 핸들러가 &lt;strong&gt;할당된 요소&lt;/strong&gt;를 의미합니다.&lt;br&gt;
예를 들어, &lt;code&gt;div &amp;gt; p&lt;/code&gt; 형태로 DOM 트리가 구성되었고 &lt;code&gt;p&lt;/code&gt;에서 발생한 이벤트를 &lt;code&gt;div&lt;/code&gt;의 이벤트 핸들러가 처리하는 상황이라 가정합시다.&lt;br&gt;
이때, &lt;code&gt;div&lt;/code&gt;의 이벤트 핸들러에서 &lt;code&gt;event.target&lt;/code&gt;을 호출한다면 이는 &lt;code&gt;p&lt;/code&gt;를 가리키고, &lt;code&gt;event.currentTarget&lt;/code&gt;을 호출한다면 이는 &lt;code&gt;div&lt;/code&gt;를 가리킨다는 것입니다.&lt;/p&gt;
&lt;h3 id=&#34;버블링-단계&#34; &gt;버블링 단계
&lt;span&gt;
    &lt;a href=&#34;#%eb%b2%84%eb%b8%94%eb%a7%81-%eb%8b%a8%ea%b3%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;버블링 단계&lt;/code&gt;란, 이벤트가 타깃 요소부터 최상위 요소까지 전파되는 이벤트 전파 단계를 말합니다.&lt;br&gt;
이벤트는 상위 요소로 계속해서 전파되며, 해당 이벤트를 처리하는 핸들러를 동작시킵니다.&lt;br&gt;
다만 &lt;code&gt;focus&lt;/code&gt;, &lt;code&gt;blur&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt;/&lt;code&gt;unload&lt;/code&gt; 등과 같이 버블링되지 않는 몇몇 이벤트들도 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이벤트가 버블링 되는지 여부는 &lt;code&gt;Event&lt;/code&gt;의 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Event/bubbles&#34;&gt;&lt;code&gt;bubbles&lt;/code&gt;&lt;/a&gt;프로퍼티를 통해 알 수 있습니다. 이 값이 &lt;code&gt;true&lt;/code&gt;라면 해당 이벤트는 버블링되어 위로 전파됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;버블링-중단stoppropagation&#34; &gt;버블링 중단(&lt;code&gt;stopPropagation&lt;/code&gt;)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b2%84%eb%b8%94%eb%a7%81-%ec%a4%91%eb%8b%a8stoppropagation&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;버블링을 통해 이벤트가 전파되는 것이 유용할 수 있지만, 그렇지 않은 경우도 있을 수 있습니다.&lt;br&gt;
예를 들어, 이벤트가 계속 전파되어 원하지 않았던 &lt;strong&gt;상위 요소의 이벤트 핸들러까지 동작&lt;/strong&gt;시켜 오동작을 일으킬 수도 있습니다.&lt;br&gt;
이럴 때, 이벤트 핸들러 내부에서 &lt;strong&gt;&lt;code&gt;Event.stopPropagation()&lt;/code&gt;&lt;/strong&gt; 메서드를 호출해 이벤트가 더 버블링 되는 것을 막을 수 있습니다.&lt;br&gt;
다만, &lt;strong&gt;한 요소&lt;/strong&gt;에 특정 이벤트를 처리하는 &lt;em&gt;&lt;strong&gt;핸들러가 여러 개일 경우&lt;/strong&gt;&lt;/em&gt;, 위로 이벤트가 버블링 되는 것은 막을 수 있지만 &lt;strong&gt;다른 핸들러가 동작 하는 것은 막을 수 없습니다&lt;/strong&gt;.&lt;br&gt;
따라서 &lt;em&gt;버블링을 막고&lt;/em&gt; &lt;strong&gt;다른 핸들러의 동작까지 막으려면&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Event.stopImmediatePropagation()&lt;/code&gt;&lt;/strong&gt; 을 사용해야 합니다.&lt;br&gt;
이렇게 버블링을 막을 수 있긴 하지만, &lt;strong&gt;대부분의 경우(특히 분석, 로깅등을 수행할 때) 버블링이 유용&lt;/strong&gt;하기 때문에 꼭 멈춰야 하는 상황이 아니라면 &lt;strong&gt;막지 않는 것이 좋습니다&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&#34;이벤트-위임event-delegation&#34; &gt;이벤트 위임(Event Delegation)
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%b4%eb%b2%a4%ed%8a%b8-%ec%9c%84%ec%9e%84event-delegation&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;버블링을 통해 이벤트가 위로 전파된다는 점을 활용해서, 모든 하위 요소에 이벤트 핸들러를 설정하는 대신 상위 요소에서 하위 요소에서 발생하는 이벤트들을 처리하는 핸들러를 설정하는 형태로 구현할 수도 있습니다.&lt;br&gt;
만약 하위 요소에서 이벤트가 발생할 때 비슷한 또는 똑같은 작업을 수행하는 경우, 번거롭게 이들에 모두 이벤트 핸들러를 설정하는 것 보다 위임하는 형태로 작성하면 &lt;strong&gt;코드가 더욱 간결&lt;/strong&gt;해질 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;예시---16개의-타일-색-바꾸기&#34; &gt;예시 - 16개의 타일 색 바꾸기
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c---16%ea%b0%9c%ec%9d%98-%ed%83%80%ec%9d%bc-%ec%83%89-%eb%b0%94%ea%be%b8%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;예시로 16개의 div 타일이 있고, 각 타일을 클릭하면 랜덤으로 타일의 색깔을 바꾼다고 합시다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;container&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tile&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;만약 전자처럼 모든 하위요소(&lt;code&gt;tile&lt;/code&gt;)에 이벤트 핸들러를 단다면 코드는 다음과 같을 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;randomColor&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`rgb(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;floor&lt;/span&gt;(Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;random&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;floor&lt;/span&gt;(Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;random&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;floor&lt;/span&gt;(Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;random&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;255&lt;/span&gt;)&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;)`&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementById&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;container&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;of&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;backgroundColor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;randomColor&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;반면, 이벤트를 상위 요소(&lt;code&gt;container&lt;/code&gt;)로 위임하게 된다면 코드를 다음과 같이 바꿀 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;container&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;querySelector&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;#container&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;container&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, (&lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;event&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;style&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;backgroundColor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;randomColor&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events&#34;&gt;Introduction to events - Learn web development | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Events&#34;&gt;Event reference | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dom.spec.whatwg.org/&#34;&gt;DOM Standard (whatwg.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ko.javascript.info/bubbling-and-capturing&#34;&gt;버블링과 캡처링 (javascript.info)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&#34;&gt;이벤트 버블링, 이벤트 캡처 그리고 이벤트 위임까지 • 캡틴판교 블로그 (joshua1988.github.io)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.quirksmode.org/js/events_order.html&#34;&gt;Javascript - Event order (quirksmode.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Javascript] Map과 Object, 뭘 써야 할까?</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/map-vs-object/</link>
      <pubDate>Sun, 21 Apr 2024 06:13:01 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/map-vs-object/</guid>
      <description>&lt;h2 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;최근 한 기업의 코딩 테스트를 푸는데, &lt;strong&gt;&lt;code&gt;중첩된 구조&lt;/code&gt;의 객체&lt;/strong&gt;를 필요로 하는 문제를 맞닥들이게 되었다.&lt;br&gt;
나는 &amp;lsquo;&lt;code&gt;Object&lt;/code&gt;가 &lt;code&gt;Map&lt;/code&gt;보다 있는 기능이 별로 없으니까, 혹시 몰라서 &lt;em&gt;메모리 터질 수 있는&lt;/em&gt; &lt;code&gt;Map&lt;/code&gt; 보단 &lt;code&gt;Object&lt;/code&gt;가 낫지 않을까?&amp;rsquo; 라는 생각으로 &lt;code&gt;Object&lt;/code&gt;를 활용해 해당 문제를 풀었다.&lt;br&gt;
그리고 그 이후 내 생각이 맞을까? 라는 생각을 갖게 되었고 이를 직접 테스트 한 뒤 내용을 정리해보고 싶어졌다.&lt;br&gt;
따라서 여러 글을 찾아 보았고, 직접 문제와 유사한 상황을 가정하고 코드를 작성해 시간과 메모리 사용량을 측정해보았다.&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34; &gt;TL;DR
&lt;span&gt;
    &lt;a href=&#34;#tldr&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Map&lt;/code&gt;은 ES6 명세에 따라 선형시간 이하의 접근 시간을 제공해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V8&lt;/code&gt;과 같은 대부분의 JS 엔진에서는 &lt;code&gt;HashTable&lt;/code&gt;을 활용해 빠른 삽입/접근 시간을 제공한다.&lt;/li&gt;
&lt;li&gt;테스트 결과, 다른 벤치마크들 처럼 &lt;code&gt;Map&lt;/code&gt;이 &lt;code&gt;Object&lt;/code&gt;보다 30~50% 정도 빠른 속도를 보였다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;map-vs-object&#34; &gt;&lt;code&gt;Map&lt;/code&gt; vs &lt;code&gt;Object&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#map-vs-object&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;자바스크립트에서 Map과 Object 모두 &lt;code&gt;키-값&lt;/code&gt; 쌍으로 데이터를 저장하는 것은 동일하지만, 세부적으로는 다른점들이 존재합니다.&lt;/p&gt;
&lt;h3 id=&#34;map&#34; &gt;&lt;code&gt;Map&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#map&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Javascript 2015(ES6)&lt;/code&gt;에서 처음으로 등장했습니다.&lt;/li&gt;
&lt;li&gt;Map은 &lt;code&gt;원시 타입&lt;/code&gt;, &lt;code&gt;객체&lt;/code&gt;, &lt;code&gt;함수&lt;/code&gt; 등 &lt;strong&gt;어떤 데이터 타입&lt;/strong&gt;이든 &lt;strong&gt;키로 지정&lt;/strong&gt;할 수 있습니다.&lt;/li&gt;
&lt;li&gt;맵의 &lt;code&gt;키&lt;/code&gt;는 &lt;strong&gt;삽입된 순서&lt;/strong&gt;대로 순서를 &lt;strong&gt;유지&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;li&gt;Map은 원소들을 &lt;code&gt;반복(Iteration)&lt;/code&gt;하는데 사용하는 &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, &lt;code&gt;entries&lt;/code&gt;와 같은 &lt;strong&gt;&lt;code&gt;빌트인 메서드&lt;/code&gt;&lt;/strong&gt; 들을 갖고 있습니다.&lt;/li&gt;
&lt;li&gt;원소에 접근하기 위해 &lt;code&gt;set()&lt;/code&gt;, &lt;code&gt;get()&lt;/code&gt;와 같은 &lt;strong&gt;메서드를 사용&lt;/strong&gt;해야 합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;object&#34; &gt;&lt;code&gt;Object&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#object&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Object의 &lt;code&gt;키&lt;/code&gt;는 &lt;code&gt;문자열&lt;/code&gt;이거나 &lt;code&gt;기호&lt;/code&gt;여야 합니다.
&lt;ul&gt;
&lt;li&gt;만약 다른 자료형을 사용할 경우, &lt;strong&gt;&lt;code&gt;자동적으로&lt;/code&gt; 문자열로 변경&lt;/strong&gt;됩니다.
&lt;ul&gt;
&lt;li&gt;즉, &lt;code&gt;키&lt;/code&gt;가 동일한지 검사할 때 &lt;code&gt;느슨한 동등 비교(==)&lt;/code&gt;를 통해 값만 비교합니다.
&lt;ul&gt;
&lt;li&gt;이와 달리 Map은 &lt;code&gt;엄격한 동등 비교(===)&lt;/code&gt;를 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Object의 속성들은 &lt;strong&gt;&lt;code&gt;순서를 보장하지 않습니다.&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;대부분의 JS 엔진들이 삽입된 순서를 유지&lt;/em&gt;하려고 하지만, 이는 엔진에서 처리해주는것이지 언어 자체에서 규정된 사항이 아닙니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Object는 &lt;code&gt;prototype chain&lt;/code&gt;이 있어, &lt;strong&gt;프로토타입 객체들로부터 속성과 메서드를 상속&lt;/strong&gt;받습니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;프로토타입 체인(prototype chain)&lt;/code&gt;: 모든 객체에는 &lt;code&gt;프로토타입&lt;/code&gt;이라는 다른 객체에 대한 링크가 존재하며, 해당 프로토타입 또한 자체 프로토타입을 가지는데 이러한 연결이 null을 프로토타입으로 하는 객체를 만날 때 까지 계속되는 형태를 뜻합니다.
&lt;img src=&#34;object-prototype.png&#34; alt=&#34;object-prototype.png&#34;&gt;
&lt;ul&gt;
&lt;li&gt;출처: &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes&#34;&gt;Object prototypes - Learn web development | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Object의 원소를 &lt;code&gt;반복&lt;/code&gt;하려면, &lt;code&gt;Object.keys(obj)&lt;/code&gt; 를 통해 키 배열을 추출하거나, &lt;code&gt;for in&lt;/code&gt;문을 사용해야 합니다.&lt;/li&gt;
&lt;li&gt;Object는 원소에 접근하기 위해 &lt;code&gt;대괄호 표현식&lt;/code&gt; 또는 &lt;code&gt;.&lt;/code&gt;을 사용해 직접 접근합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;성능은-어떨까&#34; &gt;성능은 어떨까?
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%b1%eb%8a%a5%ec%9d%80-%ec%96%b4%eb%96%a8%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;온라인에 올라온 대부분의 &lt;code&gt;Map&lt;/code&gt; vs &lt;code&gt;Object&lt;/code&gt; 성능 벤치마크에서는 &lt;code&gt;Map&lt;/code&gt;이 삽입, 삭제, 갱신 등의 작업에서 &lt;strong&gt;성능 우위&lt;/strong&gt;를 보이고 있었습니다.&lt;/p&gt;
&lt;h4 id=&#34;map이-성능우위임을-보여주는-벤치마크&#34; &gt;Map이 성능우위임을 보여주는 벤치마크
&lt;span&gt;
    &lt;a href=&#34;#map%ec%9d%b4-%ec%84%b1%eb%8a%a5%ec%9a%b0%ec%9c%84%ec%9e%84%ec%9d%84-%eb%b3%b4%ec%97%ac%ec%a3%bc%eb%8a%94-%eb%b2%a4%ec%b9%98%eb%a7%88%ed%81%ac&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;zhenghao&lt;/code&gt;라는 유저의 벤치마크(&lt;a href=&#34;https://www.zhenghao.io/posts/object-vs-map&#34;&gt;When You Should Prefer Map Over Object In JavaScript (zhenghao.io)&lt;/a&gt;), MeasureThat의 벤치마크(&lt;a href=&#34;https://www.measurethat.net/Benchmarks/Show/11290/4/map-vs-object-real-world-performance#latest_results_block&#34;&gt;Benchmark: Map vs Object (real-world) Performance - MeasureThat.net&lt;/a&gt;) 등 데이터를 살펴보면 삽입/값 가져오기 연산시 &lt;strong&gt;27~50%&lt;/strong&gt; 가량 &lt;strong&gt;Map이 더 빠르다&lt;/strong&gt;는 결과가 나왔음을 알 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 테스트들은 Map이 중첩되지 않은, &lt;strong&gt;깊이가 1인 평면상&lt;/strong&gt;에서 이뤄진 테스트입니다.&lt;/li&gt;
&lt;li&gt;추가로 &lt;strong&gt;메모리&lt;/strong&gt; 역시 &lt;strong&gt;Map이 더 적게 차지&lt;/strong&gt;한다는 결과가 많았습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;왜&#34; &gt;왜?
&lt;span&gt;
    &lt;a href=&#34;#%ec%99%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://262.ecma-international.org/6.0/#sec-map-objects&#34;&gt;ES6 명세&lt;/a&gt;에 따르면, &lt;code&gt;Map&lt;/code&gt; 객체는 &lt;code&gt;HashTable&lt;/code&gt;, 또는 다른 메커니즘을 활용해 컬렉션 요소 수에 대해 &lt;strong&gt;선형 이하의 접근 시간&lt;/strong&gt;을 제공할 수 있어야 합니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Map object must be implemented using either &lt;strong&gt;hash tables or other mechanisms&lt;/strong&gt; that, on average, &lt;strong&gt;provide access times that are sublinear&lt;/strong&gt; on the number of elements in the collection. The data structures used in this Map objects specification is only intended to describe the required observable semantics of Map objects. It is not intended to be a viable implementation model.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이러한 명세를 지키기 위해, 다양한 JS 엔진에서 HashTable을 활용해 &lt;code&gt;Map&lt;/code&gt; 객체를 구현하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V8(Google) - &lt;a href=&#34;https://github.com/v8/v8/blob/master/src/objects/map.cc#L2042&#34;&gt;v8/src/objects/map.cc at master · v8/v8 (github.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SpiderMonkey(Mozilla) - &lt;a href=&#34;https://searchfox.org/mozilla-central/source/js/src/builtin/MapObject.cpp&#34;&gt;MapObject.cpp - mozsearch (searchfox.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;오늘은 세계에서 가장 많이 사용되는 &lt;strong&gt;Chromium 기반의 환경&lt;/strong&gt;을 가정하고 성능을 비교해보기 위해, &lt;strong&gt;V8 엔진&lt;/strong&gt;의 &lt;code&gt;Map&lt;/code&gt;에 대해 알아보겠습니다.&lt;/p&gt;
&lt;h4 id=&#34;map-in-v8-engine&#34; &gt;Map in V8 Engine
&lt;span&gt;
    &lt;a href=&#34;#map-in-v8-engine&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;V8 엔진에서 &lt;code&gt;Map&lt;/code&gt;은 &lt;strong&gt;HashTable&lt;/strong&gt;, 정확히는 &lt;code&gt;OrderedHashTable&lt;/code&gt; 이라는 삽입된 순서를 유지하는 HashTable을 사용합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://codereview.chromium.org/220293002/&#34;&gt;Issue 220293002: OrderedHashTable implementation with Set and Map interfaces - Code Review (chromium.org)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이는 &lt;a href=&#34;https://wiki.mozilla.org/User:Jorend/Deterministic_hash_tables&#34;&gt;&lt;code&gt;Deterministic hash table&lt;/code&gt;&lt;/a&gt;라는 자료구조를 기반으로 합니다.&lt;/p&gt;
&lt;h5 id=&#34;deterministic-hash-table&#34; &gt;&lt;code&gt;Deterministic hash table&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#deterministic-hash-table&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// pseudocode of Deterministic hash table
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Entry&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Key key;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Value value;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Entry &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;chain;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CloseTable&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Entry&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;[] hashTable;  &lt;span style=&#34;color:#75715e&#34;&gt;// array of pointers into the data table
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Entry[] dataTable;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;기존의 버킷/체인 해시 테이블&lt;/em&gt;과 &lt;strong&gt;조회/삽입&lt;/strong&gt;은 &lt;strong&gt;비슷&lt;/strong&gt;하게 진행되지만, 각 Entry들이 Heap에 별도로 할당되지 않고 &lt;strong&gt;삽입 순서대로&lt;/strong&gt; &lt;code&gt;dateTable&lt;/code&gt;에 저장되게 됩니다. (&lt;code&gt;hashTable&lt;/code&gt;의 각 요소들은 버킷인 &lt;code&gt;dataTable&lt;/code&gt;을 가리킴)&lt;br&gt;
따라서 &lt;code&gt;hashTable&lt;/code&gt;에서 &lt;strong&gt;삽입된 순서&lt;/strong&gt;를 &lt;strong&gt;유지&lt;/strong&gt;할 수 있습니다.&lt;br&gt;
V8 엔진에서 &lt;code&gt;HashTable&lt;/code&gt;을 사용하므로, &lt;code&gt;set&lt;/code&gt;을 통한 삽입과 &lt;code&gt;get&lt;/code&gt;을 통한 탐색에 $O(1)$ 의 시간이 걸릴것으로 유추할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;직접-확인-해보자&#34; &gt;직접 확인 해보자
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%ec%a0%91-%ed%99%95%ec%9d%b8-%ed%95%b4%eb%b3%b4%ec%9e%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;앞서 살펴본 테스트들 결과에 따르면, Map이 시간적으로나 공간적으로나 Object에 우위를 보이고 있음을 알 수 있습니다.&lt;br&gt;
그래도 한 번 제 케이스에 맞게 직접 실험해보고 싶었고, &lt;strong&gt;Nested한 구조에서도 우위일지&lt;/strong&gt; 알아보고 싶어졌습니다.&lt;/p&gt;
&lt;h3 id=&#34;테스트-진행-방식&#34; &gt;테스트 진행 방식
&lt;span&gt;
    &lt;a href=&#34;#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%a7%84%ed%96%89-%eb%b0%a9%ec%8b%9d&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;테스트에 사용할 명령어 set을 먼저 만듭니다.
&lt;ul&gt;
&lt;li&gt;1,000,000개의 명령어 배열을 만들고, 500,000개의 삽입 명령과 500,000개의 삭제 명령을 만들어 채웁니다. 각 명령은 다음과 같은 형태를 가집니다.
&lt;ul&gt;
&lt;li&gt;주어지는 경로는 &lt;code&gt;.&lt;/code&gt;으로 구분되며, 경로를 이루는 문자열들은 key 또는 property의 이름에 해당합니다.
&lt;ul&gt;
&lt;li&gt;ex) &lt;code&gt;abc.def.fgi&lt;/code&gt;라면, &lt;code&gt;root.get(&#39;abc&#39;).get(&#39;def&#39;).get(&#39;fgi&#39;)&lt;/code&gt;를 통해 접근할 수 있습니다.&lt;/li&gt;
&lt;li&gt;편의상 주어지는 경로는 모두 절대경로입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;[삽입, &amp;quot;경로&amp;quot;]&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;경로의 마지막 문자열을 제외한 위치까지 이동한 후, 마지막 문자열의 이름으로 새 Map(또는 Object)을 생성합니다.
&lt;ul&gt;
&lt;li&gt;올바르지 않은 경로인 경우 생성하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[삭제, &amp;quot;경로&amp;quot;]&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;경로의 마지막 문자열을 제외한 위치까지 이동한 후, 마지막 문자열의 이름에 해당하는 Map(또는 Object)을 삭제합니다.
&lt;ul&gt;
&lt;li&gt;올바르지 않은 경로인 경우 삭제하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Map으로 먼저 해당 명령들을 수행하고, 시간을 기록합니다.&lt;/li&gt;
&lt;li&gt;Object로 해당 명령들을 동일하게 수행하고, 시간을 기록합니다.
테스트에 사용된 코드는 아래와 같습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;script src=&#34;https://gist.github.com/cloudsoswift/c27280e2909126ffa7aa903573b95f98.js&#34;&gt;&lt;/script&gt;
&lt;h3 id=&#34;테스트-결과&#34; &gt;테스트 결과
&lt;span&gt;
    &lt;a href=&#34;#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ea%b2%b0%ea%b3%bc&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;테스트는 Node.js를 통해 2 * 10회,  MS Edge의 DevTools에 있는 Console에서 1 * 10회 진행되었습니다.&lt;/p&gt;
&lt;h4 id=&#34;time-spent-in-nodejs&#34; &gt;Time Spent in &lt;code&gt;Node.js&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#time-spent-in-nodejs&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&#34;test-nodejs-1.png&#34; alt=&#34;&#34;&gt;&lt;/th&gt;
&lt;th&gt;&lt;img src=&#34;test-nodejs-2.png&#34; alt=&#34;&#34;&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;time-nodejs.png&#34; alt=&#34;time-nodejs.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;앞서 찾아보았던 벤치마크들의 데이터&lt;/em&gt;처럼 &lt;strong&gt;3~50% 정도&lt;/strong&gt;의 &lt;strong&gt;시간 차이&lt;/strong&gt;가 발생한 것을 알 수 있었습니다.&lt;/p&gt;
&lt;h4 id=&#34;time-spent-in-ms-edge-devtools&#34; &gt;Time Spent in &lt;code&gt;MS Edge Devtools&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#time-spent-in-ms-edge-devtools&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;test-msedge.png&#34; alt=&#34;test-msedge.png&#34;&gt;
&lt;img src=&#34;time-msedge.png&#34; alt=&#34;time-msedge.png&#34;&gt;
MS Edge의 Devtools의 Console에서 진행한 테스트 역시 &lt;strong&gt;50%가량의 차이&lt;/strong&gt;를 보이고 있음을 알 수 있었습니다.&lt;/p&gt;
&lt;h4 id=&#34;추가-memory-usage-in-nodejs&#34; &gt;추가) Memory Usage in &lt;code&gt;Node.js&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%94%ea%b0%80-memory-usage-in-nodejs&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;memory-nodejs.png&#34; alt=&#34;memory-nodejs.png&#34;&gt;
아무래도 제가 Object를 선택했었던 이유가 &lt;strong&gt;&lt;code&gt;메모리 사용량&lt;/code&gt;에 대한 우려&lt;/strong&gt;였기 때문에, 실제로 둘 간의 메모리 사용량 차이가 어느정도 나는지도 파악하고자 했습니다.&lt;br&gt;
하지만, &lt;code&gt;performance&lt;/code&gt;를 통해 &lt;strong&gt;브라우저에서 측정&lt;/strong&gt;하는 것은 &lt;strong&gt;정확한 데이터가 나오지 않았습니다&lt;/strong&gt;.&lt;br&gt;
(&lt;code&gt;--enable-precise-memory-info&lt;/code&gt; 플래그를 켜고 실행하라는 &lt;a href=&#34;https://trackjs.com/blog/monitoring-javascript-memory/&#34;&gt;조언&lt;/a&gt;대로 했는데도 불구하고 말이죠)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;performance.memory&lt;/code&gt;의 &lt;code&gt;usedJSHeapSize&lt;/code&gt; 변화량을 추적하고자 했으나, 보안상 이슈?로 정확한 값을 브라우저에서 제공하지 않았습니다. (추가로, &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance/memory&#34;&gt;MDN의 API 문서&lt;/a&gt;에 따르면 &lt;code&gt;Deprecated&lt;/code&gt;된 기능이라고 합니다.)&lt;/li&gt;
&lt;li&gt;따라서 &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance/measureUserAgentSpecificMemory&#34;&gt;&lt;code&gt;performance.measureUserAgentSpecificMemory()&lt;/code&gt;&lt;/a&gt; 나, &lt;a href=&#34;https://ui.toast.com/weekly-pick/ko_20200423&#34;&gt;Toast UI 팀 블로그의 글&lt;/a&gt;을 읽고 &lt;code&gt;performance.measureMemory()&lt;/code&gt; 같은 다른 API를 사용하고자 했으나, &lt;code&gt;Experimental&lt;/code&gt; 기능이기 때문인지 사용할 수가 없었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그래서 &lt;code&gt;Node.js&lt;/code&gt;에서라도 메모리 사용량을 측정해보고자 했습니다.&lt;br&gt;
찾아보니, &lt;code&gt;Node.js&lt;/code&gt;에서는 &lt;code&gt;--expose-gc&lt;/code&gt; 플래그를 이용해 사용자가 명시적으로 &lt;code&gt;gc&lt;/code&gt;를 호출하므로써 자동으로 &lt;code&gt;gc&lt;/code&gt;가 발생하는 &lt;strong&gt;텀을 늘려&lt;/strong&gt;, 잦은 gc 발생 없이 &lt;strong&gt;테스트하는 시간동안의 메모리 변동을 측정&lt;/strong&gt;할 수 있다고 하여 해당 방법을 사용했습니다.&lt;br&gt;
그러나 &lt;code&gt;Map&lt;/code&gt;을 테스트할 때 &lt;strong&gt;메모리 사용량 값이 튀는 경우&lt;/strong&gt;가 발생해, 측정한 데이터도 그냥 &amp;lsquo;아 메모리 사용량도 &lt;code&gt;Map&lt;/code&gt;이 &lt;strong&gt;훨씬 적구나&lt;/strong&gt;&amp;rsquo; 정도를 &lt;strong&gt;&lt;code&gt;짐작&lt;/code&gt;&lt;/strong&gt; 하는 용도로만 사용할 수 있을것 같습니다.&lt;/p&gt;
&lt;h2 id=&#34;결론&#34; &gt;결론
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%b0%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;Javascript에서 key를 통해 탐색해야하는 Dictionary 형태의 구조체(&lt;em&gt;중첩된 형태의 구조더라도&lt;/em&gt;)를 사용해야 한다면, &lt;strong&gt;웬만하면 &lt;code&gt;Map&lt;/code&gt;을 쓰는 것이 좋다!&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추가로, V8 엔진에서 사용하는 &lt;code&gt;hashTable&lt;/code&gt;의 구조라던지, V8 소스 코드를 찾아보는 등의 경험을 할 수 있어서 새로웠다!&lt;/li&gt;
&lt;li&gt;나중엔 이런 소스 코드들을 전부 이해하고 나아가 Contribute 할 수 있는 개발자가 될 수 있도록 노력해야겠다!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://262.ecma-international.org/6.0/#sec-map-objects&#34;&gt;ECMAScript 2015 Language Specification – ECMA-262 6th Edition (ecma-international.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://itnext.io/v8-deep-dives-understanding-map-internals-45eb94a183df&#34;&gt;[V8 Deep Dives] Understanding Map Internals | by Andrey Pechkurov | ITNEXT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codereview.chromium.org/220293002/&#34;&gt;Issue 220293002: OrderedHashTable implementation with Set and Map interfaces - Code Review (chromium.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codereview.chromium.org/947683002/#ps200001&#34;&gt;Issue 947683002: Reimplement Maps and Sets in JS - Code Review (chromium.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/map-vs-object-in-javascript/&#34;&gt;Map vs Object in JavaScript - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections&#34;&gt;키 기반 컬렉션 - JavaScript | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/32886522/javascript-objects-vs-map-performance-chrome-v8-node-js&#34;&gt;Javascript Objects vs Map performance (Chrome, V8, Node JS) - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://trackjs.com/blog/monitoring-javascript-memory/&#34;&gt;Monitoring JavaScript Memory - TrackJS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance/measureUserAgentSpecificMemory&#34;&gt;Performance: measureUserAgentSpecificMemory() method - Web APIs | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Performance/memory&#34;&gt;Performance: memory property - Web APIs | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ui.toast.com/weekly-pick/ko_20200423/&#34;&gt;performance.measureMemory()로 웹 페이지 전체 메모리 사용량 모니터링하기 | TOAST UI :: Make Your Web Delicious!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Node.js 스터디 1주차 - Node.js의 Thread에 대하여</title>
      <link>https://cloudsoswift.github.io/post/develop/nodejs/about-thread-of-node-js/</link>
      <pubDate>Fri, 04 Aug 2023 05:16:01 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/nodejs/about-thread-of-node-js/</guid>
      <description>&lt;h1 id=&#34;발단&#34; &gt;발단
&lt;span&gt;
    &lt;a href=&#34;#%eb%b0%9c%eb%8b%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Node.js의 경우 Multi-Thread이지만 하나의 Thread만 유저가 사용가능하게 하고, 나머지는 내부적으로 사용&lt;/li&gt;
&lt;li&gt;최근에는 worker_thread와 같은 기능으로 유저도 Multi-Thread 환경에서 개발할 수 있도록 하는것으로 알고있음.&lt;/li&gt;
&lt;li&gt;여기서 Node.js의 Thread는 어떻게 구성되어 있고, 어떻게 작동하는지, 왜 하나의 Thread만 유저가 사용할 수 있게 한건지, worker_thread 기능은 또 뭔지 궁금해졌음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;궁금한-점&#34; &gt;궁금한 점
&lt;span&gt;
    &lt;a href=&#34;#%ea%b6%81%ea%b8%88%ed%95%9c-%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Node.js의 &lt;strong&gt;Thread 구조&lt;/strong&gt;는 어떻게 될 까?&lt;/li&gt;
&lt;li&gt;Node.js의 &lt;strong&gt;Thread는 어떻게 작동&lt;/strong&gt;할까?&lt;/li&gt;
&lt;li&gt;왜 Node.js는 하나의 Thread만 유저가 사용할 수 있게 한걸까?(&lt;strong&gt;왜 싱글스레드 모델을 선택&lt;/strong&gt;했을까?)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;worker_threads&lt;/strong&gt; 기능은 무엇일까?&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;진행&#34; &gt;진행
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%84%ed%96%89&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;1-nodejs의-thread-구조는-어떻게-될까&#34; &gt;1. Node.js의 Thread 구조는 어떻게 될까?
&lt;span&gt;
    &lt;a href=&#34;#1-nodejs%ec%9d%98-thread-%ea%b5%ac%ec%a1%b0%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%90%a0%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;Node.js는 Event-Driven Architecture를 채용해 &lt;mark style=&#34;background: #FFF3A3A6;&#34;&gt;(1) 오케스트레이션을 위한 Event Loop&lt;/mark&gt;와 &lt;mark style=&#34;background: #FFF3A3A6;&#34;&gt;(2)고비용 작업을 위한 Worker Pool&lt;/mark&gt;을 포함하고 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;event-loop&#34; &gt;Event Loop
&lt;span&gt;
    &lt;a href=&#34;#event-loop&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;main loop, main thread, event thread 라고도 부릅니다.&lt;br&gt;
간단히 말하면 Event에 등록된 Javascript callback 함수를 실행하고, Non-Blocking 비동기 요청(ex. 네트워크 I/O) 역시 처리하는 스레드 입니다.&lt;br&gt;
Node.js 애플리케이션이 시작되면 먼저 초기화 phase를 완료하고, module들을 require하고 Event에 대한 callback들을 등록합니다.&lt;br&gt;
그 다음 Node.js 애플리케이션은 Event Loop에 진입해 들어오는 Client 요청들에 대해 그에 해당하는 callback들을 실행시키므로써 응답합니다. 이러한 callback들은 동기적으로 실행되며, 완료된 후에도 계속 처리하기 위해 비동기 요청들을 등록할 수도 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;worker-poolthread-pool&#34; &gt;Worker Pool(Thread Pool)
&lt;span&gt;
    &lt;a href=&#34;#worker-poolthread-pool&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;Task를 처리하는 Worker로 이루어진 Pool 입니다.&lt;br&gt;
Node.js의 Worker Pool은 &lt;a href=&#34;https://docs.libuv.org/en/v1.x/threadpool.html&#34;&gt;libuv&lt;/a&gt;의 구현체로, libuv는 일반적인 Task Submission API(&lt;code&gt;uv_queue_work&lt;/code&gt;)를 노출하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int uv_queue_work(*loop, *req, work_cb, after_work_cb)&lt;/code&gt; : threadpool의 스레드에서,  &lt;code&gt;work_cb&lt;/code&gt;를 실행하는 작업 request를 initialize 합니다. &lt;code&gt;work_cb&lt;/code&gt;가 완료되고 나면, loop thread에서 &lt;code&gt;after_work_cb&lt;/code&gt;를 호출합니다.&lt;br&gt;
Node.js에서는 Worker Pool을 &lt;strong&gt;&amp;ldquo;비싼&amp;rdquo;&lt;/strong&gt; 작업을 처리하기 위해 사용합니다. &lt;strong&gt;&amp;ldquo;비싼&amp;rdquo;&lt;/strong&gt; 작업으로는 OS단에서 non-blocking 버전을 제공하지 않는 I/O 작업(특히 CPU 집약적인 작업)이 있습니다.&lt;br&gt;
Worker Pool을 사용하는 Node.js Module API는 다음과 같습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;io-집약적인-api&#34; &gt;I/O-집약적인 API
&lt;span&gt;
    &lt;a href=&#34;#io-%ec%a7%91%ec%95%bd%ec%a0%81%ec%9d%b8-api&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/api/dns.html&#34;&gt;DNS&lt;/a&gt; : Node.js에서 Name Resolution을 가능케 해주는 Module로, host name의 IP 주소를 조회하는 등의 작업을 수행할 때 사용할 수 있습니다.&lt;br&gt;
(조회시 항상 DNS 프로토콜을 사용하는 건 아니고, OS 기능을 이용해 이름 확인을 할 수도 있습니다.)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/api/fs.html#fs_threadpool_usage&#34;&gt;File System&lt;/a&gt; : (&lt;code&gt;fs.FSWatcher()&lt;/code&gt;와 명시적으로 동기 방식인 API를 제외한) 대부분의 File System API가 libuv의 threadpool을 사용합니다.
&lt;ul&gt;
&lt;li&gt;참고로 libuv이 제공하는 threadpool은 내부적으로 모든 File System 작업과 &lt;code&gt;getaddrinfo&lt;/code&gt;, &lt;code&gt;getnameinfo&lt;/code&gt;와 같은 요청을 실행하는데 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;cpu-집약적인-api&#34; &gt;CPU-집약적인 API
&lt;span&gt;
    &lt;a href=&#34;#cpu-%ec%a7%91%ec%95%bd%ec%a0%81%ec%9d%b8-api&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/api/crypto.html&#34;&gt;Crypto&lt;/a&gt;: Node.js에서 암호화를 위해 사용하는 Module로, 주로 Hashing같은 고비용 작업을 처리하는데에 libuv의 threadpool을 사용합니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;crypto.pbkdf2()&lt;/code&gt;, &lt;code&gt;crypto.scrypt()&lt;/code&gt;, &lt;code&gt;crypto.randomBytes()&lt;/code&gt;,&lt;br&gt;
&lt;code&gt;crypto.randomFill()&lt;/code&gt;, &lt;code&gt;crypto.generateKeyPair()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/api/zlib.html#zlib_threadpool_usage&#34;&gt;Zlib&lt;/a&gt;: Node.js에서 파일 압축을 위해 사용하는 Module로, 명시적으로 동기적인 몇몇을 제외하면 대부분의 작업이 libuv의 threadpool을 사용합니다.&lt;br&gt;
이러한 API들만이 Worker Pool의 task 원천입니다.&lt;br&gt;
&lt;a href=&#34;https://nodejs.org/api/addons.html&#34;&gt;C++ add-on&lt;/a&gt;을 사용하는 애플리케이션과 모듈은 다른 task들을 Worker Pool에 submit 할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-nodejs의-thread는-어떻게-작동할까&#34; &gt;2. Node.js의 Thread는 어떻게 작동할까?
&lt;span&gt;
    &lt;a href=&#34;#2-nodejs%ec%9d%98-thread%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%ec%9e%91%eb%8f%99%ed%95%a0%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&#34;api-호출과-task-submit&#34; &gt;API 호출과 task submit
&lt;span&gt;
    &lt;a href=&#34;#api-%ed%98%b8%ec%b6%9c%ea%b3%bc-task-submit&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;위에서 언급한 API들 중 하나를 Event Loop의 callback 에서 호출한다면, Event Loop는 해당 API에 대한 Node.js C++ bindings에 들어가 task를 submit할 때 약간의 설정 비용(setup cost)를 지불합니다.&lt;br&gt;
설정 비용들은 task의 전체 비용에 비해 무시할 수 있는 수준이라 Event Loop는 이를 &lt;code&gt;offloading&lt;/code&gt; 합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;offloading&lt;/code&gt;: 리소스 집약적인 컴퓨팅 작업을 하드웨어 가속기와 같은 별도의 프로세서나 클러스터, 그리드 또는 클라우드와 같은 외부 플랫폼으로 전송하는 것.&lt;br&gt;
task를 submit할 때, Node.js는 Node.js C++ bindings 내부의 해당 C++ 함수에 대한 Pointer를 제공합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nodejs가-다음으로-실행할-code를-정하는-방법&#34; &gt;Node.js가 다음으로 실행할 code를 정하는 방법
&lt;span&gt;
    &lt;a href=&#34;#nodejs%ea%b0%80-%eb%8b%a4%ec%9d%8c%ec%9c%bc%eb%a1%9c-%ec%8b%a4%ed%96%89%ed%95%a0-code%eb%a5%bc-%ec%a0%95%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;Event Loop와 Worker Pool은 각각 대기중인 event, 대기중인 task들 위한 Queue를 추상적으로 유지합니다.&lt;br&gt;
&lt;strong&gt;추상적&lt;/strong&gt;이라고 말한 이유는, 사실 Event Loop는 queue를 유지하고 있지 않습니다.&lt;br&gt;
대신 OS에 요청한 file descriptor들의 집합을 갖고 있는데, 이를 통해 OS에 OS별 메커니즘(epoll (linux), kqueue (OSX), event ports (Solaris), IOCP (Windows))을 이용해 모니터링을 요청합니다.&lt;br&gt;
file descriptor로는 &lt;strong&gt;network socket&lt;/strong&gt;, &lt;strong&gt;감시중인 파일&lt;/strong&gt;들이 있습니다.&lt;br&gt;
OS가 이들 중 하나 준비되었다고 말하면, Event Loop는 이를 적절한 Event로 변환하고 해당 Event와 관련된 callback을 호출합니다.&lt;br&gt;
반면 이와 대조적으로 Worker Pool은 실행되어야 하는 Task들에 대한 실제 Queue를 사용합니다. Worker는 queue에서 task를 pop하여 처리한 뒤, task가 완료되면 &lt;em&gt;&amp;ldquo;적어도 하나의 작업이 완료되었음(At least one task is finished)&amp;rdquo;&lt;/em&gt; event를 Event Loop에 발생시킵니다.&lt;/p&gt;
&lt;h3 id=&#34;개발자가-구현시-중요하게-생각해야-할-점&#34; &gt;개발자가 구현시 중요하게 생각해야 할 점
&lt;span&gt;
    &lt;a href=&#34;#%ea%b0%9c%eb%b0%9c%ec%9e%90%ea%b0%80-%ea%b5%ac%ed%98%84%ec%8b%9c-%ec%a4%91%ec%9a%94%ed%95%98%ea%b2%8c-%ec%83%9d%ea%b0%81%ed%95%b4%ec%95%bc-%ed%95%a0-%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;위에서 언급한 (적은 thread로 많은 client를 처리하는)Node.js의 구조상, thread가 어떤 request 때문에 block될 경우 끼치는 피해가 더 막대하므로 공정한 스케줄링(fair scheduling)을 개발자가 보장할 필요가 있게 됩니다.&lt;br&gt;
따라서 개발자는 구현시 requset에 대한 scheduling에 좀 더 신경써야 합니다.&lt;br&gt;
다시 한 번 말하면, 모든 들어오는 요청과 나가는 응답이 Event Loop를 통과하므로 Event Loop가 한 작업에 대해 너무 오래걸리지 않도록, 즉 &lt;strong&gt;Block&lt;/strong&gt;되지 않도록 Javascript callback들이 빠르게 처리되도록 해야합니다.&lt;br&gt;
따라서 개발자는 input에 제한을 걸고, input이 너무 긴 작업은 거절하는 것을 고려해야 합니다.&lt;br&gt;
이를 통해 callback의 복잡성이 크더라도, input을 제한하여 callback이 worst-case 작업시간보다 오래 걸리지 않도록 할 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사실 뒤에 block을 유발할 수 있는 작업들에 대한 내용이 있는데, 이러한 내용은 공식 문서를 정리하는 것만 해도 길어질 것 같아 추후 따로 글을 작성하도록 하겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-nodejs의-싱글-스레드-모델-선택-이유&#34; &gt;3. Node.js의 싱글-스레드 모델 선택 이유
&lt;span&gt;
    &lt;a href=&#34;#3-nodejs%ec%9d%98-%ec%8b%b1%ea%b8%80-%ec%8a%a4%eb%a0%88%eb%93%9c-%eb%aa%a8%eb%8d%b8-%ec%84%a0%ed%83%9d-%ec%9d%b4%ec%9c%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;https://nodejs.org/en/about&#34;&gt;Node.js 공식문서&lt;/a&gt;에 따르면, Node.js는 &lt;em&gt;(싱글 스레드 모델을 선택하므로써)&lt;/em&gt; &lt;strong&gt;현대의 일반적인 동시성 모델들과 달리&lt;/strong&gt;&lt;mark style=&#34;background: #FFF3A3A6;&#34;&gt; 비효율적이고 사용하기 어려운 &amp;lsquo;스레드-기반 네트워킹&amp;rsquo;&lt;/mark&gt;을 피할 수 있으며, lock이 발생하지 않아 사용자들이 dead-lock의 위험으로 부터 자유로울 수 있게 됐다고 말하고 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js에서는 적은 수의 Thread를 사용하므로써, Thread의 Memory, Context Switching으로 인해 발생하는 공간과 시간 Overhead를 줄일 수 있다고 말합니다.&lt;br&gt;
그를 통해 시스템에서는 더 많은 시간과 메모리를 클라이언트들에게 사용할 수 있다는 이점을 얻을 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;영향-받은-모델&#34; &gt;영향 받은 모델
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%81%ed%96%a5-%eb%b0%9b%ec%9d%80-%eb%aa%a8%eb%8d%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;또한 Node.js의 Event Loop Runtime 구조는 Ruby의 &lt;code&gt;Event Machine&lt;/code&gt;과 Python의 &lt;code&gt;Twisted&lt;/code&gt;로 부터 영향을 받았으며, 유사한 설계를 갖고있다고 말합니다.&lt;/p&gt;
&lt;h4 id=&#34;event-machine&#34; &gt;Event Machine
&lt;span&gt;
    &lt;a href=&#34;#event-machine&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;Ruby를 위한 Event-Driven IO 및 경량 동시성 라이브러리로, Node.js, libev와 마찬가지로 &lt;strong&gt;&lt;code&gt;Reactor&lt;/code&gt;&lt;/strong&gt; 패턴을 사용해 Event-Driven I/O를 제공합니다.&lt;br&gt;
Event Machine은 &amp;lsquo;높은 확장성, 성능, 안정성&amp;rsquo; 그리고 &amp;lsquo;개발자가 애플리케이션의 로직에 집중할 수 있도록 하는 API(스레드 네트워크 프로그래밍의 복잡성을 제거한)&amp;rsquo; 이라는 두 핵심 요구사항을 만족하도록 설계되어 있습니다.&lt;br&gt;
정리하자면,  &amp;lsquo;&lt;em&gt;Scalable해서 규모를 증감&lt;/em&gt;시킬 수 있으면서, &lt;strong&gt;Thread에 대해 신경쓰지 않고 개발&lt;/strong&gt;할 수 있는 &lt;strong&gt;동시성을 지닌 API&lt;/strong&gt;를 만들도록 돕는 라이브러리&amp;rsquo; 라고 정리할 수 있을 것 같습니다.&lt;/p&gt;
&lt;h5 id=&#34;reactor-패턴&#34; &gt;&lt;strong&gt;&lt;code&gt;Reactor 패턴&lt;/code&gt;&lt;/strong&gt;
&lt;span&gt;
    &lt;a href=&#34;#reactor-%ed%8c%a8%ed%84%b4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;참고 문서
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf&#34;&gt;Reactor - An Object Behavioral Pattern for Demultiplexing and Dispatching Handles for Synchronous Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Reactor_pattern&#34;&gt;Reactor pattern - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service Handler에 &lt;em&gt;동시에 전달&lt;/em&gt;되는 Request를 처리하기 위한 &lt;strong&gt;Event Handling 패턴&lt;/strong&gt;.&lt;br&gt;
Service Handler는 들어오는 요청을 &lt;strong&gt;역다중화&lt;/strong&gt;(Demultiplex)한 뒤, 관련된 Request Handler(service provider)에게 동기적으로 전송합니다.&lt;br&gt;
모든 Reactor 시스템은 정의대로라면 싱글-스레드이지만, 멀티스레드 환경에서도 존재할 수 있습니다.&lt;br&gt;
애플리케이션 부분 코드를 Reactor 구현과 분리해 코드를 모듈화해 재사용이 가능하다는 장점이 있지만, 제어의 흐름이 역전되어 있어 절차적 패턴(Procedural Pattern)보다 디버깅하기 힘들고 Request Handler 호출이 동기적이라는 점과 Demultiplexer 때문에 최대 동시성이 제한(&lt;em&gt;대칭형 멀티프로세싱 하드웨어에서 특히&lt;/em&gt;) 된다는 한계가 존재합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;역다중화&lt;/strong&gt; : 물리적 장치의 효율성을 높이기 위해 최소한의 물리적 요소를 사용해 최대한 데이터를 전달하는 &lt;strong&gt;다중화(Multiplex)&lt;/strong&gt; 작업을 거쳐 전달받은 데이터를 다시 합치는 작업. &lt;a href=&#34;https://dbehdrhs.tistory.com/98&#34;&gt;#&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Event Demultiplexer의 경우 &lt;code&gt;Handles&lt;/code&gt;에서 발생하는 이벤트를 Block하며, Blocking 없이 Handle에 대한 작업을 시작할 수 있을 때 반환됩니다.&lt;/li&gt;
&lt;li&gt;I/O Event에 대한 일반적인 Demultiplexer는 &lt;code&gt;select&lt;/code&gt;라는, UNIX 및 WIN32 OS에서 제공되는 Event Demultiplexing System Call 입니다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; call은 어떤 handles가 &lt;em&gt;애플리케이션 프로세스를 Block하지 않고&lt;/em&gt; &lt;mark style=&#34;background: #FFF3A3A6;&#34;&gt;동시에&lt;/mark&gt; 작업을 호출할 수 있는지를 나타내는 작업입니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handles&lt;/code&gt; : 일반적으로 OS에서 관리하는 자원을 식별합니다. Logging Server에서 Socket Endpoint를 식별하여, Synchronous Event Demultiplexer가 Endpoint에서 이벤트가 발생할 때 까지 기다리도록 해줍니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;참고할만한 글
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/leveraging-event-multiplexing-even-driven-guillermo-wrba/&#34;&gt;Leveraging Event Multiplexing in Even-Driven Architectures | Guillermo Wrba&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part1&#34;&gt;비동기 서버에서 이벤트 루프를 블록하면 안 되는 이유 1부 - 멀티플렉싱 기반의 다중 접속 서버로 가기까지 (linecorp.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/n_cloudplatform/222189669084&#34;&gt;[네이버클라우드 기술&amp;amp;경험] IO Multip.. : 네이버블로그 (naver.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dbehdrhs.tistory.com/98&#34;&gt;12장 IO 멀티플렉싱(Multiplexing) (tistory.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/what-is-a-demultiplexer/&#34;&gt;What is a demultiplexer ? - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;twisted&#34; &gt;Twisted
&lt;span&gt;
    &lt;a href=&#34;#twisted&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;Python으로 작성된 Event-Driven Networking Engine으로  Event-Driven Web Server는 물론 mail, SSH Client 등을 포함하고 있어 웹 애플리케이션이 구현 가능합니다.&lt;br&gt;
Event Engine과 마찬가지로 &lt;code&gt;Reactor&lt;/code&gt; 패턴이 적용되어 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;참고할만한 글
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&amp;amp;uid=53875&#34;&gt;네트워크 프로그램 개발을 위한 파이썬 프레임워크 – DATA ON-AIR (dataonair.or.kr)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.twisted.org/en/stable/&#34;&gt;Twisted 22.10.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-worker_threads&#34; &gt;4. worker_threads
&lt;span&gt;
    &lt;a href=&#34;#4-worker_threads&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;worker_threads&lt;/code&gt;는 Javascript를 병렬 실행하는 Thread를 사용할 수 있게 해주는 모듈입니다.&lt;br&gt;
Node.js에 내장되어 있는 동기 I/O 작업이 더 효율적이므로 I/O-집약적인 작업보다 CPU-집약적인 연산을 수행하는 Javascript 실행에 더 유용합니다.&lt;br&gt;
&lt;code&gt;isMainThread&lt;/code&gt;, &lt;code&gt;Worker&lt;/code&gt;, &lt;code&gt;parentPort&lt;/code&gt;등을 통해 메인 스레드로 부터 Worker들을 만들고, Worker들이 어떤 작업을 수행할 지를 지정할 수 있습니다.&lt;br&gt;
또한 메인 스레드 &amp;lt;-&amp;gt; Worker 간 &lt;code&gt;message&lt;/code&gt; 이벤트를 발생시키거나, 메시지를 송수신할 port(&lt;code&gt;MessageChannel&lt;/code&gt;)를 만들어 데이터를 주고받을 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;worker_threads 역시 이 문서에서 다루면 너무 길어질 것 같아 추후 따로 글을 작성하겠습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;정리-후기&#34; &gt;정리 후기
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%eb%a6%ac-%ed%9b%84%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;공식 문서를 찾기보다 검색을 먼저 하는 습관이 어느순간부터 들어있었는데, 이번에 여러 공식 문서들을 찾아보며 공식 문서만 잘 찾아봐도 검색할 일이 많이 줄겠다는 생각이 들었다.&lt;/li&gt;
&lt;li&gt;개인적으로 역다중화, 다중화와 같은 개념부터 I/O Blocking, Non-Blocking 등 모르던 개념들을 많이 알게 되어서 나중에 이들에 대해 따로 정리하는 글을 작성해보고 싶어졌다.&lt;/li&gt;
&lt;li&gt;FE만 공부하던 입장에서 이런 동시성 관련된 문제에 공부하니 머리가 많이 깨질것 같지만(&amp;hellip;) 흥미도 많이 생기게 되었다!&lt;/li&gt;
&lt;li&gt;다음 주는 주제를 하나만 잡던가 좀 쉬운걸로 잡아야겠다.. 다른 것들도 하면서 글 정리하려니 한 주 가지고는 택도 없을 것 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;이외-참고한-문서-및-블로그-포스트&#34; &gt;이외 참고한 문서 및 블로그 포스트
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%b4%ec%99%b8-%ec%b0%b8%ea%b3%a0%ed%95%9c-%eb%ac%b8%ec%84%9c-%eb%b0%8f-%eb%b8%94%eb%a1%9c%ea%b7%b8-%ed%8f%ac%ec%8a%a4%ed%8a%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/api/worker_threads.html&#34;&gt;Worker threads | Node.js v20.5.0 Documentation (nodejs.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/docs/guides/dont-block-the-event-loop&#34;&gt;Don&amp;rsquo;t Block the Event Loop (or the Worker Pool) | Node.js (nodejs.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.dev/en/learn/introduction-to-nodejs/&#34;&gt;Introduction to Node.js (nodejs.dev)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick&#34;&gt;The Node.js Event Loop, Timers, and process.nextTick() | Node.js (nodejs.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/leveraging-event-multiplexing-even-driven-guillermo-wrba/&#34;&gt;Leveraging Event Multiplexing in Even-Driven Architectures | LinkedIn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part1&#34;&gt;비동기 서버에서 이벤트 루프를 블록하면 안 되는 이유 1부 - 멀티플렉싱 기반의 다중 접속 서버로 가기까지 (linecorp.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part3&#34;&gt;비동기 서버에서 이벤트 루프를 블록하면 안 되는 이유 3부 - Reactor 패턴과 이벤트 루프 (linecorp.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.naver.com/n_cloudplatform/222189669084&#34;&gt;[네이버클라우드 기술&amp;amp;경험] IO Multiplexing (IO 멀티플렉싱) 기본 개념부터 심화까지 -1부- : 네이버블로그 (naver.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dbehdrhs.tistory.com/98&#34;&gt;12장 IO 멀티플렉싱(Multiplexing) (tistory.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://plummmm.tistory.com/68&#34;&gt;입출력 다중화 (I/O Multiplexing) (tistory.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[Javascript] 순환 참조 (Circular Import)</title>
      <link>https://cloudsoswift.github.io/post/develop/230219/circular_import/</link>
      <pubDate>Sun, 19 Feb 2023 11:22:33 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/230219/circular_import/</guid>
      <description>&lt;p&gt;오늘은 Javascript, Python같은 언어에서 import시 발생할 수 있는 순환 참조 에러에 대한 포스트를 작성하고자 한다.&lt;/p&gt;
&lt;h1 id=&#34;순환-참조&#34; &gt;순환 참조
&lt;span&gt;
    &lt;a href=&#34;#%ec%88%9c%ed%99%98-%ec%b0%b8%ec%a1%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;메모리-관점에서의-순환-참조--in-javascript-&#34; &gt;메모리 관점에서의 순환 참조 ( In Javascript )
&lt;span&gt;
    &lt;a href=&#34;#%eb%a9%94%eb%aa%a8%eb%a6%ac-%ea%b4%80%ec%a0%90%ec%97%90%ec%84%9c%ec%9d%98-%ec%88%9c%ed%99%98-%ec%b0%b8%ec%a1%b0--in-javascript-&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;간단히 요약하자면, 서로 다른 두 객체가 서로를 참조하여, 가비지 컬렉션 알고리즘의 대상에 포함되지 않아 해당 객체들이 불필요해져도 메모리 회수되지 않고 존속하게되는 문제이다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management&#34;&gt;Mozilla Developer Network의 문서&lt;/a&gt;의 예시를 드는게 이해하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;;         &lt;span style=&#34;color:#75715e&#34;&gt;// x는 y를 참조합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;;         &lt;span style=&#34;color:#75715e&#34;&gt;// y는 x를 참조합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;azerty&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;다음 예제에서는 두 객체가 서로 참조하는 속성으로 생성되어 순환 구조를 생성합니다.&lt;br&gt;
함수 호출이 완료되면 이 두 객체는 스코프를 벗어나게 될 것이며, 그 시점에서 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 합니다.&lt;br&gt;
그러나 두 객체가 서로를 참조하고 있으므로, &lt;strong&gt;참조-세기 알고리즘&lt;/strong&gt;은 둘 다 가비지 컬렉션의 대상으로 표시하지 않습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;참조-세기(Reference-counting) 알고리즘&lt;/strong&gt; : 가비지 컬렉션시 사용하는 알고리즘으로, &amp;ldquo;어떤 다른 객체도 참조하지 않는 객체&amp;quot;를 더 이상 필요없는 객체로 인식하고 가비지 컬렉션을 수행.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;import에서의-순환-참조circular-dependencies-in-javascript&#34; &gt;import에서의 순환 참조(Circular Dependencies) (In Javascript)
&lt;span&gt;
    &lt;a href=&#34;#import%ec%97%90%ec%84%9c%ec%9d%98-%ec%88%9c%ed%99%98-%ec%b0%b8%ec%a1%b0circular-dependencies-in-javascript&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2가지 이상의 모듈에서 import가 꼬리의 꼬리를 물어 순환 구조를 이루어 에러가 발생하는 경우.&lt;/li&gt;
&lt;li&gt;예시
&lt;img src=&#34;https://cloudsoswift.github.io/post/develop/230219/circular.png&#34; alt=&#34;circular import&#34;&gt;&lt;/li&gt;
&lt;li&gt;위와 같이 참조의 순환 고리가 발생하게 될 경우, 그 고리의 어느 한 모듈(&lt;em&gt;순환 고리안의 다른 모듈을 참조하는&lt;/em&gt;)을 이용하려 하면&lt;br&gt;
&lt;code&gt;ReferenceError: Cannot access &#39;모듈 이름&#39; before initialization&lt;/code&gt;&lt;br&gt;
라며 에러가 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;나의-사례&#34; &gt;나의 사례
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%98%ec%9d%98-%ec%82%ac%eb%a1%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;본인은 &lt;em&gt;Axios 모듈&lt;/em&gt;, &lt;em&gt;Redux 객체(store)를 export 하는 모듈&lt;/em&gt;, &lt;em&gt;Redux Toolkit의 slice 객체를 export하는 모듈&lt;/em&gt;를 사용하며 React 프로젝트를 개발하고 있었다.&lt;/li&gt;
&lt;li&gt;개발 초-중반기에만 해도 &lt;em&gt;&lt;strong&gt;&amp;lsquo;Redux 객체 -&amp;gt; Redux Toolkit의 Slice 객체&amp;rsquo;&lt;/strong&gt;&lt;/em&gt;, &lt;em&gt;&lt;strong&gt;&amp;lsquo;Slice 객체 -&amp;gt; Axios 모듈&amp;rsquo;&lt;/strong&gt;&lt;/em&gt; 로의 참조 외에는 모듈간의 연관관계가 존재하지 않아 순환 참조가 발생하지 않아 에러가 발생하지 않았다.
&lt;img src=&#34;https://cloudsoswift.github.io/post/develop/230219/before_circular_import.png&#34; alt=&#34;before_circular_import&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;&amp;lsquo;Redux 객체 -&amp;gt; Redux Toolkit의 Slice 객체&amp;rsquo;&lt;/strong&gt;&lt;/em&gt;
&lt;ul&gt;
&lt;li&gt;Redux Toolkit Slice들의 Reducer를 모은 rootReducer를 메인 Redux객체(store)에 할당하기 위해 Slice 객체를 참조.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;&amp;lsquo;Slice 객체 -&amp;gt; Axios 모듈&amp;rsquo;&lt;/strong&gt;&lt;/em&gt;
&lt;ul&gt;
&lt;li&gt;비동기 작업 후 state를 update하는 로직을 위해, Redux 액션 생성함수(Action Creator)를 만들어서 사용하였다.&lt;/li&gt;
&lt;li&gt;이 때, 비동기 작업을 위해 Axios 모듈을 사용했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;사건의-발단&#34; &gt;사건의 발단
&lt;span&gt;
    &lt;a href=&#34;#%ec%82%ac%ea%b1%b4%ec%9d%98-%eb%b0%9c%eb%8b%a8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;그러다 Axios 모듈에 interceptor를 설정해, request를 보내기 전 &amp;lsquo;유저 Slice&amp;rsquo;에 저장된 AccessToken을 불러와 Header에 첨부해주려 했는데 순환 참조 에러가 발생했다.&lt;br&gt;
&lt;code&gt;Uncaught ReferenceError: Cannot access &#39;__WEBPACK_DEFAULT_EXPORT__&#39; before initialization&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;해당 에러를 맞닥들인 당시, 나는 &amp;lsquo;순환 참조&amp;rsquo;라는 개념도 잘 알지 못했고 이러한 행위가 에러를 발생시킨다는 것 역시 알지 못했다.&lt;/li&gt;
&lt;li&gt;그리고 여러 글들을 찾아 보다가, 관련된 &lt;a href=&#34;https://stackoverflow.com/questions/65038253/uncaught-referenceerror-cannot-access-webpack-default-export-before-initi&#34;&gt;stackoverflow 글&lt;/a&gt;을 보고 어느정도 왜 에러를 발생시키는 행위인지 알 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;원인&#34; &gt;원인
&lt;span&gt;
    &lt;a href=&#34;#%ec%9b%90%ec%9d%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;request를 보내기 전에 Redux Store를 확인하고 만약 AccessToken이 존재하면 해당 값 가져와서 &lt;em&gt;Header의 Authorization&lt;/em&gt;으로 설정한 뒤 요청을 보내는 로직을 수행하는 interceptor를 Axios 모듈에다 달아주고 싶었다.&lt;/li&gt;
&lt;li&gt;React에서 자주 쓰던것 처럼, &lt;code&gt;useDispatch()&lt;/code&gt;훅을 통해 dispatch 함수를 반환 받아, Action Creator를 통해 만든 Action을 dispatch하는 방식으로 AccessToken을 가져오는 것이 원래 계획이었다.&lt;/li&gt;
&lt;li&gt;그러나 &lt;em&gt;Axios 모듈&lt;/em&gt;은 React Component가 아니기 때문에, React Component 외부에서는 &lt;em&gt;Redux Store 모듈&lt;/em&gt;을 불러와 Store 객체가 갖고있는 dispatch 함수를 호출해야 했다.&lt;/li&gt;
&lt;li&gt;그래서 &lt;em&gt;Redux Store 모듈&lt;/em&gt;을 불러와 dispatch를 함수를 호출하려 했는데, Redux Store를 불러오는 로직을 추가하니 상기한 내용의 에러를 내놓고 있었다.&lt;/li&gt;
&lt;li&gt;즉, &lt;em&gt;Axios 모듈&lt;/em&gt;에서 &lt;em&gt;Redux Store 모듈&lt;/em&gt;을 import함으로써 아래와 같은 구조가 형성되어 버린것이었다.
&lt;img src=&#34;https://cloudsoswift.github.io/post/develop/230219/after_circular_import.png&#34; alt=&#34;after_circular_import&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;store 객체를 생성하려면 &lt;em&gt;user-slice의 reducer가 필요&lt;/em&gt;해 &lt;em&gt;&lt;strong&gt;user-slice.js를 import&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;user-slice.js 내부에 정의된 Action Creator 함수는 비동기 작업을 처리하기 위해 &lt;em&gt;Axios 모듈이 필요&lt;/em&gt;해 &lt;em&gt;&lt;strong&gt;http.js를 import&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Axios 모듈에서는 store 객체 안에 저장된 AccessToken을 가져오기 위해 &lt;em&gt;store 객체가 필요&lt;/em&gt;해 &lt;em&gt;&lt;strong&gt;store.js를 import&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;해결&#34; &gt;해결?
&lt;span&gt;
    &lt;a href=&#34;#%ed%95%b4%ea%b2%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Action Creator 함수&lt;/em&gt;, Store에 접근하는 &lt;em&gt;interceptor&lt;/em&gt;, Slice들의 reducer를 combine해 사용하는 &lt;em&gt;store 객체&lt;/em&gt; 모두 놓치고 싶지 않았지만, 에러를 해결해야 해 어쩔 수 없이 &lt;em&gt;&lt;strong&gt;Action Creator 함수&lt;/strong&gt;&lt;/em&gt;를 사용하지 않는 방향으로 코드를 수정했다.
&lt;ul&gt;
&lt;li&gt;Axios 모듈을 사용하는 Action Creator 함수로 로그인, 로그아웃이 있었는데, 해당 작업을 각 기능을 사용하는 component(로그인 - 로그인 페이지, 로그아웃 - 네비게이션 바)에서 정의하도록 하여 순환 관계를 끊었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;결론&#34; &gt;결론?
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%b0%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;순환 참조가 발생할 경우, 순환 고리에 포함된 모듈(객체)들은 생성이 안 되어 사용이 불가능하므로 순환 참조가 발생하지 않도록 코드를 짜는것이 중요하다는걸 몇 시간의 실랑이 끝에 알 수 있었다&amp;hellip;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

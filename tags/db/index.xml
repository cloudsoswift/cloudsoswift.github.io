<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DB on 오늘도 개발을 한다.</title>
    <link>https://cloudsoswift.github.io/tags/db/</link>
    <description>오늘도 개발을 한다. (DB)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sat, 14 Sep 2024 20:29:34 +0900</lastBuildDate>
    
    <atom:link href="https://cloudsoswift.github.io/tags/db/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[DB] SQL Injection 알아보기 (w. PreparedStatement, Stored Procedures)</title>
      <link>https://cloudsoswift.github.io/post/develop/database/sql-injection/</link>
      <pubDate>Sat, 14 Sep 2024 20:29:34 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/database/sql-injection/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 9월 4일에 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/04-DATABASE/16_SQL-Injection/Readme.md&#34;&gt;&lt;strong&gt;SQL Injection&lt;/strong&gt;&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;sql-injection에-대해-설명해-주세요&#34; &gt;SQL Injection에 대해 설명해 주세요.
&lt;span&gt;
    &lt;a href=&#34;#sql-injection%ec%97%90-%eb%8c%80%ed%95%b4-%ec%84%a4%eb%aa%85%ed%95%b4-%ec%a3%bc%ec%84%b8%ec%9a%94&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;code&gt;SQL Injection&lt;/code&gt;이란, &lt;em&gt;데이터베이스를 사용하는&lt;/em&gt; 웹 애플리케이션을 공격하는데 사용되는 &lt;code&gt;코드 인젝션 공격 기법&lt;/code&gt;을 말합니다.&lt;br&gt;
주로 공격자가 &lt;code&gt;입력 필드&lt;/code&gt;에 &lt;code&gt;악성 SQL 문&lt;/code&gt;을 삽입해 실행시키는 방식으로 공격하며, &lt;code&gt;데이터베이스의 정보&lt;/code&gt;를 불법적으로 &lt;code&gt;열람&lt;/code&gt; 또는 &lt;code&gt;조작&lt;/code&gt;할 수 있는 취약점입니다.&lt;br&gt;
&lt;code&gt;Injection&lt;/code&gt; 공격은 오픈소스 웹 애플리케이션 보안 프로젝트인 &lt;a href=&#34;https://owasp.org/&#34;&gt;OWASP&lt;/a&gt;에서 매년 &lt;a href=&#34;https://owasp.org/www-project-top-ten/&#34;&gt;상위 10대 취약점&lt;/a&gt;에서 근 20년간 상위권을 차지하고 있으며, 단순히 신원 위조, 기존 데이터 변조와 같은 공격 뿐만 아니라 관리자 탈취, 데이터 삭제, 시스템 데이터 공개와 같이 &lt;code&gt;시스템에 치명적인 공격&lt;/code&gt;을 불러올 수 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;공격-유형&#34; &gt;공격 유형
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%b5%ea%b2%a9-%ec%9c%a0%ed%98%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;SQL Injection&lt;/code&gt;은 기본적으로 &lt;code&gt;데이터 입력&lt;/code&gt; 란에 &lt;code&gt;메타 문자&lt;/code&gt;(&lt;code&gt;&#39;&#39;&lt;/code&gt;, &lt;code&gt;OR&lt;/code&gt; 등 SQL문을 이루는 문자들)를 삽입해 기존에 존재하지 않던 SQL 명령을 &lt;code&gt;제어 영역(control plane, SQL 명령어 및 관련 구조가 위치하는 영역. ~= user input)&lt;/code&gt;에 배치하는 방식으로 이뤄집니다.&lt;br&gt;
이러한 구조적 결함은 SQL이 &lt;code&gt;제어 영역&lt;/code&gt;과 &lt;code&gt;데이터 영역(data plane, 실제 데이터 값이 위치하는 영역. ~= SQL Query)&lt;/code&gt;을 구분하지 않고, 단순히 문자열로 된 명령을 실행한다는 점에서 기인합니다.&lt;br&gt;
&lt;code&gt;SQL Injection&lt;/code&gt;은 크게 아래 3가지 유형으로 구분됩니다.&lt;/p&gt;
&lt;h4 id=&#34;에러-기반-sql-인젝션error-based-sql-injection&#34; &gt;에러 기반 SQL 인젝션(Error-based SQL Injection)
&lt;span&gt;
    &lt;a href=&#34;#%ec%97%90%eb%9f%ac-%ea%b8%b0%eb%b0%98-sql-%ec%9d%b8%ec%a0%9d%ec%85%98error-based-sql-injection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;에러 기반 SQL 인젝션&lt;/code&gt;은 데이터베이스 서버에서 발생한 &lt;code&gt;오류 메세지&lt;/code&gt;를 바탕으로 현재 API가 &lt;code&gt;어떤 SQL 명령&lt;/code&gt;을 호출하는지, &lt;code&gt;데이터베이스 구조&lt;/code&gt;는 어떤지 등의 &lt;code&gt;정보&lt;/code&gt;를 얻어내 공격하는 기법입니다.&lt;br&gt;
이는 공격당하는 &lt;code&gt;웹 애플리케이션&lt;/code&gt; 서버가 &lt;em&gt;SQL 쿼리 수행시 발생한&lt;/em&gt; &lt;code&gt;오류&lt;/code&gt;를 &lt;code&gt;HTTP 응답&lt;/code&gt;으로 &lt;code&gt;반환&lt;/code&gt;하도록 동작하는 경우 가능한 공격입니다.&lt;/p&gt;
&lt;h5 id=&#34;예시&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;error-based-form.png&#34; alt=&#34;error-based-form.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 입력 폼으로 아이디, 비밀번호를 입력받아 로그인을 수행하는 웹 애플리케이션이 있다고 가정하겠습니다.&lt;br&gt;
위 애플리케이션이 구동되는 Spring 서버에서는 DB에서 일치하는 유저를 불러오기 위해 다음과 같은 코드가 동작하게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Statement st &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; conn&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;createStatement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	ResultSet rs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; st&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;executeQuery&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SELECT * FROM member WHERE userid = &amp;#39;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ID &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#39; AND userpw =&amp;#39;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; PW &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#39;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;즉, DB에서는 다음과 같은 SQL문이 동작하게 될 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; member &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; userid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$ID&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; userpw &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$PW&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이때, pw에 &lt;code&gt;&#39;OR 1=1 --&lt;/code&gt;를 입력하거나 &lt;code&gt;extractvalue()&lt;/code&gt; 함수 등을 사용해 DB 정보를 탈취할 수 있습니다.&lt;br&gt;
&lt;code&gt;OR 1=1 --&lt;/code&gt;는 &lt;code&gt;WHERE&lt;/code&gt; 절의 조건을 항상 참이 되도록 하고, 이어지는 조건들을 &lt;code&gt;--&lt;/code&gt;를 통해 &lt;code&gt;주석 처리&lt;/code&gt;하게 됩니다. 따라서 id에 (실제 서비스에 가입된) id중 어떤 것을 입력해도 로그인할 수 있게 됩니다.&lt;br&gt;
&lt;code&gt;extractvalue(xml_frag, xpath_expr)&lt;/code&gt; 함수의 경우 &lt;code&gt;XML&lt;/code&gt;과 &lt;code&gt;XPath 표현식&lt;/code&gt;을 인자로 받아, &lt;code&gt;XML&lt;/code&gt;에서 &lt;code&gt;XPath 표현식&lt;/code&gt;에 일치하는 데이터를 추출 및 반환하는 함수입니다.&lt;br&gt;
이때, &lt;code&gt;두 번째 인수&lt;/code&gt;에 유효하지 않은 XPath 표현식이 사용될 경우 &lt;code&gt;XPATH syntax error&lt;/code&gt;를 통해 해당 인수 값을 &lt;code&gt;출력&lt;/code&gt;하게 되는데, 이것이 &lt;code&gt;SQL 쿼리&lt;/code&gt;일 경우 &lt;code&gt;실행 결과를 에러 메시지에 포함&lt;/code&gt;한다는 점을 활용해 공격에 사용됩니다.&lt;br&gt;
따라서 두 번째 인수에 콜론(&lt;code&gt;&#39;:&#39;&lt;/code&gt; 또는 &lt;code&gt;0x3a&lt;/code&gt;(16진수 표현)을 사용)을 맨 앞에 추가하므로써 항상 유효하지 않은 &lt;code&gt;XPath 표현식&lt;/code&gt;을 만들고, &lt;code&gt;concat()&lt;/code&gt;으로 뒤에 실제 실행할 &lt;code&gt;SQL 쿼리&lt;/code&gt;를 넘겨 정보 탈취를 시도합니다.&lt;br&gt;
가령 PW에 &lt;code&gt;&#39; AND extractvalue(rand(),concat(0x3a,version()))--&lt;/code&gt; 라는 구문을 넣게 된다면 실제 SQL 쿼리 문은 다음과 같게 될것입니다. (&lt;code&gt;version()&lt;/code&gt;은 현재 MySQL 버전을 반환하는 함수입니다.)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; member &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; userid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; userpw &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; extractvalue(rand(),concat(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;x3a,&lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt;()))&lt;span style=&#34;color:#75715e&#34;&gt;--&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이를 실행하면 아래 그림처럼 서버의 MySQL 버전을 &lt;code&gt;에러와 함께 반환&lt;/code&gt;하게 됩니다.&lt;br&gt;
&lt;img src=&#34;error-alert.png&#34; alt=&#34;error-alert.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이를 통해 공격자는 &lt;code&gt;DB 버전&lt;/code&gt;, &lt;code&gt;DB 명&lt;/code&gt;, &lt;code&gt;테이블 명&lt;/code&gt;, &lt;code&gt;컬럼 명&lt;/code&gt; 등 다양한 데이터들을 추출할 수 있게 됩니다.&lt;/p&gt;
&lt;h4 id=&#34;union-기반-sql-인젝션union-based-sql-injection&#34; &gt;UNION 기반 SQL 인젝션(Union-based SQL Injection)
&lt;span&gt;
    &lt;a href=&#34;#union-%ea%b8%b0%eb%b0%98-sql-%ec%9d%b8%ec%a0%9d%ec%85%98union-based-sql-injection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;UNION 기반 SQL 인젝션&lt;/code&gt;은 웹 애플리케이션이 &lt;code&gt;DB 질의한 결과&lt;/code&gt;를 &lt;code&gt;HTTP 응답&lt;/code&gt;에 포함해 반환하는 경우, &lt;code&gt;SQL&lt;/code&gt;문을 조작하여 &lt;code&gt;DB 구조 및 데이터&lt;/code&gt;를 &lt;code&gt;탈취&lt;/code&gt;하는 공격 기법입니다.&lt;br&gt;
이때, &lt;em&gt;원래 애플리케이션이 반환할 데이터는 필요하지 않으므로&lt;/em&gt; &lt;code&gt;음수 값&lt;/code&gt;과 같이 DB에 존재하지 않을만한 값을 &lt;code&gt;입력 값으로 전달&lt;/code&gt;하고, 이후 &lt;code&gt;UNION&lt;/code&gt; 또는 &lt;code&gt;UNION ALL&lt;/code&gt;을 이용해 DB의 다른 데이터 값을 추출하는 &lt;code&gt;SQL 쿼리를 덧붙여&lt;/code&gt; 서버에 전달하게 됩니다.&lt;/p&gt;
&lt;h5 id=&#34;union과-union-all&#34; &gt;&lt;code&gt;UNION&lt;/code&gt;과 &lt;code&gt;UNION ALL&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#union%ea%b3%bc-union-all&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;UNION&lt;/code&gt;과 &lt;code&gt;UNION ALL&lt;/code&gt;은 &lt;strong&gt;두 개 이상&lt;/strong&gt;의 &lt;code&gt;SELECT 쿼리 결과&lt;/code&gt;를 하나로 합쳐주는 집합 연산자로, 이때 합쳐질 쿼리들은 다음 조건을 만족해야 합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각 쿼리들은 &lt;code&gt;SELECT&lt;/code&gt;절에서 &lt;code&gt;동일한 갯수&lt;/code&gt;의 &lt;code&gt;열&lt;/code&gt;을 사용해야 한다.&lt;/li&gt;
&lt;li&gt;각 쿼리에서 &lt;code&gt;동일한 순서의 컬럼들&lt;/code&gt;은 서로 호환되는 자료형을 가져야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;또한, &lt;code&gt;UNION&lt;/code&gt;은 쿼리 결과값 통합시 중&lt;code&gt;복된 레코드를 제거&lt;/code&gt;하는 반면, &lt;code&gt;UNION ALL&lt;/code&gt;은 &lt;em&gt;중복 제거 절차 없이&lt;/em&gt; &lt;code&gt;모든 레코드들을 반환&lt;/code&gt;한다는 차이가 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;예시-1&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;쇼핑몰 웹 애플리케이션에서 물품의 ID를 사용자로 부터 입력받으면, 해당 물품의 &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;이름&lt;/code&gt;, &lt;code&gt;가격&lt;/code&gt;을 조회하는 API가 있다고 가정하겠습니다.&lt;br&gt;
해당 API가 DB에 요청할 SQL 쿼리는 다음과 같을 것입니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; item_id, item_name, item_price 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; item 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; item_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$item_id&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;또한, 해당 API는 HTTP 응답으로 이름과 가격, 즉 &lt;code&gt;item_name&lt;/code&gt;, &lt;code&gt;item_price&lt;/code&gt;를 반환합니다.&lt;/p&gt;
&lt;p&gt;이러한 상황에서 ID로 &lt;code&gt;-99 UNION ALL SELECT version(), database(), 2--&lt;/code&gt;를 전달한다면 SQL 쿼리는 다음과 같이 바뀌게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; item_id, item_name, item_price 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; item 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; item_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;99&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;UNION&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ALL&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt;(), &lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;(), &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;당연히 상품 ID가 음수인 상품은 존재하지 않을 것이므로 상품 데이터는 전혀 반환되지 않고 &lt;code&gt;UNION&lt;/code&gt;으로 결합한 &lt;code&gt;SELECT&lt;/code&gt; 쿼리에 포함된 &lt;code&gt;SQL 서버 버전&lt;/code&gt;, &lt;code&gt;DB명&lt;/code&gt;, &lt;code&gt;숫자(컬럼 갯수 및 타입을 맞추기 위한 임의 값)&lt;/code&gt;를 반환하게 됩니다.&lt;/p&gt;
&lt;h5 id=&#34;열-갯수-알아내기&#34; &gt;열 갯수 알아내기
&lt;span&gt;
    &lt;a href=&#34;#%ec%97%b4-%ea%b0%af%ec%88%98-%ec%95%8c%ec%95%84%eb%82%b4%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;그리고 &lt;code&gt;UNION&lt;/code&gt;에서 열의 갯수를 맞춰야 하는 조건 때문에, 현재 쿼리의 컬럼 갯수를 알아야 할 수 있습니다.&lt;br&gt;
이때 &lt;code&gt;ORDER BY&lt;/code&gt; 절을 활용하면, 원래의 &lt;code&gt;SQL 쿼리&lt;/code&gt;의 열 갯수를 알아낼 수 있습니다.&lt;br&gt;
&lt;code&gt;ORDER BY&lt;/code&gt; 절에서 정렬 기준 컬럼을 지정할 때, 열 이름을 직접 기입할 수도 있지만 &lt;code&gt;해당 컬럼의 순번&lt;/code&gt;을 기입할 수도 있습니다.&lt;br&gt;
즉, 위 케이스의 경우 &lt;code&gt;ORDER BY 3&lt;/code&gt;을 기입하면 &lt;code&gt;SQL 쿼리&lt;/code&gt;의 세 번째 컬럼인 &lt;code&gt;item_price&lt;/code&gt;를 기준으로 정렬하게 됩니다.&lt;br&gt;
이러한 순번은 &lt;code&gt;SQL 쿼리가 불러올 컬럼 갯수&lt;/code&gt;만큼 배정되므로 &lt;code&gt;해당 갯수 이상의 숫자&lt;/code&gt;를 기입하게 되면 다음과 같은 &lt;code&gt;오류가 발생&lt;/code&gt;하게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;union-alert.png&#34; alt=&#34;union-alert.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;따라서 &lt;code&gt;ORDER BY&lt;/code&gt; 문에 기입할 순번을 하나씩 &lt;code&gt;차례대로 증가&lt;/code&gt;시키다가 &lt;code&gt;DB에서 오류가 발생&lt;/code&gt;하거나 &lt;code&gt;비정상 응답을 반환&lt;/code&gt;하게 되면, 바로 전의 순번이 원래의 SQL문의 &lt;code&gt;컬럼 갯수&lt;/code&gt;와 같게되는 것입니다.&lt;/p&gt;
&lt;h4 id=&#34;블라인드-sql-인젝션blind-sql-injection&#34; &gt;블라인드 SQL 인젝션(Blind SQL Injection)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b8%94%eb%9d%bc%ec%9d%b8%eb%93%9c-sql-%ec%9d%b8%ec%a0%9d%ec%85%98blind-sql-injection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;블라인드 SQL 인젝션&lt;/code&gt;은 &lt;em&gt;상기한 SQL 인젝션들과 달리&lt;/em&gt;, 웹 애플리케이션이 &lt;code&gt;HTTP 응답&lt;/code&gt;에 &lt;code&gt;DB 오류 메시지&lt;/code&gt;나 &lt;code&gt;데이터&lt;/code&gt;를 포함하지 않을때 사용할 수 있는 공격 기법입니다.&lt;br&gt;
즉, &lt;em&gt;서버의 직접적인 응답 대신&lt;/em&gt; &lt;code&gt;알고싶은 정보가 포함된 특정 조건&lt;/code&gt;을 SQL 쿼리에 포함시켰을때 &lt;code&gt;HTTP 응답&lt;/code&gt;의 &lt;code&gt;상태&lt;/code&gt;가 달라지거나, &lt;code&gt;응답에 걸리는 시간&lt;/code&gt;의 차이를 통해 해당 조건이 &lt;code&gt;참인지 거짓인지&lt;/code&gt; 알아내므로써 데이터베이스 내 &lt;code&gt;정보를 유추&lt;/code&gt;하는 공격 기법입니다.&lt;br&gt;
크게 응답의 차이를 통해 유추하는 &lt;code&gt;불린 기반&lt;/code&gt; 방식과 서버의 응답 시간 차이를 통해 유추하는 &lt;code&gt;시간 기반&lt;/code&gt; 방식이 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;블라인드-불린-기반-sql-인젝션blind-boolean-based-sql-injection&#34; &gt;블라인드 불린 기반 SQL 인젝션(Blind Boolean-Based SQL Injection)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b8%94%eb%9d%bc%ec%9d%b8%eb%93%9c-%eb%b6%88%eb%a6%b0-%ea%b8%b0%eb%b0%98-sql-%ec%9d%b8%ec%a0%9d%ec%85%98blind-boolean-based-sql-injection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;블라인드 불린 기반 SQL 인젝션&lt;/code&gt;은 &lt;code&gt;SQL 쿼리&lt;/code&gt;의 &lt;code&gt;참/거짓&lt;/code&gt;여부에 따른  &lt;code&gt;HTTP 응답 내용&lt;/code&gt;, &lt;code&gt;상태 코드&lt;/code&gt; 등의 &lt;code&gt;차이가 존재&lt;/code&gt;할 때 이를 통해 &lt;code&gt;정보를 유추&lt;/code&gt;할 수 있는 공격 기법입니다.&lt;/p&gt;
&lt;h6 id=&#34;예시-2&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-2&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;게시판 애플리케이션에서 게시글 id를 URL 인자로 받아 게시물을 불러오는 API를 예시로 들어보겠습니다. 해당 API는 다음과 같은 SQL 쿼리를 요청합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; subject, content, author  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; board  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;$id&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;만약 올바른 게시글 id를 전달받았다면 정상적으로 해당 게시글을 가져올 것이고, 그렇지 않다면 아무것도 반환하지 않을 것입니다.&lt;br&gt;
예를 들어 id를 &lt;code&gt;1 AND 1=0--&lt;/code&gt; 로 넘겼다면 SQL문은 다음과 같게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; subject, content, author  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; board  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;우리가 넘긴 &lt;code&gt;AND 1=0&lt;/code&gt; 조건 때문에 게시물 조회 &lt;code&gt;SQL 쿼리&lt;/code&gt;는 거짓이 되어 아무 것도 불러올 수 없을 것입니다. 반면 &lt;code&gt;1 AND 1=1 --&lt;/code&gt;을 넘겼다면 정상적으로 게시물을 조회해올 것입니다.&lt;br&gt;
이를 바탕으로 데이터베이스의 이름을 알아내고 싶다고 가정해보겠습니다.&lt;br&gt;
그렇다면 먼저 DB 이름의 길이를 알아내야 하므로, SQL의 &lt;code&gt;LENGTH()&lt;/code&gt;을 활용합니다.&lt;br&gt;
id로 &lt;code&gt;1 AND LENGTH(database()) = 1 --&lt;/code&gt;, &lt;code&gt;1 AND LENGTH(database()) = 2 --&lt;/code&gt;, &amp;hellip; 처럼 점점 값을 증가시키며 응답이 정상적으로 반환될 때 까지 반복합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LENGTH&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:거짓)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LENGTH&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:거짓)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;LENGTH&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:참) &amp;lt;- 현재 DB의 이름의 길이는 3임
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이후 한글자 한글자씩 비교하며 DB 이름의 각 자리가 무엇인지 확인합니다. 이때 &lt;code&gt;SUBSTRING()&lt;/code&gt; 함수를 활용합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUBSTRING&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;(), &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:거짓)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUBSTRING&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;(), &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:거짓)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SUBSTRING&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;(), &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:참) &amp;lt;- 현재 DB의 이름의 첫 글자는 &amp;#39;c&amp;#39;임
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이를 반복해 알아낸 각 자리의 문자들을 결합하면 DB의 이름을 알아낼 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;블라인드-시간-기반-sql-인젝션blind-time-based-sql-injection&#34; &gt;블라인드 시간 기반 SQL 인젝션(Blind Time-Based SQL Injection)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b8%94%eb%9d%bc%ec%9d%b8%eb%93%9c-%ec%8b%9c%ea%b0%84-%ea%b8%b0%eb%b0%98-sql-%ec%9d%b8%ec%a0%9d%ec%85%98blind-time-based-sql-injection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;블라인드 불린 기반 SQL 인젝션&lt;/code&gt;은 &lt;code&gt;SQL 쿼리&lt;/code&gt;의 &lt;code&gt;참/거짓&lt;/code&gt;여부에 따른  &lt;code&gt;HTTP 응답 내용&lt;/code&gt;, &lt;code&gt;상태 코드&lt;/code&gt; 등의 차이가 존재를 &lt;code&gt;확인할 수 없지만&lt;/code&gt;, 서버 응답 시간을 제어할 수 있을 경우 사용 가능한 공격 기법입니다.&lt;br&gt;
즉, 기존 &lt;code&gt;SQL 쿼리&lt;/code&gt;에 &lt;code&gt;특정 조건&lt;/code&gt;이 참일 경우 &lt;code&gt;응답을 지연시키는 함수&lt;/code&gt;를 사용해 해당 조건의 참/거짓 여부를 판별하게 됩니다.&lt;br&gt;
응답 시간을 제어하는 함수는 DBMS별로 상이하며, 예시로 들 &lt;code&gt;MySQL&lt;/code&gt;(및 &lt;code&gt;MariaDB&lt;/code&gt;)의 경우 &lt;code&gt;sleep()&lt;/code&gt; 함수를 사용합니다.&lt;/p&gt;
&lt;h6 id=&#34;예시-3&#34; &gt;예시
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%88%ec%8b%9c-3&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;위와 마찬가지로 게시판 애플리케이션에서 게시물 조회 API를 사용한다고 가정하겠습니다.&lt;br&gt;
이때 id로 &lt;code&gt;1 AND if(1=1, sleep(5), false)--&lt;/code&gt; 와 같은 구문을 전달했을 때 기존 &lt;code&gt;SQL 쿼리&lt;/code&gt;에 정상적으로 포함된다면, SQL문은 다음과 같게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; subject, content, author  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; board  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; id&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)&lt;span style=&#34;color:#75715e&#34;&gt;--
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;이때 if문이 동작하기 때문에 첫 번째 인자로 주어진 조건식인 &lt;code&gt;1=1&lt;/code&gt;이 참이므로, 서버는 &lt;code&gt;5초간 대기&lt;/code&gt; 상태에 있다가 응답하게 될 것입니다.&lt;br&gt;
이를 바탕으로 &lt;em&gt;불린 기반 공격 처럼&lt;/em&gt;, 조건문에 &lt;code&gt;원하는 정보에 대한 조건&lt;/code&gt;을 포함해 API 요청을 반복하므로써 원하는 정보를 알아낼 수 있습니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;LENGTH&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:거짓)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;LENGTH&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:거짓)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;LENGTH&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;), &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;)&lt;span style=&#34;color:#75715e&#34;&gt;--+                (결과:참) &amp;lt;- 현재 DB의 이름의 길이는 3임
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;방어법-httpscheatsheetseriesowasporgcheatsheetssql_injection_prevention_cheat_sheethtml&#34; &gt;방어법 &lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html&#34;&gt;#&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#%eb%b0%a9%ec%96%b4%eb%b2%95-httpscheatsheetseriesowasporgcheatsheetssql_injection_prevention_cheat_sheethtml&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;이러한 &lt;code&gt;SQL 인젝션&lt;/code&gt;을 방지하기 위해서는 ① &lt;code&gt;문자열들을 연결&lt;/code&gt;해 &lt;code&gt;동적 SQL 쿼리&lt;/code&gt;를 &lt;code&gt;생성하지 않거나&lt;/code&gt;, ② 실행된 쿼리에 &lt;code&gt;악성 SQL 입력&lt;/code&gt;이 &lt;code&gt;포함되지 않도록&lt;/code&gt; 해야 합니다.&lt;/p&gt;
&lt;h4 id=&#34;prepared-statement-사용하기&#34; &gt;Prepared Statement 사용하기
&lt;span&gt;
    &lt;a href=&#34;#prepared-statement-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;준비된 구문(Prepared Statement)&lt;/code&gt;, 또는 &lt;code&gt;파라미터화 된 쿼리(Parameterized Query)&lt;/code&gt;를 사용하게 되면 &lt;code&gt;동적 쿼리&lt;/code&gt;보다 쿼리를 작성 및 이해하는데 쉬우며, 개발자가 먼저 SQL 쿼리를 정의한 뒤 이후에 각 매개변수들을 쿼리에 전달하도록 합니다.&lt;br&gt;
또한 DB 쿼리가 이러한 형태를 띄는 경우 DB는 사용자 입력에 상관없이 항상 코드와 데이터를 구분합니다. 그리고 공격자가 SQL 명령을 삽입해도 쿼리의 원래 의도를 변경할 수 없도록 보장합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 코드 예시
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 매개변수로 사용될 해당 인자는 꼭 검증하는 것이 좋습니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;String custname &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getParameter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;customerName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String query &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;SELECT account_balance FROM user_data WHERE user_name = ? &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PreparedStatement pstmt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; connection&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;prepareStatement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; query &lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;pstmt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setString&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; custname&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ResultSet results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pstmt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;executeQuery&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Java의 &lt;code&gt;PreparedStatement&lt;/code&gt;, C# .NET의 &lt;code&gt;OleDbCommand&lt;/code&gt; 등이 이를 구현하고 있으며 이외에도 Ruby, PHP, Perl 등 다양한 언어에 &lt;code&gt;Prepared Statement&lt;/code&gt; 구현체가 존재합니다.&lt;br&gt;
또한 &lt;code&gt;SQL 인젝션&lt;/code&gt;과 유사한 &lt;code&gt;HQL 인젝션&lt;/code&gt;이 존재하는 SQL 추상화 계층인 &lt;code&gt;HQL(Hibernate Query Language)&lt;/code&gt;에도 &lt;code&gt;Prepared Statement&lt;/code&gt; 형태의 구현체가 존재합니다.&lt;/p&gt;
&lt;h4 id=&#34;stored-procedures-사용하기&#34; &gt;Stored Procedures 사용하기
&lt;span&gt;
    &lt;a href=&#34;#stored-procedures-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;저장 프로시저 (Stored procedure)&lt;/code&gt;란 DBMS에 저장되어 재사용 및 공유할 수 있는 일련의 &lt;code&gt;SQL 쿼리 집합&lt;/code&gt;입니다.&lt;br&gt;
&lt;code&gt;Stored Procedure&lt;/code&gt;가 항상 &lt;code&gt;SQL 인젝션&lt;/code&gt;으로 부터 안전하지 않지만, 특정 표준 &lt;code&gt;Stored Procedure&lt;/code&gt;를 사용하면 &lt;code&gt;Parameterized Query&lt;/code&gt;를 사용하는 것과 동일한 효과를 갖게 됩니다.&lt;br&gt;
다만, &lt;code&gt;Stored Procedure&lt;/code&gt;를 사용할 경우 오히려 시스템이 노출될 경우의 위험을 증가시킬 수 있습니다.&lt;br&gt;
가령 &lt;code&gt;db_datareader&lt;/code&gt;, &lt;code&gt;db_datawriter&lt;/code&gt;, &lt;code&gt;db_owner&lt;/code&gt;세 가지 기본 역할이 존재하는 &lt;code&gt;MS SQL Server&lt;/code&gt;에서는 &lt;code&gt;Stored Procedure&lt;/code&gt; 실행을 위해 &lt;code&gt;실행 권한(Execute right)&lt;/code&gt;이 필요하며, 만약 이 세가지 역할만 사용하는 서비스라면 웹앱이 &lt;code&gt;db_owner&lt;/code&gt; 역할로 실행되어야 &lt;code&gt;Stored Procedure&lt;/code&gt;를 사용할 수 있게 됩니다.&lt;br&gt;
따라서 사용자에게 읽기 접근 권한만 할당하기 위해 &lt;code&gt;db_datareader&lt;/code&gt; 역할을 할당하는게 불가능해지며, 공격자는 DB에 대한 모든 권한을 얻게 됩니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String custname &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; request&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;getParameter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;customerName&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Stored Procedure를 호출할 때, 매개변수들을 인자로 전달한다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  CallableStatement cs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; connection&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;prepareCall&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{call sp_getAccountBalance(?)}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;setString&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; custname&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ResultSet results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;executeQuery&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// … result set handling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;SQLException se&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// … logging and error handling
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;입력-허용-목록을-통한-유효성-검사&#34; &gt;입력 허용 목록을 통한 유효성 검사
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%85%eb%a0%a5-%ed%97%88%ec%9a%a9-%eb%aa%a9%eb%a1%9d%ec%9d%84-%ed%86%b5%ed%95%9c-%ec%9c%a0%ed%9a%a8%ec%84%b1-%ea%b2%80%ec%82%ac&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;만약 사용자 입력에 의해 변경될 값이 &lt;code&gt;테이블 이름&lt;/code&gt;, &lt;code&gt;컬럼 명&lt;/code&gt; 처럼 &lt;code&gt;바인드 변수&lt;/code&gt;를 할당할 수 없는 위치라면 쿼리를 재설계 하거나, 설명할 &lt;code&gt;입력 유효성 검사&lt;/code&gt;를 수행하는 것이 알맞은 방어책 입니다.&lt;br&gt;
이때, &lt;code&gt;테이블&lt;/code&gt; 또는 &lt;code&gt;컬럼 명&lt;/code&gt;을 사용자 매개변수 값을 통해 전달 받을 경우, 해당 값이 다른 테이블의 다른 컬럼을 이름을 가질 수도 있습니다.&lt;br&gt;
이러한 경우 근본적으로 이를 막도록 &lt;code&gt;코드를 재작성&lt;/code&gt; 하는것이 좋지만, 이는 현실적으로 쉽지 않습니다.
따라서 사용자 매개변수를 &lt;code&gt;예상 가능한 테이블&lt;/code&gt;에 매핑하여 &lt;code&gt;유효하지 않은 사용자 입력&lt;/code&gt;이 쿼리에 &lt;code&gt;포함되는 것을 막아야&lt;/code&gt; 합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String tableName&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 사용자 매개변수 값에 따라 tableName을 코드에서 지정합니다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;PARAM&lt;span style=&#34;color:#f92672&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; tableName &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fooTable&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Value2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; tableName &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;barTable&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                 &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; InputValidationException&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unexpected value provided&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                                  &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; for table name&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;추가로, 꼭 동적 쿼리를 사용해야 한다면 동적 쿼리에 SQL 구문을 삽입할 수 없도록 &lt;code&gt;API&lt;/code&gt; 또는 &lt;code&gt;StoredProcedure&lt;/code&gt;의 매개변수를 가능한 문자열이 아닌 타입으로 받는것이 좋습니다.&lt;br&gt;
즉, 예를 들어 &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt; 등으로 받게 된다면 안전하게 사용자로부터 입력을 받는것이 가능합니다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;String&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;someMethod&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;sortOrder&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;String&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;SQLquery&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;some SQL ... order by Salary &amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;sortOrder&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ASC&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DESC&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;`&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/types-of-sql-injection-sqli/&#34;&gt;Types of SQL Injection (SQLi) - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://brightsec.com/blog/sql-injection-attack/&#34;&gt;SQL Injection Attack: How It Works, Examples and Prevention (brightsec.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Glossary/SQL_Injection&#34;&gt;SQL 인젝션 (SQL Injection) - MDN Web Docs 용어 사전: 웹 용어 정의 | MDN (mozilla.org)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html&#34;&gt;SQL Injection Prevention - OWASP Cheat Sheet Series&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.invicti.com/blog/web-security/sql-injection-cheat-sheet/&#34;&gt;SQL Injection Cheat Sheet | Invicti&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://owasp.org/www-community/attacks/SQL_Injection&#34;&gt;SQL Injection | OWASP Foundation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://owasp.org/www-community/attacks/Blind_SQL_Injection&#34;&gt;Blind SQL Injection | OWASP Foundation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.boannews.com/media/view.asp?idx=128286&amp;amp;page=1&amp;amp;mkind=&amp;amp;kind=5&amp;amp;skind=J&amp;amp;search=title&amp;amp;find=&#34;&gt;[카드뉴스] ‘오래된 위협, 그러나 여전히 강력한’ SQL 인젝션 (boannews.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bugbountyclub.com/pentestgym/view/53&#34;&gt;Error 기반 SQL 인젝션 | Pentest Gym | 버그바운티클럽 (bugbountyclub.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bugbountyclub.com/pentestgym/view/54&#34;&gt;UNION 기반 SQL 인젝션 | Pentest Gym | 버그바운티클럽 (bugbountyclub.com)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bugbountyclub.com/pentestgym/view/55&#34;&gt;Blind SQL 인젝션 | Pentest Gym | 버그바운티클럽 (bugbountyclub.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[DB] DB Locking 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/database/db-locking/</link>
      <pubDate>Mon, 26 Feb 2024 01:13:22 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/database/db-locking/</guid>
      <description>&lt;h2 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 2월 20일에 발표한 &lt;strong&gt;DB Locking&lt;/strong&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;db-locking이란&#34; &gt;DB Locking이란?
&lt;span&gt;
    &lt;a href=&#34;#db-locking%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;병행 트랜잭션이 가능한 환경에서&lt;/em&gt;, 변경중인 record를 다른 transaction들이 접근하지 못하도록 막음으로써, 병행 수행 문제를 해결하려는 접근 방법입니다.&lt;br&gt;
이러한 Locking을 위한 규약(Protocol)으로는 &lt;code&gt;Shared Locking Protocol&lt;/code&gt;, &lt;code&gt;2PLP(2-Phase Locking Protocol)&lt;/code&gt;, &lt;code&gt;Multiple Granularity Locking Protocol&lt;/code&gt; 이 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;병행-트랜잭션concurrent-transaction-이란&#34; &gt;병행 트랜잭션(Concurrent Transaction) 이란?
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98concurrent-transaction-%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;동시에 실행되고 있는 둘 이상의 트랜잭션을 의미합니다.&lt;/p&gt;
&lt;h4 id=&#34;병행-트랜잭션의-장점&#34; &gt;병행 트랜잭션의 장점
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%98-%ec%9e%a5%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;db의-공용도sharability-제고&#34; &gt;DB의 공용도(Sharability) 제고
&lt;span&gt;
    &lt;a href=&#34;#db%ec%9d%98-%ea%b3%b5%ec%9a%a9%eb%8f%84sharability-%ec%a0%9c%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;응답시간response-time-단축&#34; &gt;응답시간(Response Time) 단축
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%91%eb%8b%b5%ec%8b%9c%ea%b0%84response-time-%eb%8b%a8%ec%b6%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;시스템-활용도system-utilization-증대&#34; &gt;시스템 활용도(System Utilization) 증대
&lt;span&gt;
    &lt;a href=&#34;#%ec%8b%9c%ec%8a%a4%ed%85%9c-%ed%99%9c%ec%9a%a9%eb%8f%84system-utilization-%ec%a6%9d%eb%8c%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h4 id=&#34;병행-트랜잭션의-동시성-문제&#34; &gt;병행 트랜잭션의 동시성 문제
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%98-%eb%8f%99%ec%8b%9c%ec%84%b1-%eb%ac%b8%ec%a0%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;병행 트랜잭션의 병행 수행률이 상승할수록, 아래와 같은 병행 문제들의 발생률도 상승합니다. &lt;br&gt;
설명의 편의를 위해 병행 실행되는 트랜잭션 두 가지를 아래에서 T1, T2라고 부르도록 하겠습니다.&lt;/p&gt;
&lt;h5 id=&#34;갱신-분실lost-update&#34; &gt;갱신 분실(Lost Update)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b0%b1%ec%8b%a0-%eb%b6%84%ec%8b%a4lost-update&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;Lost-Update.png&#34; alt=&#34;Lost-Update.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;두 트랜잭션이 병렬로 같은 데이터를 읽고 갱신하는 과정에서, 한 트랜잭션이 다른 트랜잭션의 갱신 값을 덮어쓰는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 연산 후 갱신 작업을 수행한 뒤, 이후에 T2가 갱신된 값이 아닌 이전의 값을 기준으로 연산 후 갱신 작업을 수행해 T1의 갱신이 무효화 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;모순적-읽기inconsistent-read&#34; &gt;모순적 읽기(Inconsistent Read)
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%a8%ec%88%9c%ec%a0%81-%ec%9d%bd%ea%b8%b0inconsistent-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;두 트랜잭션이 병렬로 같은 데이터를 읽고 갱신하는 과정에서, 데이터 불일치가 발생하는 문제입니다.&lt;/p&gt;
&lt;h6 id=&#34;dirty-read&#34; &gt;Dirty Read
&lt;span&gt;
    &lt;a href=&#34;#dirty-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Dirty-Read.png&#34; alt=&#34;Dirty-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;격리성 수준이 &lt;code&gt;Read Uncommitted&lt;/code&gt; 이하인 환경에서 발생가능한 문제로, 한 트랜잭션이 다른 트랜잭션으로부터 &lt;strong&gt;커밋되지 않은 값을 읽어 발생&lt;/strong&gt;하는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 커밋되기 전, 중간에 T2가 T1에서 작업하던 데이터(&lt;em&gt;T1의 &lt;strong&gt;수정&lt;/strong&gt;이 &lt;strong&gt;반영되지 않은&lt;/strong&gt;&lt;/em&gt;)을 읽고 작업을 수행해 T1 연산 이전의 값으로 T2가 수행되게 됩니다. 이는 정확하지 않거나 일관되지 않은 결과를 야기할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;non-repeatable-read&#34; &gt;Non-repeatable Read
&lt;span&gt;
    &lt;a href=&#34;#non-repeatable-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Non-repeatable-Read.png&#34; alt=&#34;Non-repeatable-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;같은 데이터를 한 트랜잭션 내에서 읽었음에도, 둘의 값이 다른 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 두 번 읽을 때, 중간에 T2가 해당 데이터의 값을 변경한 뒤 커밋하게 되면 두 번째로 읽었을 때의 값은 처음 읽었던 값과 다르게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;phantom-read&#34; &gt;Phantom Read
&lt;span&gt;
    &lt;a href=&#34;#phantom-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Phantom-Read.png&#34; alt=&#34;Phantom-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;같은 조건에 대한 검색을 한 트랜잭션 내에서 수행했음에도, 다시 읽으려 할 때 이전에 존재하던 값이 없어지거나, 새로운 값이 추가로 검색되는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 두 번 읽을 때, 중간에 T2가 해당 데이터를 삭제한 뒤 커밋하게 되면 두 번째로 읽었을 때 해당 데이터는 존재하지 않게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;연쇄적-롤백cascading-rollback&#34; &gt;연쇄적 롤백(Cascading Rollback)
&lt;span&gt;
    &lt;a href=&#34;#%ec%97%b0%ec%87%84%ec%a0%81-%eb%a1%a4%eb%b0%b1cascading-rollback&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;Cascading-Rollback.png&#34; alt=&#34;Cascading-Rollback.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;한 트랜잭션이 갱신한 데이터를 다른 트랜잭션이 또 다시 갱신한 뒤, 앞선 트랜잭션을 롤백하려할 때 이후 실행했던 트랜잭션도 롤백해야 하나 이미 해당 트랜잭션은 완료되어 롤백이 불가능한 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 갱신한 뒤, T2이 해당 데이터를 또 갱신한 뒤 완료처리한 상태에서 T1을 롤백하려 하면 T2이 처리한 부분에 대해서는 롤백이 불가능하게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;transaction-schedule이란&#34; &gt;Transaction Schedule이란?
&lt;span&gt;
    &lt;a href=&#34;#transaction-schedule%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;트랜잭션들이 연산을 실행하는 순서를 의미합니다.&lt;br&gt;
스케줄의 개수는 &lt;code&gt;Interleaving(트랜잭션을 쪼개서 수행하는 것)&lt;/code&gt;이 가능한 경우 거의 무한대이고, 허용되지 않으면 $n!$ 개 입니다.&lt;br&gt;
병행 수행상 문제가 야기되느냐 그렇지 않느냐에 따라 직렬/비직렬 스케줄로 나뉩니다.&lt;/p&gt;
&lt;h4 id=&#34;직렬-스케줄serial-schedule&#34; &gt;직렬 스케줄(serial Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%eb%a0%ac-%ec%8a%a4%ec%bc%80%ec%a4%84serial-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;스케줄에 포함된 모든 트랜잭션이 하나씩 실행되는 스케줄을 의미합니다.&lt;br&gt;
병행 수행의 문제가 발생하지 않으나, 병행 트랜잭션으로 실행되지 않게 됩니다.&lt;/p&gt;
&lt;h4 id=&#34;비직렬-스케줄non-serial-schedule&#34; &gt;비직렬 스케줄(non-serial Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ec%a7%81%eb%a0%ac-%ec%8a%a4%ec%bc%80%ec%a4%84non-serial-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;스케줄에 포함된 모든 트랜잭션이 서로 interleaved되는 스케줄을 의미합니다.&lt;br&gt;
같은 트랜잭션 내 작업이라도 쪼개서 수행될 수 있기 때문에 쪼개진 작업이 실행되는 시점에 따라 잘못된 결과를 얻을 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;직렬-가능-스케줄serializable-schedule&#34; &gt;직렬 가능 스케줄(serializable Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84serializable-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;어떤 직렬 스케줄과 &lt;strong&gt;동등&lt;/strong&gt;한 비직렬 스케줄을 의미합니다.&lt;br&gt;
&lt;strong&gt;모든 충돌 직렬 가능 스케줄&lt;/strong&gt;은 &lt;strong&gt;뷰 직렬 가능 스케줄&lt;/strong&gt;이지만, &lt;em&gt;&lt;strong&gt;역은 성립하지 않습니다&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;h6 id=&#34;충돌-직렬-가능-스케줄&#34; &gt;충돌 직렬 가능 스케줄
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%a9%eb%8f%8c-%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;비직렬 스케줄 S에 대해 &lt;strong&gt;충돌 동등&lt;/strong&gt;한 직렬 스케줄 S&amp;rsquo;가 존재하면, S를 &lt;code&gt;충돌 직렬 가능 스케줄&lt;/code&gt; 이라고 합니다.&lt;/p&gt;
&lt;h6 id=&#34;뷰-직렬-가능-스케줄&#34; &gt;뷰 직렬 가능 스케줄
&lt;span&gt;
    &lt;a href=&#34;#%eb%b7%b0-%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;비직렬 스케줄 S에 대해 &lt;strong&gt;뷰 동등&lt;/strong&gt;한 직렬 스케줄 S&amp;rsquo;가 존재하면, S를 &lt;code&gt;뷰 직렬 가능 스케줄&lt;/code&gt; 이라고 합니다.&lt;/p&gt;
&lt;h5 id=&#34;스케줄-동등&#34; &gt;스케줄 동등
&lt;span&gt;
    &lt;a href=&#34;#%ec%8a%a4%ec%bc%80%ec%a4%84-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h6 id=&#34;결과result-동등&#34; &gt;결과(result) 동등
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%b0%ea%b3%bcresult-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;결과가 동일한 스케줄을 의미합니다.&lt;/p&gt;
&lt;h6 id=&#34;충돌conflict-동등&#34; &gt;충돌(conflict) 동등
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%a9%eb%8f%8cconflict-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;충돌 연산의 순서가 동일한 스케줄을 의미합니다.&lt;/p&gt;
&lt;h6 id=&#34;뷰view-동등&#34; &gt;뷰(view) 동등
&lt;span&gt;
    &lt;a href=&#34;#%eb%b7%b0view-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;스케줄 S1, S2에 포함된 트랜잭션이 같고 아래 조건을 만족하는 경우를 의미합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S1에서 $T_i$가 $x$의 초기 값을 읽는다면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;li&gt;S1에서 $T_i$의 모든 read(x)가 $T_j$가 write한 x값을 읽는다면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;li&gt;S1에서 $T_i$가 write(x)를 마지막으로 수행하면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lock-이란&#34; &gt;Lock 이란?
&lt;span&gt;
    &lt;a href=&#34;#lock-%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;DB상의 데이터 항목에 대한 잠금장치입니다.&lt;br&gt;
Lock이 걸린 데이터 항목은 Lock을 건 트랜잭션만 접근할 수 있습니다.&lt;br&gt;
Lcok은 Lock을 건 트랜잭션에 의해서만 Unlock할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;lock의-종류&#34; &gt;Lock의 종류
&lt;span&gt;
    &lt;a href=&#34;#lock%ec%9d%98-%ec%a2%85%eb%a5%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;공용-로크shared-lock-s-lock&#34; &gt;공용 로크(Shared Lock, S-Lock)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%b5%ec%9a%a9-%eb%a1%9c%ed%81%acshared-lock-s-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;다른 트랜잭션이 해당 데이터를 Read 할 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;전용-로크exclusive-lock-x-lock&#34; &gt;전용 로크(Exclusive Lock, X-Lock)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%84%ec%9a%a9-%eb%a1%9c%ed%81%acexclusive-lock-x-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;다른 트랜잭션이 해당 데이터를 Read/Write 할 수 없습니다.&lt;/p&gt;
&lt;h4 id=&#34;로크-단위lock-granularity&#34; &gt;로크 단위(Lock granularity)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%ed%81%ac-%eb%8b%a8%ec%9c%84lock-granularity&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;row, table, database 등 Locking할 자원의 크기를 말합니다.&lt;br&gt;
단위의 크기가 커질수록 병행성 수준은 낮아지고, 병행 제어 기법은 간단해집니다.&lt;/p&gt;
&lt;h4 id=&#34;로크-호환성-lock-compatibility&#34; &gt;로크 호환성 (Lock Compatibility)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%ed%81%ac-%ed%98%b8%ed%99%98%ec%84%b1-lock-compatibility&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;이미 자원에 특정 Lock이 설정되어 있는 경우, 다른 트랜잭션도 해당 자원에 대해 Lock을 설정할 수 있는지 여부를 말합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구 분&lt;/th&gt;
&lt;th&gt;Request S-lock&lt;/th&gt;
&lt;th&gt;Request X-lock&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S-locked data item&lt;/td&gt;
&lt;td&gt;ok&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-locked data item&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;locking-protocol&#34; &gt;Locking Protocol
&lt;span&gt;
    &lt;a href=&#34;#locking-protocol&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;아래 설명된 Protocol들 이외에도 기본적인 Locking Protocol은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션 T가 x에 대해 read(x)/write(x) 연산을 하려면 먼저 lock(x) 연산을 실행해야 한다.&lt;/li&gt;
&lt;li&gt;트랜잭션 T가 실행한 lock(x)에 대해서는 T가 모든 실행(Task)을 종료하기 전에 unlock(x) 연산을 수행해야 한다.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;em&gt;다른 트랜잭션에 의해 lock이 걸려있는&lt;/em&gt; x에 대해 &lt;strong&gt;lock(x)&lt;/strong&gt; 를 &lt;strong&gt;실행할 수 없다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;em&gt;자신이 lock을 걸지않은 x&lt;/em&gt;에 대해 &lt;strong&gt;unlock(x)&lt;/strong&gt; 을 &lt;strong&gt;실행할 수 없다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shared-locking-protocol공용-로킹-규약&#34; &gt;&lt;code&gt;Shared Locking Protocol(공용 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#shared-locking-protocol%ea%b3%b5%ec%9a%a9-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션 T는 &lt;strong&gt;read(x)&lt;/strong&gt; 전 반드시 &lt;mark style=&#34;background: #ADCCFFA6;&#34;&gt;lock-S(x)&lt;/mark&gt; 또는 &lt;mark style=&#34;background: #FFB86CA6;&#34;&gt;lock-X(x)&lt;/mark&gt;를 실행해야 함.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;strong&gt;write(x)&lt;/strong&gt; 전 반드시 &lt;mark style=&#34;background: #FFB86CA6;&#34;&gt;lock-X(x)&lt;/mark&gt;를 실행해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 규약 때문에 공용 로킹 규약은 &lt;strong&gt;&lt;code&gt;직렬가능성(serializability)&lt;/code&gt;&lt;/strong&gt; 을 보장하지 못합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;직렬가능성(serializability)&lt;/code&gt;&lt;/strong&gt; : 비직렬 스케줄을 직렬 스케줄로 변환할 수 있는지를 의미합니다.
&lt;ul&gt;
&lt;li&gt;lock과 unlock이 병렬로 수행될 수 있으므로 병행 처리되는 트랜잭션들이 서로 간섭할 수 있어 직렬 가능성이 보장되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2plp2-phase-locking-protocol-2단계-로킹-규약&#34; &gt;&lt;code&gt;2PLP(2-Phase Locking Protocol, 2단계 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#2plp2-phase-locking-protocol-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;lock만 가능한 Phase와 unlock만 가능한 phase를 나누어 로킹을 수행하는 규약입니다.&lt;br&gt;
&lt;code&gt;직렬가능성&lt;/code&gt;을 &lt;strong&gt;보장&lt;/strong&gt;하지만, &lt;strong&gt;&lt;code&gt;Deadlock&lt;/code&gt;&lt;/strong&gt; 문제가 존재하는 규약입니다.&lt;br&gt;
변형으로는 &lt;code&gt;Strict 2PLP&lt;/code&gt;, &lt;code&gt;Rigorous 2PLP&lt;/code&gt;가 존재하며, 상용 DBMS에서는 이 둘 중 하나를 사용합니다.&lt;/p&gt;
&lt;h5 id=&#34;1-단계growing-phase&#34; &gt;1 단계(Growing Phase)
&lt;span&gt;
    &lt;a href=&#34;#1-%eb%8b%a8%ea%b3%84growing-phase&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션은 계속해 lock을 획득할 수 있으나, unlock 연산은 실행할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-단계shrink-phase&#34; &gt;2 단계(Shrink Phase)
&lt;span&gt;
    &lt;a href=&#34;#2-%eb%8b%a8%ea%b3%84shrink-phase&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;unlock 연산만 실행할 수 있으며, 일단 Lock을 해제하면 더 이상 lock을 획득할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;strict-2plp엄격-2단계-로킹-규약&#34; &gt;Strict 2PLP(엄격 2단계 로킹 규약)
&lt;span&gt;
    &lt;a href=&#34;#strict-2plp%ec%97%84%ea%b2%a9-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;2PLP에 &amp;lsquo;모든 &lt;strong&gt;X-lock&lt;/strong&gt;은 &lt;em&gt;트랜잭션 완료시까지&lt;/em&gt; &lt;strong&gt;unlock 할 수 없다&lt;/strong&gt;&amp;lsquo;는 규칙이 추가된 형태입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현이 어려우나 성능이 높고&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;연쇄 복귀 문제(Cascading Rollback)&lt;/code&gt;&lt;/strong&gt; 가 발생하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;rigorous-2plp엄밀-2단계-로킹-규약&#34; &gt;Rigorous 2PLP(엄밀 2단계 로킹 규약)
&lt;span&gt;
    &lt;a href=&#34;#rigorous-2plp%ec%97%84%eb%b0%80-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;2PLP에 &amp;lsquo;모든 &lt;strong&gt;lock&lt;/strong&gt;은 &lt;em&gt;트랜잭션 완료시까지&lt;/em&gt; &lt;strong&gt;unlock 할 수 없다&lt;/strong&gt;&amp;lsquo;는 규칙이 추가된 형태입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현은 쉬우나 성능이 낮다&lt;/strong&gt;는 단점이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;multiple-granularity-locking-protocol다중-단위-로킹-규약&#34; &gt;&lt;code&gt;Multiple Granularity Locking Protocol(다중 단위 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#multiple-granularity-locking-protocol%eb%8b%a4%ec%a4%91-%eb%8b%a8%ec%9c%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;병행성 수준을 감소시키지 않기 위해, 필요 이상의 크기로 locking 하지 않는 방법입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;로킹 계층 트리 : DB -&amp;gt; 구역(Area) -&amp;gt; 파일(File) -&amp;gt; 레코드(Record)
&lt;img src=&#34;Multi-Granularity-tree-Hiererchy.png&#34; alt=&#34;Multi-Granularity-tree-Hiererchy.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DB: 모든 파일을 포함하는 데이터베이스입니다. 데이터베이스는 여러 파일로 구성됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구역(Area): 파일들로 이뤄진 데이터베이스 내 특정 영역입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일(File): 관련된 레코드들의 그룹입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;레코드(Record): DB 테이블에서 하나의 행입니다. 레코드는 여러 필드로 구성됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;optimistic-lockpessimistic-lock란&#34; &gt;Optimistic Lock/Pessimistic Lock란?
&lt;span&gt;
    &lt;a href=&#34;#optimistic-lockpessimistic-lock%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;h3 id=&#34;낙관적-로크optimistic-lock&#34; &gt;낙관적 로크(Optimistic Lock)
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%99%ea%b4%80%ec%a0%81-%eb%a1%9c%ed%81%acoptimistic-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;다른 트랜잭션과 충돌하지 않는다고 가정하고, 별도의 Locking 없이 자원에 접근하는 것을 말합니다.&lt;br&gt;
병행 제어를 위해 아래 세 과정을 수행하며, 각 과정마다 Start(T), Validation(T), Finish(T) 세 가지의 &lt;strong&gt;&lt;code&gt;타임스탬프&lt;/code&gt;&lt;/strong&gt; 를 사용합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;타임스탬프&lt;/code&gt;&lt;/strong&gt; : 시스템에서 &lt;strong&gt;트랜잭션&lt;/strong&gt;을 &lt;strong&gt;유일하게 식별&lt;/strong&gt;하기 위해 부여한 &lt;strong&gt;식별자(identifier)&lt;/strong&gt; 로, 트랜잭션이 &lt;strong&gt;시스템에 들어온 순서대로&lt;/strong&gt; 부여합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;과정&#34; &gt;과정
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%bc%ec%a0%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;판독 단계(Read Step)&lt;/code&gt; : 트랜잭션에 필요한 자료를 DB로 부터 읽어 &lt;strong&gt;Local Working Area에 복사&lt;/strong&gt;합니다. 이후 &lt;strong&gt;모든 갱신은 사본을 대상&lt;/strong&gt;으로 수행합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;확인 단계(Validation Step)&lt;/code&gt;: &lt;strong&gt;직렬(Serialization) 가능성 위반 여부&lt;/strong&gt;를 &lt;strong&gt;검사&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;기록 단계(Write Step)&lt;/code&gt;: 확인 단계를 통과하면 &lt;strong&gt;DB에 반영&lt;/strong&gt;하고, &lt;em&gt;통과하지 못했다면 실행 결과는 취소&lt;/em&gt;하고 트랜잭션은 복귀합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;비관적-로크pessimistic-lock&#34; &gt;비관적 로크(Pessimistic Lock)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ea%b4%80%ec%a0%81-%eb%a1%9c%ed%81%acpessimistic-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;다른 트랜잭션과 충돌한다고 가정하고, 트랜잭션을 처리하기 전에 자원에 대해 Locking을 시도하는것을 말합니다.&lt;/p&gt;
&lt;h4 id=&#34;과정-1&#34; &gt;과정
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%bc%ec%a0%95-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;자원에 대해 Lock을 겁니다.&lt;/li&gt;
&lt;li&gt;트랜잭션을 실행합니다.&lt;/li&gt;
&lt;li&gt;자원에 대해 Unlock을 수행합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;트랜잭션이-비정상-종료된-경우-lock을-해제할-해결책이-있는가-없다면-직접-해결-가능한가&#34; &gt;트랜잭션이 비정상 종료된 경우 Lock을 해제할 해결책이 있는가? 없다면 직접 해결 가능한가?
&lt;span&gt;
    &lt;a href=&#34;#%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%b4-%eb%b9%84%ec%a0%95%ec%83%81-%ec%a2%85%eb%a3%8c%eb%90%9c-%ea%b2%bd%ec%9a%b0-lock%ec%9d%84-%ed%95%b4%ec%a0%9c%ed%95%a0-%ed%95%b4%ea%b2%b0%ec%b1%85%ec%9d%b4-%ec%9e%88%eb%8a%94%ea%b0%80-%ec%97%86%eb%8b%a4%eb%a9%b4-%ec%a7%81%ec%a0%91-%ed%95%b4%ea%b2%b0-%ea%b0%80%eb%8a%a5%ed%95%9c%ea%b0%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;잘 설계된 DBMS에서는 Lock이 오랫동안 유지되어 Deadlock과 같은 상황을 발생시키지 않도록 여러 대비책을 갖고 있으며, 대부분의 DBMS에서는 Lock 관리를 위한 기능을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;lock-timeout&#34; &gt;Lock Timeout
&lt;span&gt;
    &lt;a href=&#34;#lock-timeout&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;Lock을 걸 때, 타임아웃을 설정해 일정시간이 지나면 자동으로 Lock을 해제하도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;deadlock-detection&#34; &gt;Deadlock Detection
&lt;span&gt;
    &lt;a href=&#34;#deadlock-detection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;교착상태가 발생하면 사후에 트랜잭션들 중 하나를 강제종료(&lt;code&gt;rollback&lt;/code&gt;) 시키는 조치를 취하는 방식입니다.&lt;/p&gt;
&lt;h3 id=&#34;일반적인-회복-방법&#34; &gt;일반적인 회복 방법
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ed%9a%8c%eb%b3%b5-%eb%b0%a9%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;이외에도 Redo, Undo와 같은 회복 방법을 통해 트랜잭션으로 손상된 부분을 회복시킬 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;redo-media-recovery&#34; &gt;Redo (Media Recovery)
&lt;span&gt;
    &lt;a href=&#34;#redo-media-recovery&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;비소멸장치(디스크, 테이프 등)의 내용 손상에 대한 회복 기법입니다.&lt;br&gt;
가장 최근의 복제본(dump)을 적재시키고, 해당 복제본 이후의 변경을 log를 이용해 재실행하여 DB를 복원합니다.&lt;/p&gt;
&lt;h4 id=&#34;undo&#34; &gt;Undo
&lt;span&gt;
    &lt;a href=&#34;#undo&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;log를 이용해 모든 변경을 취소시키므로써 DB를 복원합니다.&lt;/p&gt;
&lt;h4 id=&#34;소멸-장치의-정보-회복&#34; &gt;소멸 장치의 정보 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%86%8c%eb%a9%b8-%ec%9e%a5%ec%b9%98%ec%9d%98-%ec%a0%95%eb%b3%b4-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;log-이용-회복&#34; &gt;Log 이용 회복
&lt;span&gt;
    &lt;a href=&#34;#log-%ec%9d%b4%ec%9a%a9-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;트랜잭션이 Write 연산을 실행하거나, 트랜잭션의 시작/완료/철회와 같은 특별 활동시 기록되는 Log를 활용해 회복하는 방법입니다.&lt;br&gt;
Log는 &lt;code&gt;On-line log(실행중인 트랜잭션에 대한 로그)&lt;/code&gt;, &lt;code&gt;Archival log(누적되는 로그를 안정 저장장치에 저장한 것)&lt;/code&gt;로 나뉩니다.&lt;/p&gt;
&lt;h6 id=&#34;지연-갱신deferred-update의-회복&#34; &gt;지연 갱신(Deferred Update)의 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%80%ec%97%b0-%ea%b0%b1%ec%8b%a0deferred-update%ec%9d%98-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;트랜잭션이 부분 완료될 때 까지 DB 변경내역을 log에 전부 기록한 뒤, 부분 완료되면 보류시킨 Output 연산을 log를 사용해 처리합니다.&lt;br&gt;
트랜잭션 &lt;strong&gt;실행 중 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;처음부터 다시 실행&lt;/strong&gt;하고, &lt;strong&gt;완료 후 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;Log을 사용해 트랜잭션을 Redo&lt;/strong&gt; 합니다.&lt;/p&gt;
&lt;h6 id=&#34;즉시-갱신immediate-update의-회복&#34; &gt;즉시 갱신(Immediate Update)의 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%a6%89%ec%8b%9c-%ea%b0%b1%ec%8b%a0immediate-update%ec%9d%98-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;트랜잭션이 실행되는 동안 발생한 변경 내용을 DB에 그대로 반영해 처리합니다.&lt;br&gt;
트랜잭션 &lt;strong&gt;실행 중 장애가 발생&lt;/strong&gt;했다면 해당 &lt;strong&gt;트랜잭션에 대한 Undo&lt;/strong&gt;를 실행하고, &lt;strong&gt;완료 후 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;트랜잭션을 Redo&lt;/strong&gt; 합니다.&lt;/p&gt;
&lt;h5 id=&#34;검사시점check-point-회복&#34; &gt;검사시점(Check Point) 회복
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%80%ec%82%ac%ec%8b%9c%ec%a0%90check-point-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;em&gt;Log를 이용할 경우&lt;/em&gt; Redo/Undo 대상 트랜잭션을 찾기위해 &lt;strong&gt;log 전체를 조사&lt;/strong&gt;하거나,&lt;strong&gt;불필요한 Redo를 반복&lt;/strong&gt;한다는 &lt;strong&gt;문제를 해결&lt;/strong&gt;하기 위해 일정 간격으로 &lt;strong&gt;CheckPoint를 설치&lt;/strong&gt;해 이를 사용하는 기법입니다.&lt;br&gt;
Log를 차례로 검사하며 트랜잭션의 start를 만났다면 해당 트랜잭션을 Undo-list에, 트랜잭션의 commit을 만났다면 Undo-list에서 삭제하고 Redo-list에 추가합니다. 이후 Undo-list의 트랜잭션을 log에 기록된 역순으로 Undo를, Redo-list의 트랜잭션을 log에 기록된 순서로 Redo를 수행합니다.&lt;/p&gt;
&lt;h5 id=&#34;그림자-페이징shadow-paging-기법&#34; &gt;그림자 페이징(Shadow Paging) 기법
&lt;span&gt;
    &lt;a href=&#34;#%ea%b7%b8%eb%a6%bc%ec%9e%90-%ed%8e%98%ec%9d%b4%ec%a7%95shadow-paging-%ea%b8%b0%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;트랜잭션을 실행하는 동안 2개의 page table을 유지하는 방법입니다.&lt;br&gt;
current page table은 write 연산을 실행할 때 변경하며, shadow page table은 트랜잭션 실행 직전의 상태를 유지합니다.&lt;br&gt;
트랜잭션 완료 전 장애가 발생한 경우 shadow page table을 복사해 실행 직전으로 복귀시킵니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34; &gt;참고 자료
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0-%ec%9e%90%eb%a3%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;전공과목 강의자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)&#34;&gt;Isolation (database systems) - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/dbms-dirty-read-in-sql/&#34;&gt;Dirty Read in SQL - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/concurrency-problems-in-dbms-transactions/&#34;&gt;Concurrency problems in DBMS Transactions - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jidum.com/jidums/view.do?jidumId=282&#34;&gt;동시성제어개요 - 지식덤프&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/serializability-in-dbms/&#34;&gt;Serializability in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.jboss.org/hibernate/orm/4.1/devguide/en-US/html/ch05.html&#34;&gt;Chapter 5. Locking - Hibernate Community Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms/&#34;&gt;Lock Based Concurrency Control Protocol in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/docs/en/db2/11.5?topic=overview-optimistic-locking&#34;&gt;Optimistic locking - IBM Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.sap.com/doc/saphelp_nw73ehp1/7.31.19/en-us/47/dc35af5bc33b8be10000000a421937/content.htm?no_cache=true&#34;&gt;How Optimistic Locks Work - SAP Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://magicsoftware.my.salesforce-sites.com/PublicKnowledge/articles/bl_Reference/Physical-Locks-xpa-3x&#34;&gt;Reference: Physical Locks (Magic xpa 3.x) - Salesforce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/multiple-granularity-locking-in-dbms/&#34;&gt;Multiple Granularity Locking in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&#34;&gt;MySQL :: MySQL 8.0 Reference Manual :: 17.7.1 InnoDB Locking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.umsl.edu/~joshik/msis480/chapt06.htm&#34;&gt;6 Database Management - University of Missouri–St. Louis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[자료구조] B Tree와 B&#43;tree 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/database/b-tree-b&#43;tree/</link>
      <pubDate>Sun, 18 Feb 2024 09:58:46 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/database/b-tree-b&#43;tree/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 2월 13일에 발표한(정확히는 나는 2일 뒤인 15일에 발표했다.) &lt;strong&gt;B 트리와 B+ 트리&lt;/strong&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h1 id=&#34;b-tree와-btree는-무엇일까&#34; &gt;B-Tree와 B+Tree는 무엇일까
&lt;span&gt;
    &lt;a href=&#34;#b-tree%ec%99%80-btree%eb%8a%94-%eb%ac%b4%ec%97%87%ec%9d%bc%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;b-트리-b-tree&#34; &gt;B 트리 (B-Tree)
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac-b-tree&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;B-tree-architecture.png&#34; alt=&#34;B-tree-architecture.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이진 트리를 확장해 한 노드가 가질 수 있는 자식 노드의 갯수가 2개 이상인 &lt;code&gt;자가 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt;의 일종이며, 각 노드가 갖고있는 키 들은 정렬되어 있습니다.&lt;br&gt;
다른 자체 균형 이진 검색 트리와 달리, B 트리는 DB, File System과 같이 큰 데이터 블록을 읽고 써야하는 스토리지 시스템에 적합합니다.&lt;/p&gt;
&lt;h3 id=&#34;b-트리의-성질&#34; &gt;B 트리의 성질
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%84%b1%ec%a7%88&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;차수 m(&lt;em&gt;노드 중 가장 많은 자식을 갖는 노드의 자식 수&lt;/em&gt;)을 갖는 B 트리는 아래와 같은 성질을 만족합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 노드는 최대 m개의 자식이 존재합니다.&lt;/li&gt;
&lt;li&gt;모든 내부 노드는 최소 ⌈m/2⌉ 개의 자식이 존재합니다.&lt;/li&gt;
&lt;li&gt;루트 노드는 (&lt;em&gt;리프가 아닌 한&lt;/em&gt;) 최소 2개의 자식이 존재합니다.&lt;/li&gt;
&lt;li&gt;k개의 자식이 있는 &lt;em&gt;리프가 아닌&lt;/em&gt; 노드는 k-1 개의 키를 갖고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-노드들&#34; &gt;B 트리의 노드들
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%eb%85%b8%eb%93%9c%eb%93%a4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;B 트리를 이루는 노드는 내부 노드, 루트 노드, 리프 노드로 구성됩니다.&lt;/p&gt;
&lt;h4 id=&#34;내부-노드-internal-node&#34; &gt;내부 노드 (Internal Node)
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%b4%eb%b6%80-%eb%85%b8%eb%93%9c-internal-node&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;em&gt;적어도 하나의 자식&lt;/em&gt;을 갖는 노드로, &lt;em&gt;리프 노드와 루트 노드를 제외&lt;/em&gt;한 &lt;strong&gt;모든 노드&lt;/strong&gt;입니다.&lt;br&gt;
이들은 일반적으로 하위 포인터, 데이터 포인터, 검색 키의 순서 집합으로 표현됩니다.&lt;br&gt;
모든 &lt;code&gt;내부 노드&lt;/code&gt;는 최대 U개에서 최소 L개의 자식을 포함합니다. 따라서 &lt;code&gt;내부 노드&lt;/code&gt; 내 요소 수는 &amp;lsquo;하위 포인터 수 - 1&amp;rsquo; 입니다. (요소 수는 L-1 보다 높고, U-1 보다 낮습니다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;따라서 U는 2L 또는 2L - 1 이고, 각 &lt;code&gt;내부 노드&lt;/code&gt;들은 &lt;strong&gt;최소 절반&lt;/strong&gt; 이상 채워져 있습니다.
&lt;ul&gt;
&lt;li&gt;이는 두 &lt;em&gt;절반이 가득 찬&lt;/em&gt; 내부 노드를 하나의 노드로 &lt;strong&gt;병합하거나&lt;/strong&gt;, 하나의 완전한 노드를 두 개의 정상적인 노드로 &lt;strong&gt;나눌 수 있음&lt;/strong&gt;을 의미합니다.&lt;/li&gt;
&lt;li&gt;이러한 점을 통해, B 트리는 새 값을 삽입하거나 삭제하고 &lt;em&gt;B 트리 속성을 유지하도록&lt;/em&gt; 트리를 조절할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;내부-노드의-구조&#34; &gt;내부 노드의 구조
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%b4%eb%b6%80-%eb%85%b8%eb%93%9c%ec%9d%98-%ea%b5%ac%ec%a1%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$pt_0$&lt;/th&gt;
&lt;th&gt;$k_0$&lt;/th&gt;
&lt;th&gt;$pt_1$&lt;/th&gt;
&lt;th&gt;$pr_0$&lt;/th&gt;
&lt;th&gt;$k_1$&lt;/th&gt;
&lt;th&gt;$pt_2$&lt;/th&gt;
&lt;th&gt;$pr_1$&lt;/th&gt;
&lt;th&gt;&amp;hellip;&lt;/th&gt;
&lt;th&gt;$k_{K-1}$&lt;/th&gt;
&lt;th&gt;$pt_K$&lt;/th&gt;
&lt;th&gt;$pr_{K-1}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;$pt_i$ : 하위 서브 트리의 루트 노드를 가리키는 포인터&lt;/li&gt;
&lt;li&gt;$pr_i$ : 데이터를 갖고 있는 레코드를 가리키는 포인터&lt;/li&gt;
&lt;li&gt;$k_i$: zero-based 노드 인덱스 $i$의 검색 키&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한, 각 내부 노드의 키는 해당 노드의 서브 트리를 나누는 기준 값으로 사용됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약 내부 노드에 3가지 자식 노드(&lt;em&gt;또는 트리&lt;/em&gt;)가 있는 경우, 내부 노드에는 최소 2개의 키(예시로 $a_1$, $a_2$)가 있어야 합니다.
&lt;ul&gt;
&lt;li&gt;가장 왼쪽 서브 트리의 모든 값은 $a_1$보다 작고, 중간의 서브 트리의 모든 값은 $a_1$ 보다 크고 $a_2$보다 작으며, 가장 오른쪽 서브 트리의 모든 값은 $a_2$보다 큽니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;루트-노드-root-node&#34; &gt;루트 노드 (Root Node)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a3%a8%ed%8a%b8-%eb%85%b8%eb%93%9c-root-node&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;루트 노드의 자식 수는 내부 노드와 동일한 상한이 존재하지만, 하한은 존재하지 않습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 트리에 L-1 보다 적은 요소가 존재한다면, 루트 노드는 트리에서 자식이 전혀 없는 유일한 노드가 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;리프-노드-leaf-node&#34; &gt;리프 노드 (Leaf Node)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a6%ac%ed%94%84-%eb%85%b8%eb%93%9c-leaf-node&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;실질적인 데이터 객체/청크를 갖는 노드입니다. 모든 리프 노드들은 &lt;strong&gt;같은 레벨에 존재&lt;/strong&gt;해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;b-트리의-장점&#34; &gt;B 트리의 장점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%9e%a5%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;정렬되어있는-키&#34; &gt;정렬되어있는 키
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%eb%a0%ac%eb%90%98%ec%96%b4%ec%9e%88%eb%8a%94-%ed%82%a4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;저장된 키들이 정렬되어 있어, 순차적인 순회에 유용합니다.&lt;/p&gt;
&lt;h4 id=&#34;동일한-삽입삭제검색-시간-복잡도&#34; &gt;동일한 삽입/삭제/검색 시간 복잡도
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%9d%bc%ed%95%9c-%ec%82%bd%ec%9e%85%ec%82%ad%ec%a0%9c%ea%b2%80%ec%83%89-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;기존의 이진 탐색 트리와 달리, 한 노드에 저장할 수 있는 키의 수가 많아 트리는 더 얕은 높이를 가질 수 있게 되었습니다.&lt;br&gt;
이러한 계층형 인덱스를 사용하므로써 디스크 I/O가 줄어들어 더 낮은 삽입/삭제/검색 시간 복잡도를 가집니다.
이러한 점 때문에 B 트리는 대용량 데이터 셋, 실시간 애플리케이션에 적합합니다.&lt;br&gt;
특히 DB에서 B 트리 인덱스를 사용하면 검색 성능을 크게 향상 시킬 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS에서는 인덱스 키 - PK가 매칭이 되어있는 B 트리를 만들어두고 이를 사용합니다.
&lt;ul&gt;
&lt;li&gt;인덱스를 통해 PK를 찾고, 찾은 PK를 통해 레코드를 찾습니다.&lt;/li&gt;
&lt;li&gt;DBMS가 PK를 통해 레코드를 찾으려면, 테이블 전체를 뒤져 검색 해야하지만, B 트리 인덱스를 활용하면 트리를 몇 단계 탐색하므로써 PK를 찾을 수 있고 그 PK를 통해 레코드를 찾아올 수 있으므로 속도가 더 빠릅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;자체-균형&#34; &gt;자체 균형
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%ec%b2%b4-%ea%b7%a0%ed%98%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;B 트리는 &lt;code&gt;자체 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt;의 일종이므로 항상 최적의 높이를 유지하고자 지속적으로 스스로 균형을 맞추려고 합니다.&lt;br&gt;
따라서 기존의 이진 검색 트리의 경우 작업이 최악의 경우(&lt;em&gt;트리가 한쪽으로 쏠린 경우&lt;/em&gt;) O(N)의 시간 복잡도를 가졌지만, B 트리는 작업이 최악의 경우에도 O(logN)의 시간복잡도를 유지하도록 보장합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;자체 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt; : 임의의 아이템 삽입/삭제 이후 자동으로 높이를 낮게 유지하는 노드 기반의 이진 검색 트리를 의미합니다. 대표적인 예시로 AVL 트리, B 트리, RBT 등이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-단점&#34; &gt;B 트리의 단점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%eb%8b%a8%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;더많은-디스크-공간-사용&#34; &gt;더많은 디스크 공간 사용
&lt;span&gt;
    &lt;a href=&#34;#%eb%8d%94%eb%a7%8e%ec%9d%80-%eb%94%94%ec%8a%a4%ed%81%ac-%ea%b3%b5%ea%b0%84-%ec%82%ac%ec%9a%a9&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;균형 유지를 위해 추가적인 포인터 및 헤더 정보를 유지해야 하므로 더 많은 공간을 사용합니다.&lt;/p&gt;
&lt;h4 id=&#34;다른-자료-구조에-비해-느린-속도&#34; &gt;다른 자료 구조에 비해 느린 속도
&lt;span&gt;
    &lt;a href=&#34;#%eb%8b%a4%eb%a5%b8-%ec%9e%90%eb%a3%8c-%ea%b5%ac%ec%a1%b0%ec%97%90-%eb%b9%84%ed%95%b4-%eb%8a%90%eb%a6%b0-%ec%86%8d%eb%8f%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;삽입/삭제 연산 이후 균형 유지를 위해 회전, 병합과 같은 재배치 작업을 수행할 수 있으며, 이 과정에서 오버헤드가 발생할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;b-트리-b-tree-1&#34; &gt;B+ 트리 (B+ Tree)
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac-b-tree-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;B-plus-tree-architecure.png&#34; alt=&#34;B-plus-tree-architecure.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위는 분기 인자 b=4이며, 1~7 범위의 키와 $d_1$ ~ $d_7$의 데이터 값들을 연결하는 b+ 트리 예시 입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;B 트리의 변종 중 하나로, 각 노드가 키-값 쌍이 아닌 &lt;strong&gt;키만 포함&lt;/strong&gt;하며(인덱스 인트리) 하단에 &lt;strong&gt;링크드 리프 노드&lt;/strong&gt;들로 이뤄진 &lt;strong&gt;추가적인 레벨&lt;/strong&gt;(데이터 엔트리)이 붙어있는 B 트리로 볼 수 있습니다.&lt;br&gt;
노드 당 m개 이하의 자식이 있는 &lt;code&gt;다항 트리(m-ary tree)&lt;/code&gt; 라고도 일컬어지며, &lt;code&gt;분기 인자(branching factor, 각 노드 당 자식의 수)&lt;/code&gt; $b$ 를 기준으로 삽입/삭제/검색 작업이 $O(log_b{N})$ 의 시간 복잡도를 가집니다.&lt;br&gt;
B+ 트리의 핵심 가치는 &lt;code&gt;블록 지향 스토리지(block-oriented storage)&lt;/code&gt;(&lt;em&gt;특히 파일 시스템&lt;/em&gt;)에서 &lt;strong&gt;효율적인 검색&lt;/strong&gt;이 가능하도록 데이터를 저장하는 것입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이진 검색 트리와 달리, B+ 트리는 팬아웃이 매우 높아 트리 내 요소를 찾는데 필요한 I/O 작업 횟수를 줄일 수 있기 때문입니다.&lt;br&gt;
B+ 트리는 MS SQL, Oracle, SQLite 등의 RDBMS에서 &lt;strong&gt;테이블 인덱스&lt;/strong&gt;를 구현하는데 활용됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-성질-1&#34; &gt;B+ 트리의 성질
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%84%b1%ec%a7%88-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;분기 인자가 $b$ 이며, 높이 h인 b+ 트리는 다음과 같은 성질을 갖습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;저장된 레코드는 최대 $n_{max} = b^h - b^{h-1}$ 개여야 합니다.&lt;/li&gt;
&lt;li&gt;저장된 레코드는 최소 $n_{min} = 2\lceil {b\over2} \rceil^{h-1} - 2\lceil {b\over2}\rceil^{h-2}$ 개여야 합니다.&lt;/li&gt;
&lt;li&gt;트리를 저장하기 위한 공간 복잡도는 O(n) 입니다.&lt;/li&gt;
&lt;li&gt;레코드를 삽입/삭제/검색하는데 $O(log_b n)$의 시간 복잡도를 갖습니다.&lt;/li&gt;
&lt;li&gt;B+ 트리 구조는 레코드 수가 증가/감소 함에 따라 확장/수축 할 수 있으며, 크기에 제한이 없습니다.&lt;/li&gt;
&lt;li&gt;리프 노드들이 링크드 리스트 형태로 이어져 있어 빠른 &lt;code&gt;중위 순회(in-order traversal)&lt;/code&gt;가 가능합니다.&lt;/li&gt;
&lt;li&gt;리프 노드에서 부모 노드가 갖고 있는 키를 &lt;strong&gt;중복적&lt;/strong&gt;으로 가질 수 있습니다(&lt;code&gt;Key Duplication&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-장점-1&#34; &gt;B+ 트리의 장점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%9e%a5%ec%a0%90-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;순서대로-탐색이-가능&#34; &gt;순서대로 탐색이 가능
&lt;span&gt;
    &lt;a href=&#34;#%ec%88%9c%ec%84%9c%eb%8c%80%eb%a1%9c-%ed%83%90%ec%83%89%ec%9d%b4-%ea%b0%80%eb%8a%a5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;B 트리의 경우 모든 데이터 포인터가 리프 노드에 있지 않기 때문에 순서대로 연결된 리스트를 만들 수 없지만, B+ 트리의 경우 모든 데이터 포인터가 리프 노드에 존재하므로 순서대로 연결된 리스트를 만들 수 있습니다. 이를 통해 범위 쿼리나 정렬된 데이터가 필요한 작업들을 쉽게 수행할 수 있습니다.&lt;br&gt;
이러한 점 때문에, B+ 트리는 DB 시스템 인덱스를 구축하는데 유용합니다.&lt;/p&gt;
&lt;h4 id=&#34;정렬되어있는-키-1&#34; &gt;정렬되어있는 키
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%eb%a0%ac%eb%90%98%ec%96%b4%ec%9e%88%eb%8a%94-%ed%82%a4-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h4 id=&#34;자체-균형-1&#34; &gt;자체 균형
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%ec%b2%b4-%ea%b7%a0%ed%98%95-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h4 id=&#34;동일한-삽입삭제검색-시간-복잡도-1&#34; &gt;동일한 삽입/삭제/검색 시간 복잡도
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%9d%bc%ed%95%9c-%ec%82%bd%ec%9e%85%ec%82%ad%ec%a0%9c%ea%b2%80%ec%83%89-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h3 id=&#34;b-트리의-단점-1&#34; &gt;B+ 트리의 단점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%eb%8b%a8%ec%a0%90-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;b-트리-대비-더-높은-메모리-사용&#34; &gt;B 트리 대비 더 높은 메모리 사용
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac-%eb%8c%80%eb%b9%84-%eb%8d%94-%eb%86%92%ec%9d%80-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%82%ac%ec%9a%a9&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;em&gt;키, 값(데이터 포인터)을 각 노드에 저장&lt;/em&gt;하는 B 트리와 달리, B+ 트리는 내부 노드에는 키만 저장하고 리프 노드 층에 데이터를 저장하기 때문에 &lt;em&gt;키의 개수에 비례해&lt;/em&gt; &lt;strong&gt;추가적인 메모리가 필요&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;h1 id=&#34;b-tree가-b-tree에-비해-반드시-좋다고-할-수-있을까-그렇지-않다면-어떤-단점이&#34; &gt;B+ Tree가 B Tree에 비해 반드시 좋다고 할 수 있을까? 그렇지 않다면 어떤 단점이?
&lt;span&gt;
    &lt;a href=&#34;#b-tree%ea%b0%80-b-tree%ec%97%90-%eb%b9%84%ed%95%b4-%eb%b0%98%eb%93%9c%ec%8b%9c-%ec%a2%8b%eb%8b%a4%ea%b3%a0-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c-%ea%b7%b8%eb%a0%87%ec%a7%80-%ec%95%8a%eb%8b%a4%eb%a9%b4-%ec%96%b4%eb%96%a4-%eb%8b%a8%ec%a0%90%ec%9d%b4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;B-tree-and-B+tree.png&#34; alt=&#34;B-tree-and-B+tree.png&#34;&gt;&lt;br&gt;
&lt;em&gt;웬만한 경우&lt;/em&gt; &lt;strong&gt;B+ 트리&lt;/strong&gt;가 B 트리 보다 &lt;strong&gt;더 빠르게 검색&lt;/strong&gt;할 수 있기 때문에 좋다고 할 수 있습니다. &lt;br&gt;
B+ 트리는 &lt;em&gt;B 트리와 달리&lt;/em&gt; 내부 노드에 값(데이터)을 저장하지 않으므로써 내부 노드에 저장되는 키의 수, 즉 &lt;strong&gt;&lt;code&gt;팬아웃&lt;/code&gt;을 최대화&lt;/strong&gt; 했고, 이를 통해 &lt;strong&gt;트리의 높이를 최소화&lt;/strong&gt; 하기 때문입니다.&lt;br&gt;
또한 &lt;strong&gt;&lt;code&gt;범위 검색 작업&lt;/code&gt;&lt;/strong&gt; 을 &lt;strong&gt;효율적&lt;/strong&gt;으로 진행할 수 있습니다. &lt;strong&gt;리프 노드가 서로 연결&lt;/strong&gt;되어 있기 때문입니다.&lt;br&gt;
그리고 삽입/삭제 작업이 &lt;strong&gt;리프 노드에서 수행&lt;/strong&gt;되어 &lt;strong&gt;더 쉽고 시간 소모가 적습니다&lt;/strong&gt;.&lt;br&gt;
하지만, B 트리의 경우 &lt;em&gt;특정 노드를 자주 사용하는 경우&lt;/em&gt; &lt;strong&gt;더 빠를 수&lt;/strong&gt; 있습니다. 자주 사용되는 &lt;strong&gt;노드를 &lt;code&gt;상승&lt;/code&gt;&lt;/strong&gt; 시킬 수 있기 때문에, 원하는 데이터에 도달하는데 필요한 비교 작업이 적어지기 때문입니다.&lt;/p&gt;
&lt;h1 id=&#34;db에서-굳이-rbt와-같은-트리를-사용하지-않고-b-treebtree를-사용하는-이유는&#34; &gt;DB에서 굳이 RBT와 같은 트리를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유는?
&lt;span&gt;
    &lt;a href=&#34;#db%ec%97%90%ec%84%9c-%ea%b5%b3%ec%9d%b4-rbt%ec%99%80-%ea%b0%99%ec%9d%80-%ed%8a%b8%eb%a6%ac%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%ec%a7%80-%ec%95%8a%ea%b3%a0-b-treebtree%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0%eb%8a%94&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;더 빠르기 때문&lt;/strong&gt;입니다.&lt;br&gt;
이를 설명하려면 먼저 RBT, 즉 &lt;code&gt;레드-블랙 트리(Red-Black Tree)&lt;/code&gt;의 구조에 대해 알아야 합니다.&lt;br&gt;
RBT는 B 트리/B+ 트리와 마찬가지로 &lt;code&gt;자가 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt; 의 일종으로, 각각의 노드가 &lt;strong&gt;레드&lt;/strong&gt; 또는 &lt;strong&gt;블랙&lt;/strong&gt;의 색상 속성을 갖습니다.&lt;br&gt;
루트 노드와 모든 리프 노드들은 블랙이며, 레드 노드의 양 자식 노드들은 모두 블랙이라는 특징 때문에, RBT는 블랙과 레드가 번갈아 나오는 형태를 띄게 됩니다(물론 &lt;em&gt;블랙 다음에 블랙이 나올 수도&lt;/em&gt; 있습니다).&lt;br&gt;
이러한 특징 때문에 &lt;em&gt;루트 노드로 부터&lt;/em&gt; &lt;mark style=&#34;background: orange;&#34;&gt;가장 먼 리프 노드까지의 거리&lt;/mark&gt;가 &lt;mark style=&#34;background: skyblue;&#34;&gt;가장 가까운 리프 노드까지의 거리&lt;/mark&gt;의 &lt;strong&gt;2배 보다 항상 짧다&lt;/strong&gt;는 특성을 지니고, 이 때문에 삽입/삭제/탐색에 있어 B 트리와 마찬가지로 $O(logN)$의 시간 복잡도를 갖게 됩니다.&lt;br&gt;
하지만, &lt;strong&gt;RBT&lt;/strong&gt;는 일반적인 BST와 같이 &lt;strong&gt;자식을 둘 밖에&lt;/strong&gt; 가질 수 없으나 &lt;strong&gt;B 트리&lt;/strong&gt;는 &lt;strong&gt;둘 이상&lt;/strong&gt; 가질 수 있기 때문에 훨씬 &lt;strong&gt;트리 높이가 짧아지고&lt;/strong&gt; &lt;strong&gt;더 적은 디스크 I/O 작업을 수행&lt;/strong&gt;해 결과적으로 더 빠른 속도로 탐색을 진행할 수 있습니다.&lt;br&gt;
또한 &lt;em&gt;B 트리의 경우&lt;/em&gt; 내부 노드의 두 개 이상의 키들을 &lt;strong&gt;&lt;code&gt;배열&lt;/code&gt;&lt;/strong&gt; 로 다루므로 RBT가 하위 노드들을 참조해 탐색하는 것 보다 &lt;strong&gt;더 빠른 접근 속도&lt;/strong&gt;를 갖게 됩니다.&lt;br&gt;
이러한 차이 때문에 DB에서 B 트리/B+ 트리를 사용하게 됩니다.&lt;/p&gt;
&lt;h1 id=&#34;오름차순으로-정렬된-인덱스가-있다고-할-때-내림차순-정렬을-시도할-경우-성능이-어떻게-될까-b-treebtree의-구조를-기반으로&#34; &gt;오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까? (B-Tree/B+Tree의 구조를 기반으로)
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%a4%eb%a6%84%ec%b0%a8%ec%88%9c%ec%9c%bc%eb%a1%9c-%ec%a0%95%eb%a0%ac%eb%90%9c-%ec%9d%b8%eb%8d%b1%ec%8a%a4%ea%b0%80-%ec%9e%88%eb%8b%a4%ea%b3%a0-%ed%95%a0-%eb%95%8c-%eb%82%b4%eb%a6%bc%ec%b0%a8%ec%88%9c-%ec%a0%95%eb%a0%ac%ec%9d%84-%ec%8b%9c%eb%8f%84%ed%95%a0-%ea%b2%bd%ec%9a%b0-%ec%84%b1%eb%8a%a5%ec%9d%b4-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%90%a0%ea%b9%8c-b-treebtree%ec%9d%98-%ea%b5%ac%ec%a1%b0%eb%a5%bc-%ea%b8%b0%eb%b0%98%ec%9c%bc%eb%a1%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;b-트리의-경우&#34; &gt;B 트리의 경우
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ea%b2%bd%ec%9a%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;B 트리의 경우 내림차순 정렬을 시도할 경우, 모든 노드들을 역순으로 하나 하나 탐색해야 합니다. 따라서 B+ 트리 대비 낮은 성능을 보입니다.&lt;/p&gt;
&lt;h2 id=&#34;b-트리의-경우-1&#34; &gt;B+ 트리의 경우
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ea%b2%bd%ec%9a%b0-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;B+ 트리의 경우 내림차순 정렬을 시도할 경우, 리프 노드만 역순으로 탐색하면 되고, 리프 노드들이 링크드 리스트 형태를 띄고 있으므로 순차 접근에 최적화 되어있어 더 높은 성능을 보입니다.&lt;/p&gt;
&lt;h1 id=&#34;참고-문서&#34; &gt;참고 문서
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0-%eb%ac%b8%ec%84%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree&#34;&gt;Self-balancing binary search tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/cs/self-balancing-bts&#34;&gt;Self-Balancing Binary Search Trees | Baeldung on Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree&#34;&gt;B-tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/introduction-of-b-tree-2/&#34;&gt;Introduction of B-Tree - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/B%2B_tree&#34;&gt;B+ tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/introduction-of-b-tree/&#34;&gt;Introduction of B+ Tree - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/difference-between-b-tree-and-b-tree/&#34;&gt;Difference between B tree and B+ tree - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/cs/b-trees-vs-btrees&#34;&gt;The Difference Between B-trees and B+trees | Baeldung on Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/&#34;&gt;MySQL Ascending index vs Descending index - tech.kakao.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&#34;&gt;Red–black tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.allegro.tech/2023/11/how-does-btree-make-your-queries-fast.html&#34;&gt;How does B-tree make your queries fast? - allegro.tech&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

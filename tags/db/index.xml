<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DB on 오늘도 개발을 한다.</title>
    <link>https://cloudsoswift.github.io/tags/db/</link>
    <description>오늘도 개발을 한다. (DB)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 26 Feb 2024 01:13:22 +0900</lastBuildDate>
    
    <atom:link href="https://cloudsoswift.github.io/tags/db/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[DB] DB Locking 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/database/db-locking/</link>
      <pubDate>Mon, 26 Feb 2024 01:13:22 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/database/db-locking/</guid>
      <description>&lt;h2 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 2월 20일에 발표한 &lt;strong&gt;DB Locking&lt;/strong&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h2 id=&#34;db-locking이란&#34; &gt;DB Locking이란?
&lt;span&gt;
    &lt;a href=&#34;#db-locking%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;병행 트랜잭션이 가능한 환경에서&lt;/em&gt;, 변경중인 record를 다른 transaction들이 접근하지 못하도록 막음으로써, 병행 수행 문제를 해결하려는 접근 방법입니다.&lt;br&gt;
이러한 Locking을 위한 규약(Protocol)으로는 &lt;code&gt;Shared Locking Protocol&lt;/code&gt;, &lt;code&gt;2PLP(2-Phase Locking Protocol)&lt;/code&gt;, &lt;code&gt;Multiple Granularity Locking Protocol&lt;/code&gt; 이 있습니다.&lt;/p&gt;
&lt;h3 id=&#34;병행-트랜잭션concurrent-transaction-이란&#34; &gt;병행 트랜잭션(Concurrent Transaction) 이란?
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98concurrent-transaction-%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;동시에 실행되고 있는 둘 이상의 트랜잭션을 의미합니다.&lt;/p&gt;
&lt;h4 id=&#34;병행-트랜잭션의-장점&#34; &gt;병행 트랜잭션의 장점
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%98-%ec%9e%a5%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;db의-공용도sharability-제고&#34; &gt;DB의 공용도(Sharability) 제고
&lt;span&gt;
    &lt;a href=&#34;#db%ec%9d%98-%ea%b3%b5%ec%9a%a9%eb%8f%84sharability-%ec%a0%9c%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;응답시간response-time-단축&#34; &gt;응답시간(Response Time) 단축
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%91%eb%8b%b5%ec%8b%9c%ea%b0%84response-time-%eb%8b%a8%ec%b6%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h5 id=&#34;시스템-활용도system-utilization-증대&#34; &gt;시스템 활용도(System Utilization) 증대
&lt;span&gt;
    &lt;a href=&#34;#%ec%8b%9c%ec%8a%a4%ed%85%9c-%ed%99%9c%ec%9a%a9%eb%8f%84system-utilization-%ec%a6%9d%eb%8c%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h4 id=&#34;병행-트랜잭션의-동시성-문제&#34; &gt;병행 트랜잭션의 동시성 문제
&lt;span&gt;
    &lt;a href=&#34;#%eb%b3%91%ed%96%89-%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%98-%eb%8f%99%ec%8b%9c%ec%84%b1-%eb%ac%b8%ec%a0%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;병행 트랜잭션의 병행 수행률이 상승할수록, 아래와 같은 병행 문제들의 발생률도 상승합니다. &lt;br&gt;
설명의 편의를 위해 병행 실행되는 트랜잭션 두 가지를 아래에서 T1, T2라고 부르도록 하겠습니다.&lt;/p&gt;
&lt;h5 id=&#34;갱신-분실lost-update&#34; &gt;갱신 분실(Lost Update)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b0%b1%ec%8b%a0-%eb%b6%84%ec%8b%a4lost-update&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;Lost-Update.png&#34; alt=&#34;Lost-Update.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;두 트랜잭션이 병렬로 같은 데이터를 읽고 갱신하는 과정에서, 한 트랜잭션이 다른 트랜잭션의 갱신 값을 덮어쓰는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 연산 후 갱신 작업을 수행한 뒤, 이후에 T2가 갱신된 값이 아닌 이전의 값을 기준으로 연산 후 갱신 작업을 수행해 T1의 갱신이 무효화 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;모순적-읽기inconsistent-read&#34; &gt;모순적 읽기(Inconsistent Read)
&lt;span&gt;
    &lt;a href=&#34;#%eb%aa%a8%ec%88%9c%ec%a0%81-%ec%9d%bd%ea%b8%b0inconsistent-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;두 트랜잭션이 병렬로 같은 데이터를 읽고 갱신하는 과정에서, 데이터 불일치가 발생하는 문제입니다.&lt;/p&gt;
&lt;h6 id=&#34;dirty-read&#34; &gt;Dirty Read
&lt;span&gt;
    &lt;a href=&#34;#dirty-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Dirty-Read.png&#34; alt=&#34;Dirty-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;격리성 수준이 &lt;code&gt;Read Uncommitted&lt;/code&gt; 이하인 환경에서 발생가능한 문제로, 한 트랜잭션이 다른 트랜잭션으로부터 &lt;strong&gt;커밋되지 않은 값을 읽어 발생&lt;/strong&gt;하는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 커밋되기 전, 중간에 T2가 T1에서 작업하던 데이터(&lt;em&gt;T1의 &lt;strong&gt;수정&lt;/strong&gt;이 &lt;strong&gt;반영되지 않은&lt;/strong&gt;&lt;/em&gt;)을 읽고 작업을 수행해 T1 연산 이전의 값으로 T2가 수행되게 됩니다. 이는 정확하지 않거나 일관되지 않은 결과를 야기할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;non-repeatable-read&#34; &gt;Non-repeatable Read
&lt;span&gt;
    &lt;a href=&#34;#non-repeatable-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Non-repeatable-Read.png&#34; alt=&#34;Non-repeatable-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;같은 데이터를 한 트랜잭션 내에서 읽었음에도, 둘의 값이 다른 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 두 번 읽을 때, 중간에 T2가 해당 데이터의 값을 변경한 뒤 커밋하게 되면 두 번째로 읽었을 때의 값은 처음 읽었던 값과 다르게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&#34;phantom-read&#34; &gt;Phantom Read
&lt;span&gt;
    &lt;a href=&#34;#phantom-read&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;&lt;img src=&#34;Phantom-Read.png&#34; alt=&#34;Phantom-Read.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;같은 조건에 대한 검색을 한 트랜잭션 내에서 수행했음에도, 다시 읽으려 할 때 이전에 존재하던 값이 없어지거나, 새로운 값이 추가로 검색되는 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 두 번 읽을 때, 중간에 T2가 해당 데이터를 삭제한 뒤 커밋하게 되면 두 번째로 읽었을 때 해당 데이터는 존재하지 않게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;연쇄적-롤백cascading-rollback&#34; &gt;연쇄적 롤백(Cascading Rollback)
&lt;span&gt;
    &lt;a href=&#34;#%ec%97%b0%ec%87%84%ec%a0%81-%eb%a1%a4%eb%b0%b1cascading-rollback&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;img src=&#34;Cascading-Rollback.png&#34; alt=&#34;Cascading-Rollback.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;한 트랜잭션이 갱신한 데이터를 다른 트랜잭션이 또 다시 갱신한 뒤, 앞선 트랜잭션을 롤백하려할 때 이후 실행했던 트랜잭션도 롤백해야 하나 이미 해당 트랜잭션은 완료되어 롤백이 불가능한 문제입니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;예시) T1이 한 데이터를 갱신한 뒤, T2이 해당 데이터를 또 갱신한 뒤 완료처리한 상태에서 T1을 롤백하려 하면 T2이 처리한 부분에 대해서는 롤백이 불가능하게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;transaction-schedule이란&#34; &gt;Transaction Schedule이란?
&lt;span&gt;
    &lt;a href=&#34;#transaction-schedule%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;트랜잭션들이 연산을 실행하는 순서를 의미합니다.&lt;br&gt;
스케줄의 개수는 &lt;code&gt;Interleaving(트랜잭션을 쪼개서 수행하는 것)&lt;/code&gt;이 가능한 경우 거의 무한대이고, 허용되지 않으면 $n!$ 개 입니다.&lt;br&gt;
병행 수행상 문제가 야기되느냐 그렇지 않느냐에 따라 직렬/비직렬 스케줄로 나뉩니다.&lt;/p&gt;
&lt;h4 id=&#34;직렬-스케줄serial-schedule&#34; &gt;직렬 스케줄(serial Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%eb%a0%ac-%ec%8a%a4%ec%bc%80%ec%a4%84serial-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;스케줄에 포함된 모든 트랜잭션이 하나씩 실행되는 스케줄을 의미합니다.&lt;br&gt;
병행 수행의 문제가 발생하지 않으나, 병행 트랜잭션으로 실행되지 않게 됩니다.&lt;/p&gt;
&lt;h4 id=&#34;비직렬-스케줄non-serial-schedule&#34; &gt;비직렬 스케줄(non-serial Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ec%a7%81%eb%a0%ac-%ec%8a%a4%ec%bc%80%ec%a4%84non-serial-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;스케줄에 포함된 모든 트랜잭션이 서로 interleaved되는 스케줄을 의미합니다.&lt;br&gt;
같은 트랜잭션 내 작업이라도 쪼개서 수행될 수 있기 때문에 쪼개진 작업이 실행되는 시점에 따라 잘못된 결과를 얻을 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;직렬-가능-스케줄serializable-schedule&#34; &gt;직렬 가능 스케줄(serializable Schedule)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84serializable-schedule&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;어떤 직렬 스케줄과 &lt;strong&gt;동등&lt;/strong&gt;한 비직렬 스케줄을 의미합니다.&lt;br&gt;
&lt;strong&gt;모든 충돌 직렬 가능 스케줄&lt;/strong&gt;은 &lt;strong&gt;뷰 직렬 가능 스케줄&lt;/strong&gt;이지만, &lt;em&gt;&lt;strong&gt;역은 성립하지 않습니다&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;h6 id=&#34;충돌-직렬-가능-스케줄&#34; &gt;충돌 직렬 가능 스케줄
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%a9%eb%8f%8c-%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;비직렬 스케줄 S에 대해 &lt;strong&gt;충돌 동등&lt;/strong&gt;한 직렬 스케줄 S&amp;rsquo;가 존재하면, S를 &lt;code&gt;충돌 직렬 가능 스케줄&lt;/code&gt; 이라고 합니다.&lt;/p&gt;
&lt;h6 id=&#34;뷰-직렬-가능-스케줄&#34; &gt;뷰 직렬 가능 스케줄
&lt;span&gt;
    &lt;a href=&#34;#%eb%b7%b0-%ec%a7%81%eb%a0%ac-%ea%b0%80%eb%8a%a5-%ec%8a%a4%ec%bc%80%ec%a4%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;비직렬 스케줄 S에 대해 &lt;strong&gt;뷰 동등&lt;/strong&gt;한 직렬 스케줄 S&amp;rsquo;가 존재하면, S를 &lt;code&gt;뷰 직렬 가능 스케줄&lt;/code&gt; 이라고 합니다.&lt;/p&gt;
&lt;h5 id=&#34;스케줄-동등&#34; &gt;스케줄 동등
&lt;span&gt;
    &lt;a href=&#34;#%ec%8a%a4%ec%bc%80%ec%a4%84-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;h6 id=&#34;결과result-동등&#34; &gt;결과(result) 동등
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%b0%ea%b3%bcresult-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;결과가 동일한 스케줄을 의미합니다.&lt;/p&gt;
&lt;h6 id=&#34;충돌conflict-동등&#34; &gt;충돌(conflict) 동등
&lt;span&gt;
    &lt;a href=&#34;#%ec%b6%a9%eb%8f%8cconflict-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;충돌 연산의 순서가 동일한 스케줄을 의미합니다.&lt;/p&gt;
&lt;h6 id=&#34;뷰view-동등&#34; &gt;뷰(view) 동등
&lt;span&gt;
    &lt;a href=&#34;#%eb%b7%b0view-%eb%8f%99%eb%93%b1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;스케줄 S1, S2에 포함된 트랜잭션이 같고 아래 조건을 만족하는 경우를 의미합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S1에서 $T_i$가 $x$의 초기 값을 읽는다면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;li&gt;S1에서 $T_i$의 모든 read(x)가 $T_j$가 write한 x값을 읽는다면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;li&gt;S1에서 $T_i$가 write(x)를 마지막으로 수행하면, S2에서도 그러해야 합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lock-이란&#34; &gt;Lock 이란?
&lt;span&gt;
    &lt;a href=&#34;#lock-%ec%9d%b4%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;DB상의 데이터 항목에 대한 잠금장치입니다.&lt;br&gt;
Lock이 걸린 데이터 항목은 Lock을 건 트랜잭션만 접근할 수 있습니다.&lt;br&gt;
Lcok은 Lock을 건 트랜잭션에 의해서만 Unlock할 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;lock의-종류&#34; &gt;Lock의 종류
&lt;span&gt;
    &lt;a href=&#34;#lock%ec%9d%98-%ec%a2%85%eb%a5%98&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;공용-로크shared-lock-s-lock&#34; &gt;공용 로크(Shared Lock, S-Lock)
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%b5%ec%9a%a9-%eb%a1%9c%ed%81%acshared-lock-s-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;다른 트랜잭션이 해당 데이터를 Read 할 수 있습니다.&lt;/p&gt;
&lt;h5 id=&#34;전용-로크exclusive-lock-x-lock&#34; &gt;전용 로크(Exclusive Lock, X-Lock)
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%84%ec%9a%a9-%eb%a1%9c%ed%81%acexclusive-lock-x-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;다른 트랜잭션이 해당 데이터를 Read/Write 할 수 없습니다.&lt;/p&gt;
&lt;h4 id=&#34;로크-단위lock-granularity&#34; &gt;로크 단위(Lock granularity)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%ed%81%ac-%eb%8b%a8%ec%9c%84lock-granularity&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;row, table, database 등 Locking할 자원의 크기를 말합니다.&lt;br&gt;
단위의 크기가 커질수록 병행성 수준은 낮아지고, 병행 제어 기법은 간단해집니다.&lt;/p&gt;
&lt;h4 id=&#34;로크-호환성-lock-compatibility&#34; &gt;로크 호환성 (Lock Compatibility)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a1%9c%ed%81%ac-%ed%98%b8%ed%99%98%ec%84%b1-lock-compatibility&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;이미 자원에 특정 Lock이 설정되어 있는 경우, 다른 트랜잭션도 해당 자원에 대해 Lock을 설정할 수 있는지 여부를 말합니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;구 분&lt;/th&gt;
&lt;th&gt;Request S-lock&lt;/th&gt;
&lt;th&gt;Request X-lock&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;S-locked data item&lt;/td&gt;
&lt;td&gt;ok&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X-locked data item&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;td&gt;not ok&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;locking-protocol&#34; &gt;Locking Protocol
&lt;span&gt;
    &lt;a href=&#34;#locking-protocol&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;아래 설명된 Protocol들 이외에도 기본적인 Locking Protocol은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션 T가 x에 대해 read(x)/write(x) 연산을 하려면 먼저 lock(x) 연산을 실행해야 한다.&lt;/li&gt;
&lt;li&gt;트랜잭션 T가 실행한 lock(x)에 대해서는 T가 모든 실행(Task)을 종료하기 전에 unlock(x) 연산을 수행해야 한다.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;em&gt;다른 트랜잭션에 의해 lock이 걸려있는&lt;/em&gt; x에 대해 &lt;strong&gt;lock(x)&lt;/strong&gt; 를 &lt;strong&gt;실행할 수 없다&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;em&gt;자신이 lock을 걸지않은 x&lt;/em&gt;에 대해 &lt;strong&gt;unlock(x)&lt;/strong&gt; 을 &lt;strong&gt;실행할 수 없다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;shared-locking-protocol공용-로킹-규약&#34; &gt;&lt;code&gt;Shared Locking Protocol(공용 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#shared-locking-protocol%ea%b3%b5%ec%9a%a9-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션 T는 &lt;strong&gt;read(x)&lt;/strong&gt; 전 반드시 &lt;mark style=&#34;background: #ADCCFFA6;&#34;&gt;lock-S(x)&lt;/mark&gt; 또는 &lt;mark style=&#34;background: #FFB86CA6;&#34;&gt;lock-X(x)&lt;/mark&gt;를 실행해야 함.&lt;/li&gt;
&lt;li&gt;트랜잭션 T는 &lt;strong&gt;write(x)&lt;/strong&gt; 전 반드시 &lt;mark style=&#34;background: #FFB86CA6;&#34;&gt;lock-X(x)&lt;/mark&gt;를 실행해야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 규약 때문에 공용 로킹 규약은 &lt;strong&gt;&lt;code&gt;직렬가능성(serializability)&lt;/code&gt;&lt;/strong&gt; 을 보장하지 못합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;직렬가능성(serializability)&lt;/code&gt;&lt;/strong&gt; : 비직렬 스케줄을 직렬 스케줄로 변환할 수 있는지를 의미합니다.
&lt;ul&gt;
&lt;li&gt;lock과 unlock이 병렬로 수행될 수 있으므로 병행 처리되는 트랜잭션들이 서로 간섭할 수 있어 직렬 가능성이 보장되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2plp2-phase-locking-protocol-2단계-로킹-규약&#34; &gt;&lt;code&gt;2PLP(2-Phase Locking Protocol, 2단계 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#2plp2-phase-locking-protocol-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;lock만 가능한 Phase와 unlock만 가능한 phase를 나누어 로킹을 수행하는 규약입니다.&lt;br&gt;
&lt;code&gt;직렬가능성&lt;/code&gt;을 &lt;strong&gt;보장&lt;/strong&gt;하지만, &lt;strong&gt;&lt;code&gt;Deadlock&lt;/code&gt;&lt;/strong&gt; 문제가 존재하는 규약입니다.&lt;br&gt;
변형으로는 &lt;code&gt;Strict 2PLP&lt;/code&gt;, &lt;code&gt;Rigorous 2PLP&lt;/code&gt;가 존재하며, 상용 DBMS에서는 이 둘 중 하나를 사용합니다.&lt;/p&gt;
&lt;h5 id=&#34;1-단계growing-phase&#34; &gt;1 단계(Growing Phase)
&lt;span&gt;
    &lt;a href=&#34;#1-%eb%8b%a8%ea%b3%84growing-phase&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;트랜잭션은 계속해 lock을 획득할 수 있으나, unlock 연산은 실행할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-단계shrink-phase&#34; &gt;2 단계(Shrink Phase)
&lt;span&gt;
    &lt;a href=&#34;#2-%eb%8b%a8%ea%b3%84shrink-phase&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;unlock 연산만 실행할 수 있으며, 일단 Lock을 해제하면 더 이상 lock을 획득할 수 없습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;strict-2plp엄격-2단계-로킹-규약&#34; &gt;Strict 2PLP(엄격 2단계 로킹 규약)
&lt;span&gt;
    &lt;a href=&#34;#strict-2plp%ec%97%84%ea%b2%a9-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;2PLP에 &amp;lsquo;모든 &lt;strong&gt;X-lock&lt;/strong&gt;은 &lt;em&gt;트랜잭션 완료시까지&lt;/em&gt; &lt;strong&gt;unlock 할 수 없다&lt;/strong&gt;&amp;lsquo;는 규칙이 추가된 형태입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현이 어려우나 성능이 높고&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;연쇄 복귀 문제(Cascading Rollback)&lt;/code&gt;&lt;/strong&gt; 가 발생하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;rigorous-2plp엄밀-2단계-로킹-규약&#34; &gt;Rigorous 2PLP(엄밀 2단계 로킹 규약)
&lt;span&gt;
    &lt;a href=&#34;#rigorous-2plp%ec%97%84%eb%b0%80-2%eb%8b%a8%ea%b3%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;2PLP에 &amp;lsquo;모든 &lt;strong&gt;lock&lt;/strong&gt;은 &lt;em&gt;트랜잭션 완료시까지&lt;/em&gt; &lt;strong&gt;unlock 할 수 없다&lt;/strong&gt;&amp;lsquo;는 규칙이 추가된 형태입니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;구현은 쉬우나 성능이 낮다&lt;/strong&gt;는 단점이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;multiple-granularity-locking-protocol다중-단위-로킹-규약&#34; &gt;&lt;code&gt;Multiple Granularity Locking Protocol(다중 단위 로킹 규약)&lt;/code&gt;
&lt;span&gt;
    &lt;a href=&#34;#multiple-granularity-locking-protocol%eb%8b%a4%ec%a4%91-%eb%8b%a8%ec%9c%84-%eb%a1%9c%ed%82%b9-%ea%b7%9c%ec%95%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;병행성 수준을 감소시키지 않기 위해, 필요 이상의 크기로 locking 하지 않는 방법입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;로킹 계층 트리 : DB -&amp;gt; 구역(Area) -&amp;gt; 파일(File) -&amp;gt; 레코드(Record)
&lt;img src=&#34;Multi-Granularity-tree-Hiererchy.png&#34; alt=&#34;Multi-Granularity-tree-Hiererchy.png&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DB: 모든 파일을 포함하는 데이터베이스입니다. 데이터베이스는 여러 파일로 구성됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;구역(Area): 파일들로 이뤄진 데이터베이스 내 특정 영역입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일(File): 관련된 레코드들의 그룹입니다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;레코드(Record): DB 테이블에서 하나의 행입니다. 레코드는 여러 필드로 구성됩니다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;optimistic-lockpessimistic-lock란&#34; &gt;Optimistic Lock/Pessimistic Lock란?
&lt;span&gt;
    &lt;a href=&#34;#optimistic-lockpessimistic-lock%eb%9e%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;h3 id=&#34;낙관적-로크optimistic-lock&#34; &gt;낙관적 로크(Optimistic Lock)
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%99%ea%b4%80%ec%a0%81-%eb%a1%9c%ed%81%acoptimistic-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;다른 트랜잭션과 충돌하지 않는다고 가정하고, 별도의 Locking 없이 자원에 접근하는 것을 말합니다.&lt;br&gt;
병행 제어를 위해 아래 세 과정을 수행하며, 각 과정마다 Start(T), Validation(T), Finish(T) 세 가지의 &lt;strong&gt;&lt;code&gt;타임스탬프&lt;/code&gt;&lt;/strong&gt; 를 사용합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;타임스탬프&lt;/code&gt;&lt;/strong&gt; : 시스템에서 &lt;strong&gt;트랜잭션&lt;/strong&gt;을 &lt;strong&gt;유일하게 식별&lt;/strong&gt;하기 위해 부여한 &lt;strong&gt;식별자(identifier)&lt;/strong&gt; 로, 트랜잭션이 &lt;strong&gt;시스템에 들어온 순서대로&lt;/strong&gt; 부여합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;과정&#34; &gt;과정
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%bc%ec%a0%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;판독 단계(Read Step)&lt;/code&gt; : 트랜잭션에 필요한 자료를 DB로 부터 읽어 &lt;strong&gt;Local Working Area에 복사&lt;/strong&gt;합니다. 이후 &lt;strong&gt;모든 갱신은 사본을 대상&lt;/strong&gt;으로 수행합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;확인 단계(Validation Step)&lt;/code&gt;: &lt;strong&gt;직렬(Serialization) 가능성 위반 여부&lt;/strong&gt;를 &lt;strong&gt;검사&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;기록 단계(Write Step)&lt;/code&gt;: 확인 단계를 통과하면 &lt;strong&gt;DB에 반영&lt;/strong&gt;하고, &lt;em&gt;통과하지 못했다면 실행 결과는 취소&lt;/em&gt;하고 트랜잭션은 복귀합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;비관적-로크pessimistic-lock&#34; &gt;비관적 로크(Pessimistic Lock)
&lt;span&gt;
    &lt;a href=&#34;#%eb%b9%84%ea%b4%80%ec%a0%81-%eb%a1%9c%ed%81%acpessimistic-lock&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;다른 트랜잭션과 충돌한다고 가정하고, 트랜잭션을 처리하기 전에 자원에 대해 Locking을 시도하는것을 말합니다.&lt;/p&gt;
&lt;h4 id=&#34;과정-1&#34; &gt;과정
&lt;span&gt;
    &lt;a href=&#34;#%ea%b3%bc%ec%a0%95-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;자원에 대해 Lock을 겁니다.&lt;/li&gt;
&lt;li&gt;트랜잭션을 실행합니다.&lt;/li&gt;
&lt;li&gt;자원에 대해 Unlock을 수행합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;트랜잭션이-비정상-종료된-경우-lock을-해제할-해결책이-있는가-없다면-직접-해결-가능한가&#34; &gt;트랜잭션이 비정상 종료된 경우 Lock을 해제할 해결책이 있는가? 없다면 직접 해결 가능한가?
&lt;span&gt;
    &lt;a href=&#34;#%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%b4-%eb%b9%84%ec%a0%95%ec%83%81-%ec%a2%85%eb%a3%8c%eb%90%9c-%ea%b2%bd%ec%9a%b0-lock%ec%9d%84-%ed%95%b4%ec%a0%9c%ed%95%a0-%ed%95%b4%ea%b2%b0%ec%b1%85%ec%9d%b4-%ec%9e%88%eb%8a%94%ea%b0%80-%ec%97%86%eb%8b%a4%eb%a9%b4-%ec%a7%81%ec%a0%91-%ed%95%b4%ea%b2%b0-%ea%b0%80%eb%8a%a5%ed%95%9c%ea%b0%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;잘 설계된 DBMS에서는 Lock이 오랫동안 유지되어 Deadlock과 같은 상황을 발생시키지 않도록 여러 대비책을 갖고 있으며, 대부분의 DBMS에서는 Lock 관리를 위한 기능을 제공합니다.&lt;/p&gt;
&lt;h3 id=&#34;lock-timeout&#34; &gt;Lock Timeout
&lt;span&gt;
    &lt;a href=&#34;#lock-timeout&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;Lock을 걸 때, 타임아웃을 설정해 일정시간이 지나면 자동으로 Lock을 해제하도록 합니다.&lt;/p&gt;
&lt;h3 id=&#34;deadlock-detection&#34; &gt;Deadlock Detection
&lt;span&gt;
    &lt;a href=&#34;#deadlock-detection&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;교착상태가 발생하면 사후에 트랜잭션들 중 하나를 강제종료(&lt;code&gt;rollback&lt;/code&gt;) 시키는 조치를 취하는 방식입니다.&lt;/p&gt;
&lt;h3 id=&#34;일반적인-회복-방법&#34; &gt;일반적인 회복 방법
&lt;span&gt;
    &lt;a href=&#34;#%ec%9d%bc%eb%b0%98%ec%a0%81%ec%9d%b8-%ed%9a%8c%eb%b3%b5-%eb%b0%a9%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;이외에도 Redo, Undo와 같은 회복 방법을 통해 트랜잭션으로 손상된 부분을 회복시킬 수 있습니다.&lt;/p&gt;
&lt;h4 id=&#34;redo-media-recovery&#34; &gt;Redo (Media Recovery)
&lt;span&gt;
    &lt;a href=&#34;#redo-media-recovery&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;비소멸장치(디스크, 테이프 등)의 내용 손상에 대한 회복 기법입니다.&lt;br&gt;
가장 최근의 복제본(dump)을 적재시키고, 해당 복제본 이후의 변경을 log를 이용해 재실행하여 DB를 복원합니다.&lt;/p&gt;
&lt;h4 id=&#34;undo&#34; &gt;Undo
&lt;span&gt;
    &lt;a href=&#34;#undo&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;log를 이용해 모든 변경을 취소시키므로써 DB를 복원합니다.&lt;/p&gt;
&lt;h4 id=&#34;소멸-장치의-정보-회복&#34; &gt;소멸 장치의 정보 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%86%8c%eb%a9%b8-%ec%9e%a5%ec%b9%98%ec%9d%98-%ec%a0%95%eb%b3%b4-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;log-이용-회복&#34; &gt;Log 이용 회복
&lt;span&gt;
    &lt;a href=&#34;#log-%ec%9d%b4%ec%9a%a9-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;트랜잭션이 Write 연산을 실행하거나, 트랜잭션의 시작/완료/철회와 같은 특별 활동시 기록되는 Log를 활용해 회복하는 방법입니다.&lt;br&gt;
Log는 &lt;code&gt;On-line log(실행중인 트랜잭션에 대한 로그)&lt;/code&gt;, &lt;code&gt;Archival log(누적되는 로그를 안정 저장장치에 저장한 것)&lt;/code&gt;로 나뉩니다.&lt;/p&gt;
&lt;h6 id=&#34;지연-갱신deferred-update의-회복&#34; &gt;지연 갱신(Deferred Update)의 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%a7%80%ec%97%b0-%ea%b0%b1%ec%8b%a0deferred-update%ec%9d%98-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;트랜잭션이 부분 완료될 때 까지 DB 변경내역을 log에 전부 기록한 뒤, 부분 완료되면 보류시킨 Output 연산을 log를 사용해 처리합니다.&lt;br&gt;
트랜잭션 &lt;strong&gt;실행 중 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;처음부터 다시 실행&lt;/strong&gt;하고, &lt;strong&gt;완료 후 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;Log을 사용해 트랜잭션을 Redo&lt;/strong&gt; 합니다.&lt;/p&gt;
&lt;h6 id=&#34;즉시-갱신immediate-update의-회복&#34; &gt;즉시 갱신(Immediate Update)의 회복
&lt;span&gt;
    &lt;a href=&#34;#%ec%a6%89%ec%8b%9c-%ea%b0%b1%ec%8b%a0immediate-update%ec%9d%98-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h6&gt;&lt;p&gt;트랜잭션이 실행되는 동안 발생한 변경 내용을 DB에 그대로 반영해 처리합니다.&lt;br&gt;
트랜잭션 &lt;strong&gt;실행 중 장애가 발생&lt;/strong&gt;했다면 해당 &lt;strong&gt;트랜잭션에 대한 Undo&lt;/strong&gt;를 실행하고, &lt;strong&gt;완료 후 장애가 발생&lt;/strong&gt;했다면 &lt;strong&gt;트랜잭션을 Redo&lt;/strong&gt; 합니다.&lt;/p&gt;
&lt;h5 id=&#34;검사시점check-point-회복&#34; &gt;검사시점(Check Point) 회복
&lt;span&gt;
    &lt;a href=&#34;#%ea%b2%80%ec%82%ac%ec%8b%9c%ec%a0%90check-point-%ed%9a%8c%eb%b3%b5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;&lt;em&gt;Log를 이용할 경우&lt;/em&gt; Redo/Undo 대상 트랜잭션을 찾기위해 &lt;strong&gt;log 전체를 조사&lt;/strong&gt;하거나,&lt;strong&gt;불필요한 Redo를 반복&lt;/strong&gt;한다는 &lt;strong&gt;문제를 해결&lt;/strong&gt;하기 위해 일정 간격으로 &lt;strong&gt;CheckPoint를 설치&lt;/strong&gt;해 이를 사용하는 기법입니다.&lt;br&gt;
Log를 차례로 검사하며 트랜잭션의 start를 만났다면 해당 트랜잭션을 Undo-list에, 트랜잭션의 commit을 만났다면 Undo-list에서 삭제하고 Redo-list에 추가합니다. 이후 Undo-list의 트랜잭션을 log에 기록된 역순으로 Undo를, Redo-list의 트랜잭션을 log에 기록된 순서로 Redo를 수행합니다.&lt;/p&gt;
&lt;h5 id=&#34;그림자-페이징shadow-paging-기법&#34; &gt;그림자 페이징(Shadow Paging) 기법
&lt;span&gt;
    &lt;a href=&#34;#%ea%b7%b8%eb%a6%bc%ec%9e%90-%ed%8e%98%ec%9d%b4%ec%a7%95shadow-paging-%ea%b8%b0%eb%b2%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;p&gt;트랜잭션을 실행하는 동안 2개의 page table을 유지하는 방법입니다.&lt;br&gt;
current page table은 write 연산을 실행할 때 변경하며, shadow page table은 트랜잭션 실행 직전의 상태를 유지합니다.&lt;br&gt;
트랜잭션 완료 전 장애가 발생한 경우 shadow page table을 복사해 실행 직전으로 복귀시킵니다.&lt;/p&gt;
&lt;h2 id=&#34;참고-자료&#34; &gt;참고 자료
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0-%ec%9e%90%eb%a3%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;전공과목 강의자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)&#34;&gt;Isolation (database systems) - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/dbms-dirty-read-in-sql/&#34;&gt;Dirty Read in SQL - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/concurrency-problems-in-dbms-transactions/&#34;&gt;Concurrency problems in DBMS Transactions - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jidum.com/jidums/view.do?jidumId=282&#34;&gt;동시성제어개요 - 지식덤프&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/serializability-in-dbms/&#34;&gt;Serializability in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.jboss.org/hibernate/orm/4.1/devguide/en-US/html/ch05.html&#34;&gt;Chapter 5. Locking - Hibernate Community Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/lock-based-concurrency-control-protocol-in-dbms/&#34;&gt;Lock Based Concurrency Control Protocol in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/docs/en/db2/11.5?topic=overview-optimistic-locking&#34;&gt;Optimistic locking - IBM Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://help.sap.com/doc/saphelp_nw73ehp1/7.31.19/en-us/47/dc35af5bc33b8be10000000a421937/content.htm?no_cache=true&#34;&gt;How Optimistic Locks Work - SAP Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://magicsoftware.my.salesforce-sites.com/PublicKnowledge/articles/bl_Reference/Physical-Locks-xpa-3x&#34;&gt;Reference: Physical Locks (Magic xpa 3.x) - Salesforce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/multiple-granularity-locking-in-dbms/&#34;&gt;Multiple Granularity Locking in DBMS - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html&#34;&gt;MySQL :: MySQL 8.0 Reference Manual :: 17.7.1 InnoDB Locking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.umsl.edu/~joshik/msis480/chapt06.htm&#34;&gt;6 Database Management - University of Missouri–St. Louis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>[자료구조] B Tree와 B&#43;tree 알아보기</title>
      <link>https://cloudsoswift.github.io/post/develop/database/b-tree-b&#43;tree/</link>
      <pubDate>Sun, 18 Feb 2024 09:58:46 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/database/b-tree-b&#43;tree/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 2월 13일에 발표한(정확히는 나는 2일 뒤인 15일에 발표했다.) &lt;strong&gt;B 트리와 B+ 트리&lt;/strong&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;/p&gt;
&lt;h1 id=&#34;b-tree와-btree는-무엇일까&#34; &gt;B-Tree와 B+Tree는 무엇일까
&lt;span&gt;
    &lt;a href=&#34;#b-tree%ec%99%80-btree%eb%8a%94-%eb%ac%b4%ec%97%87%ec%9d%bc%ea%b9%8c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;b-트리-b-tree&#34; &gt;B 트리 (B-Tree)
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac-b-tree&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;B-tree-architecture.png&#34; alt=&#34;B-tree-architecture.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;이진 트리를 확장해 한 노드가 가질 수 있는 자식 노드의 갯수가 2개 이상인 &lt;code&gt;자가 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt;의 일종이며, 각 노드가 갖고있는 키 들은 정렬되어 있습니다.&lt;br&gt;
다른 자체 균형 이진 검색 트리와 달리, B 트리는 DB, File System과 같이 큰 데이터 블록을 읽고 써야하는 스토리지 시스템에 적합합니다.&lt;/p&gt;
&lt;h3 id=&#34;b-트리의-성질&#34; &gt;B 트리의 성질
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%84%b1%ec%a7%88&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;차수 m(&lt;em&gt;노드 중 가장 많은 자식을 갖는 노드의 자식 수&lt;/em&gt;)을 갖는 B 트리는 아래와 같은 성질을 만족합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 노드는 최대 m개의 자식이 존재합니다.&lt;/li&gt;
&lt;li&gt;모든 내부 노드는 최소 ⌈m/2⌉ 개의 자식이 존재합니다.&lt;/li&gt;
&lt;li&gt;루트 노드는 (&lt;em&gt;리프가 아닌 한&lt;/em&gt;) 최소 2개의 자식이 존재합니다.&lt;/li&gt;
&lt;li&gt;k개의 자식이 있는 &lt;em&gt;리프가 아닌&lt;/em&gt; 노드는 k-1 개의 키를 갖고 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-노드들&#34; &gt;B 트리의 노드들
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%eb%85%b8%eb%93%9c%eb%93%a4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;B 트리를 이루는 노드는 내부 노드, 루트 노드, 리프 노드로 구성됩니다.&lt;/p&gt;
&lt;h4 id=&#34;내부-노드-internal-node&#34; &gt;내부 노드 (Internal Node)
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%b4%eb%b6%80-%eb%85%b8%eb%93%9c-internal-node&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;em&gt;적어도 하나의 자식&lt;/em&gt;을 갖는 노드로, &lt;em&gt;리프 노드와 루트 노드를 제외&lt;/em&gt;한 &lt;strong&gt;모든 노드&lt;/strong&gt;입니다.&lt;br&gt;
이들은 일반적으로 하위 포인터, 데이터 포인터, 검색 키의 순서 집합으로 표현됩니다.&lt;br&gt;
모든 &lt;code&gt;내부 노드&lt;/code&gt;는 최대 U개에서 최소 L개의 자식을 포함합니다. 따라서 &lt;code&gt;내부 노드&lt;/code&gt; 내 요소 수는 &amp;lsquo;하위 포인터 수 - 1&amp;rsquo; 입니다. (요소 수는 L-1 보다 높고, U-1 보다 낮습니다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;따라서 U는 2L 또는 2L - 1 이고, 각 &lt;code&gt;내부 노드&lt;/code&gt;들은 &lt;strong&gt;최소 절반&lt;/strong&gt; 이상 채워져 있습니다.
&lt;ul&gt;
&lt;li&gt;이는 두 &lt;em&gt;절반이 가득 찬&lt;/em&gt; 내부 노드를 하나의 노드로 &lt;strong&gt;병합하거나&lt;/strong&gt;, 하나의 완전한 노드를 두 개의 정상적인 노드로 &lt;strong&gt;나눌 수 있음&lt;/strong&gt;을 의미합니다.&lt;/li&gt;
&lt;li&gt;이러한 점을 통해, B 트리는 새 값을 삽입하거나 삭제하고 &lt;em&gt;B 트리 속성을 유지하도록&lt;/em&gt; 트리를 조절할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;내부-노드의-구조&#34; &gt;내부 노드의 구조
&lt;span&gt;
    &lt;a href=&#34;#%eb%82%b4%eb%b6%80-%eb%85%b8%eb%93%9c%ec%9d%98-%ea%b5%ac%ec%a1%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$pt_0$&lt;/th&gt;
&lt;th&gt;$k_0$&lt;/th&gt;
&lt;th&gt;$pt_1$&lt;/th&gt;
&lt;th&gt;$pr_0$&lt;/th&gt;
&lt;th&gt;$k_1$&lt;/th&gt;
&lt;th&gt;$pt_2$&lt;/th&gt;
&lt;th&gt;$pr_1$&lt;/th&gt;
&lt;th&gt;&amp;hellip;&lt;/th&gt;
&lt;th&gt;$k_{K-1}$&lt;/th&gt;
&lt;th&gt;$pt_K$&lt;/th&gt;
&lt;th&gt;$pr_{K-1}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;$pt_i$ : 하위 서브 트리의 루트 노드를 가리키는 포인터&lt;/li&gt;
&lt;li&gt;$pr_i$ : 데이터를 갖고 있는 레코드를 가리키는 포인터&lt;/li&gt;
&lt;li&gt;$k_i$: zero-based 노드 인덱스 $i$의 검색 키&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한, 각 내부 노드의 키는 해당 노드의 서브 트리를 나누는 기준 값으로 사용됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약 내부 노드에 3가지 자식 노드(&lt;em&gt;또는 트리&lt;/em&gt;)가 있는 경우, 내부 노드에는 최소 2개의 키(예시로 $a_1$, $a_2$)가 있어야 합니다.
&lt;ul&gt;
&lt;li&gt;가장 왼쪽 서브 트리의 모든 값은 $a_1$보다 작고, 중간의 서브 트리의 모든 값은 $a_1$ 보다 크고 $a_2$보다 작으며, 가장 오른쪽 서브 트리의 모든 값은 $a_2$보다 큽니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;루트-노드-root-node&#34; &gt;루트 노드 (Root Node)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a3%a8%ed%8a%b8-%eb%85%b8%eb%93%9c-root-node&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;루트 노드의 자식 수는 내부 노드와 동일한 상한이 존재하지만, 하한은 존재하지 않습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 트리에 L-1 보다 적은 요소가 존재한다면, 루트 노드는 트리에서 자식이 전혀 없는 유일한 노드가 됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;리프-노드-leaf-node&#34; &gt;리프 노드 (Leaf Node)
&lt;span&gt;
    &lt;a href=&#34;#%eb%a6%ac%ed%94%84-%eb%85%b8%eb%93%9c-leaf-node&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;실질적인 데이터 객체/청크를 갖는 노드입니다. 모든 리프 노드들은 &lt;strong&gt;같은 레벨에 존재&lt;/strong&gt;해야 합니다.&lt;/p&gt;
&lt;h3 id=&#34;b-트리의-장점&#34; &gt;B 트리의 장점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%9e%a5%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;정렬되어있는-키&#34; &gt;정렬되어있는 키
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%eb%a0%ac%eb%90%98%ec%96%b4%ec%9e%88%eb%8a%94-%ed%82%a4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;저장된 키들이 정렬되어 있어, 순차적인 순회에 유용합니다.&lt;/p&gt;
&lt;h4 id=&#34;동일한-삽입삭제검색-시간-복잡도&#34; &gt;동일한 삽입/삭제/검색 시간 복잡도
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%9d%bc%ed%95%9c-%ec%82%bd%ec%9e%85%ec%82%ad%ec%a0%9c%ea%b2%80%ec%83%89-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;기존의 이진 탐색 트리와 달리, 한 노드에 저장할 수 있는 키의 수가 많아 트리는 더 얕은 높이를 가질 수 있게 되었습니다.&lt;br&gt;
이러한 계층형 인덱스를 사용하므로써 디스크 I/O가 줄어들어 더 낮은 삽입/삭제/검색 시간 복잡도를 가집니다.
이러한 점 때문에 B 트리는 대용량 데이터 셋, 실시간 애플리케이션에 적합합니다.&lt;br&gt;
특히 DB에서 B 트리 인덱스를 사용하면 검색 성능을 크게 향상 시킬 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DBMS에서는 인덱스 키 - PK가 매칭이 되어있는 B 트리를 만들어두고 이를 사용합니다.
&lt;ul&gt;
&lt;li&gt;인덱스를 통해 PK를 찾고, 찾은 PK를 통해 레코드를 찾습니다.&lt;/li&gt;
&lt;li&gt;DBMS가 PK를 통해 레코드를 찾으려면, 테이블 전체를 뒤져 검색 해야하지만, B 트리 인덱스를 활용하면 트리를 몇 단계 탐색하므로써 PK를 찾을 수 있고 그 PK를 통해 레코드를 찾아올 수 있으므로 속도가 더 빠릅니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;자체-균형&#34; &gt;자체 균형
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%ec%b2%b4-%ea%b7%a0%ed%98%95&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;B 트리는 &lt;code&gt;자체 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt;의 일종이므로 항상 최적의 높이를 유지하고자 지속적으로 스스로 균형을 맞추려고 합니다.&lt;br&gt;
따라서 기존의 이진 검색 트리의 경우 작업이 최악의 경우(&lt;em&gt;트리가 한쪽으로 쏠린 경우&lt;/em&gt;) O(N)의 시간 복잡도를 가졌지만, B 트리는 작업이 최악의 경우에도 O(logN)의 시간복잡도를 유지하도록 보장합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;자체 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt; : 임의의 아이템 삽입/삭제 이후 자동으로 높이를 낮게 유지하는 노드 기반의 이진 검색 트리를 의미합니다. 대표적인 예시로 AVL 트리, B 트리, RBT 등이 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-단점&#34; &gt;B 트리의 단점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%eb%8b%a8%ec%a0%90&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;더많은-디스크-공간-사용&#34; &gt;더많은 디스크 공간 사용
&lt;span&gt;
    &lt;a href=&#34;#%eb%8d%94%eb%a7%8e%ec%9d%80-%eb%94%94%ec%8a%a4%ed%81%ac-%ea%b3%b5%ea%b0%84-%ec%82%ac%ec%9a%a9&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;균형 유지를 위해 추가적인 포인터 및 헤더 정보를 유지해야 하므로 더 많은 공간을 사용합니다.&lt;/p&gt;
&lt;h4 id=&#34;다른-자료-구조에-비해-느린-속도&#34; &gt;다른 자료 구조에 비해 느린 속도
&lt;span&gt;
    &lt;a href=&#34;#%eb%8b%a4%eb%a5%b8-%ec%9e%90%eb%a3%8c-%ea%b5%ac%ec%a1%b0%ec%97%90-%eb%b9%84%ed%95%b4-%eb%8a%90%eb%a6%b0-%ec%86%8d%eb%8f%84&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;삽입/삭제 연산 이후 균형 유지를 위해 회전, 병합과 같은 재배치 작업을 수행할 수 있으며, 이 과정에서 오버헤드가 발생할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&#34;b-트리-b-tree-1&#34; &gt;B+ 트리 (B+ Tree)
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac-b-tree-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;B-plus-tree-architecure.png&#34; alt=&#34;B-plus-tree-architecure.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위는 분기 인자 b=4이며, 1~7 범위의 키와 $d_1$ ~ $d_7$의 데이터 값들을 연결하는 b+ 트리 예시 입니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;B 트리의 변종 중 하나로, 각 노드가 키-값 쌍이 아닌 &lt;strong&gt;키만 포함&lt;/strong&gt;하며(인덱스 인트리) 하단에 &lt;strong&gt;링크드 리프 노드&lt;/strong&gt;들로 이뤄진 &lt;strong&gt;추가적인 레벨&lt;/strong&gt;(데이터 엔트리)이 붙어있는 B 트리로 볼 수 있습니다.&lt;br&gt;
노드 당 m개 이하의 자식이 있는 &lt;code&gt;다항 트리(m-ary tree)&lt;/code&gt; 라고도 일컬어지며, &lt;code&gt;분기 인자(branching factor, 각 노드 당 자식의 수)&lt;/code&gt; $b$ 를 기준으로 삽입/삭제/검색 작업이 $O(log_b{N})$ 의 시간 복잡도를 가집니다.&lt;br&gt;
B+ 트리의 핵심 가치는 &lt;code&gt;블록 지향 스토리지(block-oriented storage)&lt;/code&gt;(&lt;em&gt;특히 파일 시스템&lt;/em&gt;)에서 &lt;strong&gt;효율적인 검색&lt;/strong&gt;이 가능하도록 데이터를 저장하는 것입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이진 검색 트리와 달리, B+ 트리는 팬아웃이 매우 높아 트리 내 요소를 찾는데 필요한 I/O 작업 횟수를 줄일 수 있기 때문입니다.&lt;br&gt;
B+ 트리는 MS SQL, Oracle, SQLite 등의 RDBMS에서 &lt;strong&gt;테이블 인덱스&lt;/strong&gt;를 구현하는데 활용됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-성질-1&#34; &gt;B+ 트리의 성질
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%84%b1%ec%a7%88-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;p&gt;분기 인자가 $b$ 이며, 높이 h인 b+ 트리는 다음과 같은 성질을 갖습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;저장된 레코드는 최대 $n_{max} = b^h - b^{h-1}$ 개여야 합니다.&lt;/li&gt;
&lt;li&gt;저장된 레코드는 최소 $n_{min} = 2\lceil {b\over2} \rceil^{h-1} - 2\lceil {b\over2}\rceil^{h-2}$ 개여야 합니다.&lt;/li&gt;
&lt;li&gt;트리를 저장하기 위한 공간 복잡도는 O(n) 입니다.&lt;/li&gt;
&lt;li&gt;레코드를 삽입/삭제/검색하는데 $O(log_b n)$의 시간 복잡도를 갖습니다.&lt;/li&gt;
&lt;li&gt;B+ 트리 구조는 레코드 수가 증가/감소 함에 따라 확장/수축 할 수 있으며, 크기에 제한이 없습니다.&lt;/li&gt;
&lt;li&gt;리프 노드들이 링크드 리스트 형태로 이어져 있어 빠른 &lt;code&gt;중위 순회(in-order traversal)&lt;/code&gt;가 가능합니다.&lt;/li&gt;
&lt;li&gt;리프 노드에서 부모 노드가 갖고 있는 키를 &lt;strong&gt;중복적&lt;/strong&gt;으로 가질 수 있습니다(&lt;code&gt;Key Duplication&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리의-장점-1&#34; &gt;B+ 트리의 장점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ec%9e%a5%ec%a0%90-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;순서대로-탐색이-가능&#34; &gt;순서대로 탐색이 가능
&lt;span&gt;
    &lt;a href=&#34;#%ec%88%9c%ec%84%9c%eb%8c%80%eb%a1%9c-%ed%83%90%ec%83%89%ec%9d%b4-%ea%b0%80%eb%8a%a5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;B 트리의 경우 모든 데이터 포인터가 리프 노드에 있지 않기 때문에 순서대로 연결된 리스트를 만들 수 없지만, B+ 트리의 경우 모든 데이터 포인터가 리프 노드에 존재하므로 순서대로 연결된 리스트를 만들 수 있습니다. 이를 통해 범위 쿼리나 정렬된 데이터가 필요한 작업들을 쉽게 수행할 수 있습니다.&lt;br&gt;
이러한 점 때문에, B+ 트리는 DB 시스템 인덱스를 구축하는데 유용합니다.&lt;/p&gt;
&lt;h4 id=&#34;정렬되어있는-키-1&#34; &gt;정렬되어있는 키
&lt;span&gt;
    &lt;a href=&#34;#%ec%a0%95%eb%a0%ac%eb%90%98%ec%96%b4%ec%9e%88%eb%8a%94-%ed%82%a4-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h4 id=&#34;자체-균형-1&#34; &gt;자체 균형
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%ec%b2%b4-%ea%b7%a0%ed%98%95-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h4 id=&#34;동일한-삽입삭제검색-시간-복잡도-1&#34; &gt;동일한 삽입/삭제/검색 시간 복잡도
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%9d%bc%ed%95%9c-%ec%82%bd%ec%9e%85%ec%82%ad%ec%a0%9c%ea%b2%80%ec%83%89-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h3 id=&#34;b-트리의-단점-1&#34; &gt;B+ 트리의 단점
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%eb%8b%a8%ec%a0%90-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;h4 id=&#34;b-트리-대비-더-높은-메모리-사용&#34; &gt;B 트리 대비 더 높은 메모리 사용
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac-%eb%8c%80%eb%b9%84-%eb%8d%94-%eb%86%92%ec%9d%80-%eb%a9%94%eb%aa%a8%eb%a6%ac-%ec%82%ac%ec%9a%a9&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;&lt;em&gt;키, 값(데이터 포인터)을 각 노드에 저장&lt;/em&gt;하는 B 트리와 달리, B+ 트리는 내부 노드에는 키만 저장하고 리프 노드 층에 데이터를 저장하기 때문에 &lt;em&gt;키의 개수에 비례해&lt;/em&gt; &lt;strong&gt;추가적인 메모리가 필요&lt;/strong&gt;합니다.&lt;/p&gt;
&lt;h1 id=&#34;b-tree가-b-tree에-비해-반드시-좋다고-할-수-있을까-그렇지-않다면-어떤-단점이&#34; &gt;B+ Tree가 B Tree에 비해 반드시 좋다고 할 수 있을까? 그렇지 않다면 어떤 단점이?
&lt;span&gt;
    &lt;a href=&#34;#b-tree%ea%b0%80-b-tree%ec%97%90-%eb%b9%84%ed%95%b4-%eb%b0%98%eb%93%9c%ec%8b%9c-%ec%a2%8b%eb%8b%a4%ea%b3%a0-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c-%ea%b7%b8%eb%a0%87%ec%a7%80-%ec%95%8a%eb%8b%a4%eb%a9%b4-%ec%96%b4%eb%96%a4-%eb%8b%a8%ec%a0%90%ec%9d%b4&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;B-tree-and-B+tree.png&#34; alt=&#34;B-tree-and-B+tree.png&#34;&gt;&lt;br&gt;
&lt;em&gt;웬만한 경우&lt;/em&gt; &lt;strong&gt;B+ 트리&lt;/strong&gt;가 B 트리 보다 &lt;strong&gt;더 빠르게 검색&lt;/strong&gt;할 수 있기 때문에 좋다고 할 수 있습니다. &lt;br&gt;
B+ 트리는 &lt;em&gt;B 트리와 달리&lt;/em&gt; 내부 노드에 값(데이터)을 저장하지 않으므로써 내부 노드에 저장되는 키의 수, 즉 &lt;strong&gt;&lt;code&gt;팬아웃&lt;/code&gt;을 최대화&lt;/strong&gt; 했고, 이를 통해 &lt;strong&gt;트리의 높이를 최소화&lt;/strong&gt; 하기 때문입니다.&lt;br&gt;
또한 &lt;strong&gt;&lt;code&gt;범위 검색 작업&lt;/code&gt;&lt;/strong&gt; 을 &lt;strong&gt;효율적&lt;/strong&gt;으로 진행할 수 있습니다. &lt;strong&gt;리프 노드가 서로 연결&lt;/strong&gt;되어 있기 때문입니다.&lt;br&gt;
그리고 삽입/삭제 작업이 &lt;strong&gt;리프 노드에서 수행&lt;/strong&gt;되어 &lt;strong&gt;더 쉽고 시간 소모가 적습니다&lt;/strong&gt;.&lt;br&gt;
하지만, B 트리의 경우 &lt;em&gt;특정 노드를 자주 사용하는 경우&lt;/em&gt; &lt;strong&gt;더 빠를 수&lt;/strong&gt; 있습니다. 자주 사용되는 &lt;strong&gt;노드를 &lt;code&gt;상승&lt;/code&gt;&lt;/strong&gt; 시킬 수 있기 때문에, 원하는 데이터에 도달하는데 필요한 비교 작업이 적어지기 때문입니다.&lt;/p&gt;
&lt;h1 id=&#34;db에서-굳이-rbt와-같은-트리를-사용하지-않고-b-treebtree를-사용하는-이유는&#34; &gt;DB에서 굳이 RBT와 같은 트리를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유는?
&lt;span&gt;
    &lt;a href=&#34;#db%ec%97%90%ec%84%9c-%ea%b5%b3%ec%9d%b4-rbt%ec%99%80-%ea%b0%99%ec%9d%80-%ed%8a%b8%eb%a6%ac%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%ec%a7%80-%ec%95%8a%ea%b3%a0-b-treebtree%eb%a5%bc-%ec%82%ac%ec%9a%a9%ed%95%98%eb%8a%94-%ec%9d%b4%ec%9c%a0%eb%8a%94&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;더 빠르기 때문&lt;/strong&gt;입니다.&lt;br&gt;
이를 설명하려면 먼저 RBT, 즉 &lt;code&gt;레드-블랙 트리(Red-Black Tree)&lt;/code&gt;의 구조에 대해 알아야 합니다.&lt;br&gt;
RBT는 B 트리/B+ 트리와 마찬가지로 &lt;code&gt;자가 균형 이진 검색 트리(Self Balancing Binary Search Tree)&lt;/code&gt; 의 일종으로, 각각의 노드가 &lt;strong&gt;레드&lt;/strong&gt; 또는 &lt;strong&gt;블랙&lt;/strong&gt;의 색상 속성을 갖습니다.&lt;br&gt;
루트 노드와 모든 리프 노드들은 블랙이며, 레드 노드의 양 자식 노드들은 모두 블랙이라는 특징 때문에, RBT는 블랙과 레드가 번갈아 나오는 형태를 띄게 됩니다(물론 &lt;em&gt;블랙 다음에 블랙이 나올 수도&lt;/em&gt; 있습니다).&lt;br&gt;
이러한 특징 때문에 &lt;em&gt;루트 노드로 부터&lt;/em&gt; &lt;mark style=&#34;background: orange;&#34;&gt;가장 먼 리프 노드까지의 거리&lt;/mark&gt;가 &lt;mark style=&#34;background: skyblue;&#34;&gt;가장 가까운 리프 노드까지의 거리&lt;/mark&gt;의 &lt;strong&gt;2배 보다 항상 짧다&lt;/strong&gt;는 특성을 지니고, 이 때문에 삽입/삭제/탐색에 있어 B 트리와 마찬가지로 $O(logN)$의 시간 복잡도를 갖게 됩니다.&lt;br&gt;
하지만, &lt;strong&gt;RBT&lt;/strong&gt;는 일반적인 BST와 같이 &lt;strong&gt;자식을 둘 밖에&lt;/strong&gt; 가질 수 없으나 &lt;strong&gt;B 트리&lt;/strong&gt;는 &lt;strong&gt;둘 이상&lt;/strong&gt; 가질 수 있기 때문에 훨씬 &lt;strong&gt;트리 높이가 짧아지고&lt;/strong&gt; &lt;strong&gt;더 적은 디스크 I/O 작업을 수행&lt;/strong&gt;해 결과적으로 더 빠른 속도로 탐색을 진행할 수 있습니다.&lt;br&gt;
또한 &lt;em&gt;B 트리의 경우&lt;/em&gt; 내부 노드의 두 개 이상의 키들을 &lt;strong&gt;&lt;code&gt;배열&lt;/code&gt;&lt;/strong&gt; 로 다루므로 RBT가 하위 노드들을 참조해 탐색하는 것 보다 &lt;strong&gt;더 빠른 접근 속도&lt;/strong&gt;를 갖게 됩니다.&lt;br&gt;
이러한 차이 때문에 DB에서 B 트리/B+ 트리를 사용하게 됩니다.&lt;/p&gt;
&lt;h1 id=&#34;오름차순으로-정렬된-인덱스가-있다고-할-때-내림차순-정렬을-시도할-경우-성능이-어떻게-될까-b-treebtree의-구조를-기반으로&#34; &gt;오름차순으로 정렬된 인덱스가 있다고 할 때, 내림차순 정렬을 시도할 경우 성능이 어떻게 될까? (B-Tree/B+Tree의 구조를 기반으로)
&lt;span&gt;
    &lt;a href=&#34;#%ec%98%a4%eb%a6%84%ec%b0%a8%ec%88%9c%ec%9c%bc%eb%a1%9c-%ec%a0%95%eb%a0%ac%eb%90%9c-%ec%9d%b8%eb%8d%b1%ec%8a%a4%ea%b0%80-%ec%9e%88%eb%8b%a4%ea%b3%a0-%ed%95%a0-%eb%95%8c-%eb%82%b4%eb%a6%bc%ec%b0%a8%ec%88%9c-%ec%a0%95%eb%a0%ac%ec%9d%84-%ec%8b%9c%eb%8f%84%ed%95%a0-%ea%b2%bd%ec%9a%b0-%ec%84%b1%eb%8a%a5%ec%9d%b4-%ec%96%b4%eb%96%bb%ea%b2%8c-%eb%90%a0%ea%b9%8c-b-treebtree%ec%9d%98-%ea%b5%ac%ec%a1%b0%eb%a5%bc-%ea%b8%b0%eb%b0%98%ec%9c%bc%eb%a1%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;h2 id=&#34;b-트리의-경우&#34; &gt;B 트리의 경우
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ea%b2%bd%ec%9a%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;B 트리의 경우 내림차순 정렬을 시도할 경우, 모든 노드들을 역순으로 하나 하나 탐색해야 합니다. 따라서 B+ 트리 대비 낮은 성능을 보입니다.&lt;/p&gt;
&lt;h2 id=&#34;b-트리의-경우-1&#34; &gt;B+ 트리의 경우
&lt;span&gt;
    &lt;a href=&#34;#b-%ed%8a%b8%eb%a6%ac%ec%9d%98-%ea%b2%bd%ec%9a%b0-1&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;p&gt;B+ 트리의 경우 내림차순 정렬을 시도할 경우, 리프 노드만 역순으로 탐색하면 되고, 리프 노드들이 링크드 리스트 형태를 띄고 있으므로 순차 접근에 최적화 되어있어 더 높은 성능을 보입니다.&lt;/p&gt;
&lt;h1 id=&#34;참고-문서&#34; &gt;참고 문서
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0-%eb%ac%b8%ec%84%9c&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree&#34;&gt;Self-balancing binary search tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/cs/self-balancing-bts&#34;&gt;Self-Balancing Binary Search Trees | Baeldung on Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/B-tree&#34;&gt;B-tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/introduction-of-b-tree-2/&#34;&gt;Introduction of B-Tree - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/B%2B_tree&#34;&gt;B+ tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/introduction-of-b-tree/&#34;&gt;Introduction of B+ Tree - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/difference-between-b-tree-and-b-tree/&#34;&gt;Difference between B tree and B+ tree - GeeksforGeeks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.baeldung.com/cs/b-trees-vs-btrees&#34;&gt;The Difference Between B-trees and B+trees | Baeldung on Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/&#34;&gt;MySQL Ascending index vs Descending index - tech.kakao.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&#34;&gt;Red–black tree - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.allegro.tech/2023/11/how-does-btree-make-your-queries-fast.html&#34;&gt;How does B-tree make your queries fast? - allegro.tech&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

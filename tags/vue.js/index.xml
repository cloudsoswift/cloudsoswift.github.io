<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Vue.js on 오늘도 개발을 한다.</title>
    <link>https://cloudsoswift.github.io/tags/vue.js/</link>
    <description>오늘도 개발을 한다. (Vue.js)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Mon, 18 Nov 2024 10:37:02 +0900</lastBuildDate>
    
    <atom:link href="https://cloudsoswift.github.io/tags/vue.js/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Javascript]가상 DOM 알아보기(w. Diffing Algorithm, React Fiber, Compiler-Informed Virtual DOM)</title>
      <link>https://cloudsoswift.github.io/post/develop/javascript/virtual-dom/</link>
      <pubDate>Mon, 18 Nov 2024 10:37:02 +0900</pubDate>
      
      <guid>https://cloudsoswift.github.io/post/develop/javascript/virtual-dom/</guid>
      <description>&lt;h1 id=&#34;서론&#34; &gt;서론
&lt;span&gt;
    &lt;a href=&#34;#%ec%84%9c%eb%a1%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/orm712/CS-712&#34;&gt;CS 스터디&lt;/a&gt;에서 11월 8일 발표한 &lt;a href=&#34;https://github.com/orm712/CS-712/blob/main/08-JAVASCRIPT/13_Virtual-DOM/Readme.md&#34;&gt;가상 DOM&lt;/a&gt;에 대해 정리한 문서를 블로그에 공유하고자 한다.&lt;br&gt;
다만, 현재 문서 내용에는 &lt;code&gt;React Fiber의 실제 내부 동작&lt;/code&gt;이라든가, &lt;code&gt;React나 Vue.js를 제외한 다른 VDOM을 채택한 라이브러리들&lt;/code&gt;에 대한 내용이 빠져있다.&lt;br&gt;
또한, React 18 이후 &lt;code&gt;Concurrent Rendering을 통해 개선된 성능&lt;/code&gt;에 대한 얘기도 많이 부족하다고 생각하여, 추후 &lt;strong&gt;내용을 수정하여 보완&lt;/strong&gt;하거나, 이를 &lt;strong&gt;보충할만한 또 다른 포스트를 등록할 예정&lt;/strong&gt;이다.&lt;/p&gt;
&lt;h2 id=&#34;가상-dom&#34; &gt;가상 DOM?
&lt;span&gt;
    &lt;a href=&#34;#%ea%b0%80%ec%83%81-dom&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;가상 DOM(Virtual DOM, VDOM)&lt;/code&gt;이란, &lt;code&gt;UI의 가상 표현&lt;/code&gt;이 &lt;code&gt;메모리상에 저장&lt;/code&gt;되고, &lt;code&gt;ReactDOM&lt;/code&gt;과 같은 라이브러리를 통해 &lt;code&gt;실제 DOM과 동기화&lt;/code&gt;되는 &lt;strong&gt;&lt;code&gt;프로그래밍 개념&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이렇게 실제 DOM과 가상 DOM을 &lt;code&gt;동기화&lt;/code&gt;하는 과정을 &lt;code&gt;재조정(Reconciliation)&lt;/code&gt;이라고 함&lt;/li&gt;
&lt;li&gt;이러한 형태는 React의 &lt;code&gt;선언적 API 구조&lt;/code&gt;의 기반이 됨
&lt;ul&gt;
&lt;li&gt;사용자가 &lt;em&gt;UI가 어떤 상태가 되길 원하는지&lt;/em&gt; React에게 알려주면, React는 DOM이 해당 상태와 일치하는지 확인하고 갱신
&lt;ul&gt;
&lt;li&gt;이를 통해 &lt;code&gt;어트리뷰트 조작&lt;/code&gt;, &lt;code&gt;이벤트 핸들링&lt;/code&gt;, &lt;code&gt;수동 DOM 조작&lt;/code&gt;과 같은 작업들을 &lt;strong&gt;추상화&lt;/strong&gt;할 수 있음
&lt;ul&gt;
&lt;li&gt;개발자가 직접 해당 조작들을 &lt;strong&gt;하나하나 수행하지 않아도 됨&lt;/strong&gt;을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;따라서 개발자는 한 상태에서 다른 상태로의 전환을 &lt;code&gt;효율적으로 수행할 방안&lt;/code&gt;에 대해 &lt;strong&gt;&lt;code&gt;고민하지 않아도 됨&lt;/code&gt;&lt;/strong&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이러한 재조정 과정에 활용할 &lt;em&gt;컴포넌트 트리와 관련된 추가 정보들&lt;/em&gt;을 저장하기 위해 &lt;strong&gt;&lt;code&gt;Fiber&lt;/code&gt;&lt;/strong&gt; 라는 내부 객체를 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;주의-사항&#34; &gt;주의 사항
&lt;span&gt;
    &lt;a href=&#34;#%ec%a3%bc%ec%9d%98-%ec%82%ac%ed%95%ad&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;React 내부에서 &lt;code&gt;재조정&lt;/code&gt;과 &lt;code&gt;렌더링&lt;/code&gt;은 별도의 단계로 설계되어 있음
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;재조정&lt;/code&gt;: &lt;code&gt;재조정자(reconciler)&lt;/code&gt;가 트리의 어느 부분이 변경되었는지 계산&lt;/li&gt;
&lt;li&gt;&lt;code&gt;렌더링&lt;/code&gt;: &lt;code&gt;렌더러&lt;/code&gt;가 계산된 트리를 사용해 실제로 렌더링 된 애플리케이션을 업데이트&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이러한 구조를 통해, &lt;code&gt;ReactDOM&lt;/code&gt;과 &lt;code&gt;React Native&lt;/code&gt;는 동일한 &lt;code&gt;재조정자&lt;/code&gt;를 공유하되, 각각 &lt;code&gt;자체 렌더러&lt;/code&gt;를 사용
&lt;ul&gt;
&lt;li&gt;즉, DOM은 React 가 &lt;code&gt;렌더링할 수 있는 환경&lt;/code&gt; 중 하나에 불과함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;재조정reconciliation&#34; &gt;재조정(Reconciliation)?
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%ac%ec%a1%b0%ec%a0%95reconciliation&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;DOM을 &lt;code&gt;React Element 트리&lt;/code&gt;의 &lt;code&gt;가장 최근 상태&lt;/code&gt;와 일치하도록 &lt;strong&gt;&lt;code&gt;효율적으로 업데이트하는 방법&lt;/code&gt;&lt;/strong&gt; 을 결정하는 과정
&lt;ul&gt;
&lt;li&gt;React의 &lt;code&gt;render()&lt;/code&gt; 함수는 항상 최신 상태의 &lt;code&gt;React Element 트리&lt;/code&gt;를 반환하고자 함.
&lt;ul&gt;
&lt;li&gt;즉, &lt;code&gt;state&lt;/code&gt; 또는 &lt;code&gt;props&lt;/code&gt;가 업데이트될 때 마다 다른 &lt;code&gt;React Element 트리&lt;/code&gt;를 반환해야 함.&lt;/li&gt;
&lt;li&gt;이를 위해서는 React가 DOM을 가장 최근의 트리와 일치하도록 효율적으로 업데이트 할 수 있어야 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;즉, 한 트리에서 다른 트리로 변환하기 위한 &lt;strong&gt;&lt;code&gt;최소한의 연산 횟수&lt;/code&gt;&lt;/strong&gt; 가 발생하는 알고리즘이 필요
&lt;ul&gt;
&lt;li&gt;일반적인 알고리즘으로는 $O(n^3)$의 시간이 소요됨 &lt;a href=&#34;https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf&#34;&gt;#&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이를 위해 React에서는 아래 &lt;code&gt;두 가지 가정을 기반&lt;/code&gt;으로 한 휴리스틱 $O(n)$ 알고리즘을 사용
&lt;ol&gt;
&lt;li&gt;두 &lt;code&gt;다른 타입&lt;/code&gt;의 엘리먼트들은 &lt;code&gt;서로 다른 트리&lt;/code&gt;를 만든다.&lt;/li&gt;
&lt;li&gt;개발자는 &lt;code&gt;key&lt;/code&gt; prop을 통해 어떤 하위 엘리먼트가 여러 렌더링에 대해 안정적인지(동일한 형태를 띄는지) 힌트를 줄 수 있음&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;디핑-알고리즘diffing-algorithm&#34; &gt;디핑 알고리즘(Diffing Algorithm)
&lt;span&gt;
    &lt;a href=&#34;#%eb%94%94%ed%95%91-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98diffing-algorithm&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;p&gt;두 트리의 차이를 비교하는 &lt;code&gt;디핑 알고리즘&lt;/code&gt;에서는 먼저 &lt;code&gt;루트 엘리먼트&lt;/code&gt;를 비교하고, &lt;code&gt;루트 엘리먼트&lt;/code&gt;의 타입에 따라 다른 동작을 수행&lt;/p&gt;
&lt;h5 id=&#34;다른-타입의-엘리먼트&#34; &gt;다른 타입의 엘리먼트
&lt;span&gt;
    &lt;a href=&#34;#%eb%8b%a4%eb%a5%b8-%ed%83%80%ec%9e%85%ec%9d%98-%ec%97%98%eb%a6%ac%eb%a8%bc%ed%8a%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;루트 엘리먼트&lt;/code&gt;가 다른 타입을 가질때마다, React는 이전 트리를 허물고 새로운 트리를 처음부터 구축
&lt;ul&gt;
&lt;li&gt;ex) 루트 엘리먼트가 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;로 바뀌거나, &lt;code&gt;&amp;lt;Article&amp;gt;&lt;/code&gt;에서 &lt;code&gt;&amp;lt;Comment&amp;gt;&lt;/code&gt;로 바뀌는 등의 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이전 트리를 허물때, 이전 &lt;code&gt;DOM Node&lt;/code&gt;들도 파괴됨
&lt;ul&gt;
&lt;li&gt;이때, 해당 &lt;code&gt;DOM Node&lt;/code&gt;들의 컴포넌트 인스턴스들은 &lt;code&gt;componentWillUnmount()&lt;/code&gt;를 수신&lt;/li&gt;
&lt;li&gt;루트 아래 모든 컴포넌트들은 마운트 해제되고 상태가 파괴됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이후 새로운 트리를 만들 때, 새로운 &lt;code&gt;DOM Node&lt;/code&gt;들이 DOM에 삽입됨
&lt;ul&gt;
&lt;li&gt;이때, 해당 &lt;code&gt;DOM Node&lt;/code&gt;들의 컴포넌트 인스턴스들은 &lt;code&gt;UNSAFE_componentWillMount()&lt;/code&gt;를 수신한 뒤 &lt;code&gt;componentDidMount()&lt;/code&gt;를 수신&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이전 트리와 관련된 상태들은 모두 파괴됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;동일한-타입의-dom-엘리먼트&#34; &gt;동일한 타입의 DOM 엘리먼트
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%9d%bc%ed%95%9c-%ed%83%80%ec%9e%85%ec%9d%98-dom-%ec%97%98%eb%a6%ac%eb%a8%bc%ed%8a%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;같은 타입의 두 &lt;code&gt;React DOM 엘리먼트&lt;/code&gt;에 대해, React는 &lt;code&gt;DOM Node&lt;/code&gt;는 유지하되, &lt;code&gt;어트리뷰트&lt;/code&gt;를 살펴보고 &lt;code&gt;변경된 값&lt;/code&gt;만 갱신함&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 변경 전
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;className&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;before&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stuff&amp;#34;&lt;/span&gt; /&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 변경 후, React는 비교 후 바뀐 className만 반영
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;className&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;after&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;title&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;stuff&amp;#34;&lt;/span&gt; /&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;동일한-타입의-컴포넌트-엘리먼트&#34; &gt;동일한 타입의 컴포넌트 엘리먼트
&lt;span&gt;
    &lt;a href=&#34;#%eb%8f%99%ec%9d%bc%ed%95%9c-%ed%83%80%ec%9e%85%ec%9d%98-%ec%bb%b4%ed%8f%ac%eb%84%8c%ed%8a%b8-%ec%97%98%eb%a6%ac%eb%a8%bc%ed%8a%b8&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;컴포넌트가 갱신된 경우, 인스턴스는 동일하게 유지되므로 상태는 렌더링간에 변화가 발생하지 않음&lt;/li&gt;
&lt;li&gt;React는 기존 컴포넌트의 props를 새 엘리먼트와 일치하도록 갱신&lt;/li&gt;
&lt;li&gt;이후 &lt;code&gt;UNSAFE_componentWillReceiveProps()&lt;/code&gt;와 &lt;code&gt;UNSAFE_componentWillUpdate()&lt;/code&gt;, 그리고 &lt;code&gt;componentDidUpdate()&lt;/code&gt;를 호출&lt;/li&gt;
&lt;li&gt;이어서 &lt;code&gt;render()&lt;/code&gt;가 호출된 뒤 재귀적으로 디핑 알고리즘이 호출됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;자식에-대한-디핑-알고리즘-재귀&#34; &gt;자식에 대한 디핑 알고리즘 재귀
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%90%ec%8b%9d%ec%97%90-%eb%8c%80%ed%95%9c-%eb%94%94%ed%95%91-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98-%ec%9e%ac%ea%b7%80&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;기본적으로 React는 &lt;code&gt;DOM Node&lt;/code&gt;의 자식 노드들을 한 번에 순회하고, 차이가 있을 경우 갱신&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;key-prop&#34; &gt;&lt;code&gt;key&lt;/code&gt; prop
&lt;span&gt;
    &lt;a href=&#34;#key-prop&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;상기한 자식 노드간 비교를 나이브하게 구현할 경우, 아래와 같은 케이스에서 비효율적으로 렌더링이 이뤄짐&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 전
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Duke&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Villanova&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 후
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 만약 요소를 1대1로 비교할 경우, 위의 Duke는 Connecticut과, Villanova는 Duke와 비교하게 됨
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 따라서 이미 렌더링된 Duke와 Villanova를 재활용하지 못함
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Connecticut&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Duke&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Villanova&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;이를 방지하고자, React에서는 &lt;code&gt;key&lt;/code&gt; prop을 사용해 이전 트리에서 같은 &lt;code&gt;key&lt;/code&gt;를 가지는 자식과 비교하도록 함.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt;는 주로 데이터에서 발견할 수 있는 &lt;code&gt;고유한 ID&lt;/code&gt;나, 데이터를 해시한 값을 사용
&lt;ul&gt;
&lt;li&gt;배열에서의 항목의 &lt;code&gt;인덱스&lt;/code&gt; 값을 &lt;code&gt;key&lt;/code&gt;로 쓸 수도 있지만, 이는 배열의 재정렬이나 항목 간 이동 발생시 인덱스가 바뀌므로 원치않는 방식으로 갱신이 이뤄질 수 있음
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://legacy.reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key&#34;&gt;키를 index로 사용해 문제가 발생하는 케이스&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://legacy.reactjs.org/redirect-to-codepen/reconciliation/no-index-used-as-key&#34;&gt;위 경우를 보완한 케이스&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key&lt;/code&gt;는 &lt;code&gt;형제(sibling)&lt;/code&gt;사이에서만 고유하면 되며, 전역적으로 고유할 필요는 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;react의-디자인-원칙&#34; &gt;React의 디자인 원칙
&lt;span&gt;
    &lt;a href=&#34;#react%ec%9d%98-%eb%94%94%ec%9e%90%ec%9d%b8-%ec%9b%90%ec%b9%99&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://legacy.reactjs.org/docs/design-principles.html&#34;&gt;React의 디자인 원칙&lt;/a&gt;의 핵심은 다음과 같음
&lt;ul&gt;
&lt;li&gt;UI에 모든 업데이트가 &lt;strong&gt;&lt;code&gt;즉시 반영되어야 할 필요는 없음&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;React는 하나의 틱 동안 트리를 재귀적으로 순회하며 렌더링 함수 호출해 업데이트된 트리를 계산해야 함&lt;/li&gt;
&lt;li&gt;따라서 이들을 &lt;em&gt;즉시 반영하려다&lt;/em&gt; &lt;strong&gt;프레임이 떨어지거나&lt;/strong&gt;, &lt;strong&gt;UX가 불편해질 수&lt;/strong&gt; 있음&lt;/li&gt;
&lt;li&gt;따라서, &lt;strong&gt;일부 업데이트를 지연&lt;/strong&gt;시킬 수 있으며, 경우에 따라 &lt;strong&gt;데이터들을 통합해 일괄 업데이트&lt;/strong&gt; 할 수 있음(데이터가 프레임 속도보다 빠르게 도착한 경우)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;다른 유형의 업데이트들&lt;/code&gt;은 &lt;strong&gt;&lt;code&gt;다른 우선순위를 가져야 함&lt;/code&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;근본적으로 React는 &lt;code&gt;UI 구축&lt;/code&gt;을 위한 라이브러리이므로, &lt;em&gt;화면에서 벗어난 것이 있다면&lt;/em&gt; 이와 관련된 모든 로직들을 &lt;code&gt;지연&lt;/code&gt;시킬 수 있음&lt;/li&gt;
&lt;li&gt;예를 들어, 애니메이션 업데이트는 데이터 저장소의 값 업데이트보다 더 빨리 완료되어야 함&lt;/li&gt;
&lt;li&gt;이를 통해 프레임 저하를 방지할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;풀(pull) 기반 접근 방식*&lt;/code&gt;에서는 &lt;code&gt;작업 스케줄링*&lt;/code&gt; 방법을 &lt;code&gt;프레임워크(React)&lt;/code&gt;가 대신 결정해줌
&lt;ul&gt;
&lt;li&gt;이는 &lt;code&gt;푸시(push) 기반 접근방식*&lt;/code&gt;에서 &lt;code&gt;앱(프로그래머)&lt;/code&gt;가 직접 결정해야하는 것과 대조적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;풀 기반 접근 방식&lt;/code&gt;: 필요할 때까지 계산을 지연시킬 수 있는 접근 방식&lt;/li&gt;
&lt;li&gt;&lt;code&gt;푸시 기반 접근방식&lt;/code&gt;: 새 데이터를 사용할 수 있을 때마다, 계산이 이뤄지는 방식&lt;/li&gt;
&lt;li&gt;&lt;code&gt;작업 스케줄링&lt;/code&gt;: &lt;code&gt;작업*&lt;/code&gt;이 수행될 &lt;strong&gt;시점&lt;/strong&gt;을  결정하는 일련의 과정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;작업(work)&lt;/code&gt;: 수행되어야 하는 연산. 주로 업데이트(&lt;code&gt;setState&lt;/code&gt;와 같은)의 결과임&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;react-fiber--참고-문서httpsgithubcomacdlitereact-fiber-architecture&#34; &gt;React Fiber &lt;a href=&#34;https://github.com/acdlite/react-fiber-architecture&#34;&gt;# 참고 문서&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#react-fiber--%ec%b0%b8%ea%b3%a0-%eb%ac%b8%ec%84%9chttpsgithubcomacdlitereact-fiber-architecture&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;React Fiber&lt;/code&gt;란 React 16에 등장한 새로운 &lt;code&gt;재조정 엔진&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이를 통해 가상 DOM의 &lt;code&gt;점진적 렌더링(incremental rendering)&lt;/code&gt;을 가능케 하는 것이 목표.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;점진적 렌더링&lt;/code&gt;: 렌더링 작업을 청크로 분할하여, 여러 프레임에 걸쳐 분산하는 기능
&lt;ul&gt;
&lt;li&gt;우선순위가 높은 업데이트 사항부터 먼저 처리해나가는 렌더링 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이외에도 새로운 업데이트 발생시 기존의 작업을 &lt;code&gt;일시 중지(pause)&lt;/code&gt;, &lt;code&gt;중단(abort)&lt;/code&gt;,  &lt;code&gt;재사용(reuse)&lt;/code&gt; 할 수 있는 기능, 여러 유형의 업데이트에 &lt;code&gt;우선순위를 지정&lt;/code&gt;하는 기능, 동시성 프로그래밍을 위한 기본 기능 등의 주요기능이 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;등장-배경&#34; &gt;등장 배경
&lt;span&gt;
    &lt;a href=&#34;#%eb%93%b1%ec%9e%a5-%eb%b0%b0%ea%b2%bd&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Fiber 이전의 React는 &lt;code&gt;작업 스케줄링&lt;/code&gt;을 활용하지 않아, 업데이트가 발생하면 모든 하위 트리가 즉시 재렌더링 됨&lt;/li&gt;
&lt;li&gt;이를 방지하고자, React의 핵심 알고리즘을 개편하는 것이 Fiber의 목표&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;기능&#34; &gt;기능
&lt;span&gt;
    &lt;a href=&#34;#%ea%b8%b0%eb%8a%a5&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;h5 id=&#34;작업-스케줄링&#34; &gt;작업 스케줄링
&lt;span&gt;
    &lt;a href=&#34;#%ec%9e%91%ec%97%85-%ec%8a%a4%ec%bc%80%ec%a4%84%eb%a7%81&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;React에서 스케줄링을 활용할 수 있도록 해야 하므로, 다음의 기능이 구현되어야 함
&lt;ul&gt;
&lt;li&gt;작업의 &lt;code&gt;중지 및 재개&lt;/code&gt;가 가능해야 함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;다양한 유형의 작업들&lt;/code&gt;에게 &lt;code&gt;우선순위를 할당&lt;/code&gt;할 수 있어야 함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;이전에 완료한 작업의 값&lt;/code&gt;을 &lt;code&gt;재사용&lt;/code&gt;할 수 있어야 함&lt;/li&gt;
&lt;li&gt;더 이상 &lt;code&gt;필요하지 않은 작업&lt;/code&gt;은 &lt;code&gt;중단할 수 있어야 함&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이를 위해, 먼저 작업을 작은 단위인 &lt;code&gt;Fiber&lt;/code&gt;로 세분화 함
&lt;ul&gt;
&lt;li&gt;React 컴포넌트를 &lt;code&gt;v = f(d)&lt;/code&gt;의 꼴로 표현할 때, React 앱을 렌더링 하는건 &lt;em&gt;또 다른 함수에 대한 호출&lt;/em&gt;이 포함된 함수를 호출하는 것과 유사&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UI를 다룰 때, 한 번에 많은 작업을 실행하려하면 애니메이션 프레임이 떨어지게 됨&lt;/li&gt;
&lt;li&gt;이를 해결하기 위해 &lt;code&gt;최신 브라우저&lt;/code&gt;와 &lt;code&gt;React Native&lt;/code&gt;는 다음 두 API를 구현하여 사용
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;requestIdleCallback&lt;/code&gt;: 낮은 우선순위의 함수를 &lt;code&gt;유휴 기간(Idle Period)&lt;/code&gt;동안 호출되도록 스케줄링&lt;/li&gt;
&lt;li&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;: 높은 우선순위의 함수를 &lt;code&gt;다음 애니메이션 프레임&lt;/code&gt;에 호출되도록 스케줄링&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이러한 API의 구현은 렌더링 작업을 &lt;code&gt;증분 단위(Incremental Unit)&lt;/code&gt;로 나눌 수 있을때 가능
&lt;ul&gt;
&lt;li&gt;일반적인 함수 호출 방식인 &lt;code&gt;콜 스택&lt;/code&gt;에 의존하게 되면, 스택이 비워질 때까지 작업을 수행하므로 이러한 동작이 불가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;React Fiber&lt;/code&gt;는 &lt;code&gt;React Component&lt;/code&gt;에 특화된, 재구현된 &lt;code&gt;콜 스택&lt;/code&gt;이라고 볼 수 있으며, &lt;code&gt;Fiber&lt;/code&gt;는 하나의 가상 스택 프레임이라고 볼 수 있음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;React Fiber&lt;/code&gt;의 구현을 통해 &lt;code&gt;스택 프레임&lt;/code&gt;을 &lt;code&gt;메모리에 보관&lt;/code&gt;해두었다, &lt;code&gt;다시 실행&lt;/code&gt;하는 것이 &lt;code&gt;가능&lt;/code&gt;해짐
&lt;ul&gt;
&lt;li&gt;이는 &lt;code&gt;React Fiber&lt;/code&gt;의 목표인 &lt;code&gt;작업 스케줄링&lt;/code&gt;을 가능케 하는것은 물론, &lt;code&gt;동시성&lt;/code&gt;, &lt;code&gt;오류 경계(Error Boundary)&lt;/code&gt;과 같은 기능도 사용할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;fiber의-구조&#34; &gt;Fiber의 구조
&lt;span&gt;
    &lt;a href=&#34;#fiber%ec%9d%98-%ea%b5%ac%ec%a1%b0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Fiber&lt;/code&gt;는 &lt;code&gt;컴포넌트&lt;/code&gt;, &lt;code&gt;입력(input)&lt;/code&gt;, &lt;code&gt;출력(output)&lt;/code&gt;에 대한 정보를 포함하는 &lt;code&gt;JS 객체&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;스택 프레임&lt;/code&gt;이면서, &lt;code&gt;컴포넌트의 인스턴스&lt;/code&gt;라고 할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fiber&lt;/code&gt;의 &lt;code&gt;핵심 필드&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;React 엘리먼트로부터 복사해온 &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt; 값&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;은 &lt;code&gt;Fiber&lt;/code&gt;에 대응되는 컴포넌트의 유형에 대해 설명&lt;/li&gt;
&lt;li&gt;두 필드 모두 &lt;code&gt;재조정&lt;/code&gt;과정에서 재사용 가능 여부를 판별할 때 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;child&lt;/code&gt;, &lt;code&gt;sibling&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;다른 &lt;code&gt;Fiber&lt;/code&gt;를 가리키는 필드로, 재귀적 트리 구조를 묘사함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;child&lt;/code&gt;: 컴포넌트의 &lt;code&gt;render&lt;/code&gt; 메서드가 반환하는 값에 대응됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sibling&lt;/code&gt;: 컴포넌트의 &lt;code&gt;render&lt;/code&gt; 메서드가 여러 자식을 반환하는 경우, 자식 Fiber들을 단방향 링크드리스트 형태로 묶어놓은 값
&lt;ul&gt;
&lt;li&gt;이때, 첫 번째 자식이 링크드리스트의 head임&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;프로그램이 현재 Fiber를 처리하고, 반환해야 할 Fiber 값
&lt;ul&gt;
&lt;li&gt;개념적으로, 스택 프레임의 &lt;code&gt;반환 주소(return address)&lt;/code&gt;와 동일&lt;/li&gt;
&lt;li&gt;즉, 쉽게 &lt;code&gt;부모 Fiber&lt;/code&gt;라고 보면 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pendingProps&lt;/code&gt;, &lt;code&gt;memoizedProps&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;개념적으로, &lt;code&gt;props&lt;/code&gt;는 함수의 인자값&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pendingProps&lt;/code&gt;는 실행 시작 시점에 설정되고, &lt;code&gt;memoizedProps&lt;/code&gt;는 종료 시점에 설정됨&lt;/li&gt;
&lt;li&gt;만약 두 값이 같다면, Fiber의 이전 출력 값을 재사용할 수 있다는 뜻&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pendingWorkPriority&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Fiber가 내포하고 있는 작업의 우선순위를 나타내는 숫자 값&lt;/li&gt;
&lt;li&gt;0인 &lt;code&gt;NoWork&lt;/code&gt;를 제외하고, 값이 클수록 우선순위가 낮음을 의미&lt;/li&gt;
&lt;li&gt;스케줄러는 이 우선순위 값을 사용해, 다음으로 수행할 작업을 탐색함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alternate&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;이 Fiber의 대체 Fiber를 의미하는 필드&lt;/li&gt;
&lt;li&gt;컴포넌트 인스턴스에는 대응되는 최대 2개의 Fiber가 존재
&lt;ul&gt;
&lt;li&gt;즉, &lt;code&gt;현재 Fiber(플러시* 된)&lt;/code&gt;와 &lt;code&gt;작업 진행 중인 Fiber&lt;/code&gt;가 존재
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;플러시&lt;/code&gt;: &lt;code&gt;출력(output)&lt;/code&gt;을 화면에 &lt;code&gt;렌더링&lt;/code&gt;하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;둘은 각각 서로에게 대응됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fiber의 &lt;code&gt;alternate&lt;/code&gt;는 &lt;code&gt;cloneFiber&lt;/code&gt;라는 함수를 이용해 만들어지며, 이미 존재하는 경우 해당 값을 재사용함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;output&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;개념적으로 &lt;code&gt;함수의 반환값&lt;/code&gt;에 대응되는 개념&lt;/li&gt;
&lt;li&gt;모든 &lt;code&gt;Fiber&lt;/code&gt;는 &lt;code&gt;output&lt;/code&gt;이 있지만, 오직 &lt;code&gt;리프 노드&lt;/code&gt;에서만 &lt;code&gt;호스트 컴포넌트*&lt;/code&gt;에 의해 생성됨
&lt;ul&gt;
&lt;li&gt;생성된 &lt;code&gt;output&lt;/code&gt;은 트리 위로 전달 됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;호스트 컴포넌트&lt;/code&gt;: React 앱의 &lt;code&gt;리프 노드&lt;/code&gt;. &lt;code&gt;렌더링 환경&lt;/code&gt;에 따라 다르지만, 브라우저 환경에서는 보통 &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;span&lt;/code&gt;같은 엘리먼트를 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;output&lt;/code&gt;은 렌더러가 &lt;code&gt;렌더링 환경&lt;/code&gt;에게 &lt;code&gt;변경 사항을 플러시&lt;/code&gt; 할 수 있도록 최종적으로 렌더러에게 전달되어야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;react-18-이후의-가상-dom&#34; &gt;React 18 이후의 가상 DOM
&lt;span&gt;
    &lt;a href=&#34;#react-18-%ec%9d%b4%ed%9b%84%ec%9d%98-%ea%b0%80%ec%83%81-dom&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;상기한 디핑 알고리즘 방식은 크고, 복잡한 컴포넌트 계층 구조에 대해서는 한계가 존재
&lt;ul&gt;
&lt;li&gt;Javascript의 &lt;code&gt;단일 스레드&lt;/code&gt;라는 구조적 한계 때문에, UI 업데이트 관련 코드 동작이 오래 걸리면 화면이 충분히 빠르게 갱신되지 못하고 끊김이 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이를 보완하고자, &lt;code&gt;React 18&lt;/code&gt;에서 &lt;code&gt;Concurrent Mode&lt;/code&gt;의 이점을 활용한 개선된 &lt;code&gt;재조정(Reconciliation)&lt;/code&gt; 알고리즘을 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Concurrent Mode&lt;/code&gt;를 통해 React는 메인 스레드가 블락되지 않고도 여러 작업들을 병렬적으로 수행할 수 있게 됨&lt;/li&gt;
&lt;li&gt;React 18의 &lt;code&gt;재조정 알고리즘&lt;/code&gt;은 다음과 같음
&lt;ul&gt;
&lt;li&gt;먼저 &lt;code&gt;재조정 작업&lt;/code&gt;을 &lt;code&gt;fiber&lt;/code&gt;라고 부르는 작은 유닛들로 나누고, 이들의 중요도에 따라 &lt;code&gt;우선순위&lt;/code&gt;를 메김&lt;/li&gt;
&lt;li&gt;이후 React는 &lt;code&gt;우선순위를 기반&lt;/code&gt;으로 재조정 프로세스를 효율적으로 중단 및 재개함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vuejs의-가상-dom--참고-문서httpsvuejsorgguideextrasrendering-mechanism&#34; &gt;Vue.js의 가상 DOM &lt;a href=&#34;https://vuejs.org/guide/extras/rendering-mechanism&#34;&gt;# 참고 문서&lt;/a&gt;
&lt;span&gt;
    &lt;a href=&#34;#vuejs%ec%9d%98-%ea%b0%80%ec%83%81-dom--%ec%b0%b8%ea%b3%a0-%eb%ac%b8%ec%84%9chttpsvuejsorgguideextrasrendering-mechanism&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Vue.js 역시 &lt;code&gt;가상 DOM&lt;/code&gt;을 사용
&lt;ul&gt;
&lt;li&gt;다만, React와 여타 다른 가상 DOM을 구현하는 라이브러리들과 다른점이 존재
&lt;ul&gt;
&lt;li&gt;바로 &lt;code&gt;컴파일 시간&lt;/code&gt;에 템플릿을 &lt;code&gt;정적으로 분석&lt;/code&gt;해, &lt;code&gt;가상 DOM&lt;/code&gt;의 런타임 성능을 향상시키고자 몇가지 &lt;code&gt;최적화&lt;/code&gt;를 진행한다는 점&lt;/li&gt;
&lt;li&gt;이를 Vue.js에서는 &lt;code&gt;컴파일러에 알려진 가상돔 최적화(Compiler-Informed Virtual DOM)&lt;/code&gt; 라고 부름&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;최적화 기법&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;정적 호이스팅 (Static Hoisting)&lt;/code&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt; &amp;lt;!-- 호이스팅 됨 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt; &amp;lt;!-- 호이스팅 됨 --&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;div&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;dynamic&lt;/span&gt; }}&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/div&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;템플릿에서 동적 바인딩이 포함되지 않은 부분에 대한 비교를 건너 뜀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;패치 플래그&lt;/code&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;vnode&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;patchFlag&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PatchFlags&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CLASS&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 2 */&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &lt;span style=&#34;color:#75715e&#34;&gt;// 노드의 패치 플래그에서 클래스 변동에 대한 비트 값이 1인 경우
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	  &lt;span style=&#34;color:#75715e&#34;&gt;// 클래스 값에 변동이 생겼음을 알 수 있음
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;클래스, 텍스트, 스타일, props 등의 &lt;code&gt;요소&lt;/code&gt;들에 대해 &lt;code&gt;변동이 있는지를 기록&lt;/code&gt;하는 &lt;code&gt;플래그&lt;/code&gt;인 &lt;code&gt;패치 플래그&lt;/code&gt;를 통해 어떤 업데이트 작업이 필요한지 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;트리 병합 (Tree Flattening)&lt;/code&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-jsx&#34; data-lang=&#34;jsx&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;루트&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;블록&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;         &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;추적&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;안&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;됨&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;   &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;추적됨&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;                  &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;추적&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;안&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;됨&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	    &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt; }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;추적됨&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	  &amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;!--&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;위&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;경우&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;트리&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;병합을&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;통해&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;아래와&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;같이&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;평탄화된&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;형태로&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;최적화&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;할&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;수&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;있음&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;--&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;루트&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;블록&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;{{ &lt;span style=&#34;color:#a6e22e&#34;&gt;bar&lt;/span&gt; }}&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;div&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;트리에서 &lt;code&gt;정적인 자식 노드들(동적 바인딩이 포함되지 않은)은 제외&lt;/code&gt;하고, &lt;code&gt;동적 하위 노드&lt;/code&gt;들만 &lt;code&gt;포함&lt;/code&gt;하는 &lt;code&gt;트리 병합&lt;/code&gt;을 수행해, 가상 DOM 재조정 중에 통과해야 하는 노드의 수를 크게 줄임&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;참고&#34; &gt;참고
&lt;span&gt;
    &lt;a href=&#34;#%ec%b0%b8%ea%b3%a0&#34;&gt;
        &lt;svg viewBox=&#34;0 0 28 23&#34; height=&#34;100%&#34; width=&#34;19&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt;&lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34; fill=&#34;none&#34; stroke-linecap=&#34;round&#34; stroke-miterlimit=&#34;10&#34; stroke-width=&#34;2&#34;/&gt;&lt;/svg&gt;
    &lt;/a&gt;
&lt;/span&gt;
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://legacy.reactjs.org/docs/faq-internals.html&#34;&gt;Virtual DOM and Internals – React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://legacy.reactjs.org/docs/reconciliation.html&#34;&gt;Reconciliation – React&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/acdlite/react-fiber-architecture&#34;&gt;acdlite/react-fiber-architecture: A description of React&amp;rsquo;s new core algorithm, React Fiber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://vuejs.org/guide/extras/rendering-mechanism&#34;&gt;Rendering Mechanism | Vue.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
